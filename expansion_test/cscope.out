cscope 15 $HOME/Documents/GitHub/minishell/rita/expansion_test -c -q 0000000348 0000069346
	@envp_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_env
(
t_env
 **
head
)

16 
t_env
 *
ptr
;

17 
t_env
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
var_name
);

27 
	`free
(
tmp
->
var_value
);

28 
	`free
(
tmp
);

30 *
head
 = 
NULL
;

31 
	}
}

40 
t_env
 *
	$new_env
(char *
envp
)

42 
t_env
 *
env
;

43 int 
end
;

44 int 
start
;

46 if (!
envp
)

47 return (
NULL
);

48 
start
 = 0;

49 
end
 = 0;

50 
env
 = 
	`malloc
(sizeof(
t_env
));

51 if (!
env
)

52 return (
	`malloc_error_print_message
(
	`strerror
(
errno
)), 
NULL
);

53 while (
envp
[
end
] != '=')

54 
end
++;

55 
env
->
var_name
 = 
	`ft_substr
(
envp
, 0, 
end
);

56 if (!
env
->
var_name
)

57 return (
NULL
);

58 
end
++;

59 
start
 = 
end
;

60 while (
envp
[
end
] != '\0')

61 
end
++;

62 
env
->
var_value
 = 
	`ft_substr
(
envp
, 
start
, 
end
 - start);

63 if (!
env
->
var_value
)

64 return (
	`malloc_error_print_message
("ft stubstr failed"), 
NULL
);

65 
env
->
next
 = 
NULL
;

66 return (
env
);

67 
	}
}

72 int 
	$link_env
(
t_env
 **
head
, t_env *
last
)

74 
t_env
 *
ptr
;

76 if (!
last
)

78 
ptr
 = *
head
;

79 while (
ptr
)

81 if (!
ptr
->
next
)

83 
ptr
 = ptr->
next
;

85 
ptr
->
next
 = 
last
;

87 
	}
}

100 
t_env
 *
	$get_envp
(char **
envp
)

102 
t_env
 **
head
;

103 
t_env
 *
env
;

104 int 
i
;

106 
i
 = 0;

107 
head
 = 
NULL
;

108 if (!
envp
)

109 return (
NULL
);

110 
env
 = 
	`new_env
(
envp
[
i
]);

111 if (!
env
)

112 return (
NULL
);

113 
head
 = &
env
;

114 
i
++;

115 while (
envp
[
i
])

117 if (
	`link_env
(
head
, 
	`new_env
(
envp
[
i
])) < 0)

118 return (
	`free_env
(
head
), 
NULL
);

119 
i
++;

121 return (*
head
);

122 
	}
}

	@is_dollar.c

12 #include 
	~"minishell.h
"

16 int 
	$is_dollar
(char 
c
)

18 if (
c
 == '$')

21 
	}
}

	@is_operator.c

12 #include 
	~"minishell.h
"

16 int 
	$is_pipeline
(char 
c
)

18 if (
c
 == '|')

21 
	}
}

25 int 
	$is_lchevron
(char 
c
)

27 if (
c
 == '<')

30 
	}
}

32 int 
	$is_rchevron
(char 
c
)

34 if (
c
 == '>')

37 
	}
}

39 int 
	$is_chevron
(char 
c
)

41 if (
	`is_lchevron
(
c
) || 
	`is_rchevron
(c))

44 
	}
}

48 int 
	$is_operator
(char 
c
)

50 if (
	`is_pipeline
(
c
) || 
	`is_chevron
(c))

53 
	}
}

	@is_question.c

12 #include 
	~"minishell.h
"

14 int 
	$is_question
(char 
c
)

16 if (
c
 == '?')

19 
	}
}

21 int 
	$is_punct
(char 
c
)

23 if ((
c
 >= 33 && c <= 47) || \

24 (
c
 >= 58 && c <= 64) || \

25 (
c
 >= 91 && c <= 94) || \

26 (
c
 == 96) || \

27 (
c
 >= 123 && c <= 126))

30 
	}
}

	@is_quote.c

12 #include 
	~"minishell.h
"

16 int 
	$is_double_quote
(char 
c
)

18 if (
c
 == '\"')

21 
	}
}

23 int 
	$is_simple_quote
(char 
c
)

25 if (
c
 == '\'')

28 
	}
}

30 int 
	$is_quote
(char 
c
)

32 if (
	`is_double_quote
(
c
) || 
	`is_simple_quote
(c))

35 
	}
}

	@is_token.c

12 #include 
	~"minishell.h
"

16 int 
	$is_metacharacter
(char 
c
)

18 if (
	`is_blank
(
c
) || 
	`is_newline
(c) || 
	`is_operator
(c))

21 
	}
}

25 int 
	$is_delimiter
(char 
c
)

27 if (
	`is_metacharacter
(
c
))

30 
	}
}

34 int 
	$is_word
(char 
c
)

36 if (!
	`is_delimiter
(
c
))

39 
	}
}

	@is_white_space.c

12 #include 
	~"minishell.h
"

14 int 
	$is_blank
(char 
c
)

16 if (
c
 == ' ' || c == '\t')

19 
	}
}

21 int 
	$is_newline
(char 
c
)

23 if (
c
 == '\n')

26 
	}
}

28 int 
	$is_white_space
(char 
c
)

30 if (
	`is_blank
(
c
) || 
	`is_newline
(c))

33 
	}
}

	@libft/ft_printf/ft_count_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_int
(int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

	@libft/ft_printf/ft_count_unsigned_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_unsigned_int
(unsigned int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 else if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 return (
count
);

30 
	}
}

	@libft/ft_printf/ft_dprintf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 
fd
, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 
fd
, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 
fd
, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 
fd
, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 
fd
, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_dprintf
(int 
fd
, const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 
fd
, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 
fd
, &
count
);

50 
	`ft_format_specifier_fd
(
last
[
i
 + 1], 
ap
, &
count
, 
fd
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@libft/ft_printf/ft_printf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier
(char 
format
, 
va_list
 
ap
, int *
count
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 1, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 1, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 1, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 1, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 1, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 1, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 1, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_printf
(const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 1, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 1, &
count
);

50 
	`ft_format_specifier
(
last
[
i
 + 1], 
ap
, &
count
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@libft/ft_printf/ft_printf_address.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
);

16 void 
	$ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
)

18 
	`ft_printf_str
("0x", 
fd
, 
count
);

19 
	`ft_put_uintptr_fd
(
n
, 
fd
, 
count
);

20 
	}
}

22 void 
	$ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
)

24 if (
n
 > 15)

26 
	`ft_put_uintptr_fd
(
n
 / 16, 
fd
, 
count
);

27 
	`ft_put_uintptr_fd
(
n
 % 16, 
fd
, 
count
);

29 if (
n
 < 10)

30 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

31 else if (
n
 > 9 && n < 16)

32 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

33 
	}
}

	@libft/ft_printf/ft_printf_char.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_char
(char 
c
, int 
fd
, int *
count
)

16 
	`ft_putchar_fd
(
c
, 
fd
);

17 *
count
 += 1;

18 
	}
}

	@libft/ft_printf/ft_printf_hexa.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
)

16 if (
n
 > 15)

18 
	`ft_printf_hexa
(
n
 / 16, 
fd
, 
count
, 
c
);

19 
	`ft_printf_hexa
(
n
 % 16, 
fd
, 
count
, 
c
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

25 if (
c
 == 'x')

26 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

27 else if (
c
 == 'X')

28 
	`ft_printf_char
(
n
 + 55, 
fd
, 
count
);

30 
	}
}

	@libft/ft_printf/ft_printf_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_int
(int 
n
, int 
fd
, int *
count
)

16 
	`ft_putnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_int
(
n
);

18 
	}
}

	@libft/ft_printf/ft_printf_str.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_str
(char *
s
, int 
fd
, int *
count
)

16 int 
i
;

18 
i
 = 0;

19 if (
s
 != 
NULL
)

21 while (
s
[
i
] != '\0')

22 
i
++;

23 
	`ft_putstr_fd
(
s
, 
fd
);

27 
	`ft_putstr_fd
("(null)", 1);

28 
i
 = 6;

30 *
count
 += 
i
;

31 
	}
}

	@libft/ft_printf/ft_printf_unsint.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
)

16 
	`ft_put_unsnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_unsigned_int
(
n
);

18 
	}
}

	@libft/ft_printf/ft_put_hexanbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_hexanbr_fd
(unsigned int 
n
, int 
fd
, int *
count
)

16 if (
n
 > 15)

18 
	`ft_put_hexanbr_fd
(
n
 / 16, 
fd
, 
count
);

19 
	`ft_put_hexanbr_fd
(
n
 % 16, 
fd
, 
count
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

24 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

25 
	}
}

	@libft/ft_printf/ft_put_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_put_int
(int 
n
, int 
fd
, int *
count
)

16 int 
a
;

18 
a
 = *
count
;

19 
	`ft_putnbr_fd
(
n
, 
fd
);

20 
a
 += 
	`ft_count_int
(
n
);

21 return (
a
);

22 
	}
}

	@libft/ft_printf/ft_put_unsnbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
)

16 if (
n
 > 9)

18 
	`ft_put_unsnbr_fd
(
n
 / 10, 
fd
);

19 
	`ft_put_unsnbr_fd
((
n
 % 10), 
fd
);

22 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

23 
	}
}

	@libft/get_next_line/get_next_line.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$create_nextline
(char *
result
, char *
line
)

16 int 
start
;

17 int 
size
;

18 char *
nextline
;

20 
start
 = 
	`ft_strlen_int
(
result
);

21 
size
 = 
	`ft_strlen_int
(
line
);

22 
size
 = size - 
start
;

23 if (
size
 == 0)

25 
	`free
 (
line
);

26 return (
NULL
);

28 
nextline
 = 
	`malloc
((
size
 + 1) * sizeof(char));

29 if (!
nextline
)

30 return (
NULL
);

31 
size
 = 0;

32 while (
line
[
start
] != '\0')

34 
nextline
[
size
] = 
line
[
start
];

35 
size
++;

36 
start
++;

38 
nextline
[
size
] = '\0';

39 
	`free
(
line
);

40 return (
nextline
);

41 
	}
}

55 char *
	$create_result
(char *
line
)

57 int 
i
;

58 char *
result
;

60 
i
 = 
	`there_is_n
(
line
);

61 if (
i
 == -1 && *
line
)

62 
i
 = 
	`ft_strlen_int
(
line
);

63 else if (
i
 == -1 && !*
line
)

64 return (
NULL
);

65 
result
 = 
	`malloc
((
i
 + 1) * sizeof(char));

66 if (!
result
)

67 return (
NULL
);

68 
i
 = 0;

69 while (
line
[
i
] != '\0')

71 
result
[
i
] = 
line
[i];

72 if (
line
[
i
] == '\n')

74 
i
++;

77 
i
++;

79 
result
[
i
] = '\0';

80 return (
result
);

81 
	}
}

94 char *
	$read_fd
(char *
line
, int 
fd
, int *
error
)

96 char *
buffer
;

97 int 
ret
;

99 
ret
 = 1;

100 
	`prepare_forstash
(&
line
, &
buffer
);

101 while (
ret
 > 0 && 
	`there_is_n
(
buffer
) == -1 && there_is_n(
line
) == -1)

103 
ret
 = (int)
	`read
(
fd
, 
buffer
, 
BUFFER_SIZE
);

104 if (
ret
 < 0)

106 
	`free
(
buffer
);

107 *
error
 = -1;

108 return (
NULL
);

110 if (
ret
 == 0)

112 *
error
 = 0;

115 
buffer
[
ret
] = '\0';

116 
line
 = 
	`ft_join
(line, 
buffer
);

118 
	`free
(
buffer
);

119 return (
line
);

120 
	}
}

130 int 
	$check_errors
(int 
fd
, char **
line
)

132 if (
fd
 < 0 || 
BUFFER_SIZE
 <= 0 || 
	`read
(fd, 0, 0) < 0)

134 
	`free
(*
line
);

135 *
line
 = 0;

139 
	}
}

150 char *
	$get_next_line
(int 
fd
)

152 static char *
line
;

153 char *
result
;

154 int 
error
;

156 
error
 = 
	`check_errors
(
fd
, &
line
);

157 if (
error
 == 0)

158 return (
NULL
);

159 
line
 = 
	`read_fd
(line, 
fd
, &
error
);

160 if (
error
 == -1 || (error == 0 && !*
line
))

162 
	`free
(
line
);

163 
line
 = 0;

164 return (
NULL
);

166 if (!
line
)

167 return (
NULL
);

168 
result
 = 
	`create_result
(
line
);

169 if (!
result
)

171 
line
 = 0;

172 
	`free
(
line
);

174 
line
 = 
	`create_nextline
(
result
, line);

175 return (
result
);

176 
	}
}

	@libft/get_next_line/get_next_line_bonus.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$get_next_line_maxopen
(int 
fd
)

16 static char *
line
[
OPEN_MAX
];

17 char *
result
;

18 int 
error
;

20 
error
 = 
	`check_errors
(
fd
, &
line
[fd]);

21 if (
error
 == 0)

22 return (
NULL
);

23 
line
[
fd
] = 
	`read_fd
(line[fd], fd, &
error
);

24 if (
error
 == -1 || (error == 0 && !*
line
[
fd
]))

26 
	`free
(
line
[
fd
]);

27 
line
[
fd
] = 0;

28 return (
NULL
);

30 if (!
line
[
fd
])

31 return (
NULL
);

32 
result
 = 
	`create_result
(
line
[
fd
]);

33 if (!
result
)

35 
line
[
fd
] = 0;

36 
	`free
(
line
[
fd
]);

38 
line
[
fd
] = 
	`create_nextline
(
result
, line[fd]);

39 return (
result
);

40 
	}
}

	@libft/get_next_line/get_next_line_utils.c

12 #include 
	~"../includes/get_next_line.h
"

14 void 
	$prepare_forstash
(char **
line
, char **
buffer
)

16 *
buffer
 = 
	`ft_calloc_count
(
BUFFER_SIZE
);

17 if (*
line
 == 
NULL
)

18 *
line
 = 
	`ft_calloc_count
(0);

19 
	}
}

21 char *
	$ft_join
(char *
line
, char *
buffer
)

23 int 
i
;

24 int 
j
;

25 char *
stash
;

27 if (!
line
 || !
buffer
)

28 return (
NULL
);

29 
i
 = 
	`ft_strlen_int
(
line
);

30 
j
 = 
	`ft_strlen_int
(
buffer
);

31 
stash
 = 
	`malloc
((
i
 + 
j
 + 1) * sizeof(char));

32 if (!
stash
)

33 return (
NULL
);

34 
i
 = 0;

35 
j
 = 0;

36 while (
line
[
i
] != '\0')

38 
stash
[
i
] = 
line
[i];

39 
i
++;

41 while (
buffer
[
j
] != '\0')

42 
stash
[
i
++] = 
buffer
[
j
++];

43 
stash
[
i
] = '\0';

44 
	`free
(
line
);

45 return (
stash
);

46 
	}
}

48 char *
	$ft_calloc_count
(int 
count
)

50 char *
string
;

51 int 
i
;

53 
i
 = 0;

54 
string
 = 
	`malloc
((
count
 + 1) * sizeof(char));

55 if (!
string
)

56 return (
NULL
);

57 while (
i
 <= 
count
)

59 
string
[
i
] = '\0';

60 
i
++;

62 return (
string
);

63 
	}
}

65 int 
	$ft_strlen_int
(const char *
string
)

67 int 
i
;

69 
i
 = 0;

70 while (
string
[
i
] != '\0')

71 
i
++;

72 return (
i
);

73 
	}
}

75 int 
	$there_is_n
(char *
line
)

77 int 
i
;

79 
i
 = 0;

80 while (
line
[
i
] != '\0')

82 if (
line
[
i
] == '\n')

83 return (
i
 + 1);

84 
i
++;

87 
	}
}

	@libft/includes/ft_printf.h

12 #ifndef 
FT_PRINTF_H


13 #define 
	#FT_PRINTF_H


	)

15 #include 
	~"libft.h
"

16 #include 
	~<stdarg.h
>

18 int 
ft_printf
(const char *
last
, ...);

19 void 
ft_printf_char
(char 
c
, int 
fd
, int *
count
);

20 void 
ft_printf_str
(char *
s
, int 
fd
, int *
count
);

21 void 
ft_printf_int
(int 
n
, int 
fd
, int *
count
);

22 int 
ft_count_int
(int 
n
);

23 void 
ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
);

24 void 
ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
);

25 int 
ft_count_unsigned_int
(unsigned int 
n
);

26 void 
ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
);

27 void 
ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
);

31 void 
ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
);

32 int 
ft_dprintf
(int 
fd
, const char *
last
, ...);

	@libft/includes/get_next_line.h

12 #ifndef 
GET_NEXT_LINE_H


13 #define 
	#GET_NEXT_LINE_H


	)

15 #include 
	~<unistd.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<limits.h
>

19 #ifndef 
BUFFER_SIZE


20 #define 
	#BUFFER_SIZE
 42

	)

23 char *
ft_calloc_count
(int 
count
);

24 int 
ft_strlen_int
(const char *
string
);

25 char *
ft_join
(char *
nextline
, char *
buffer
);

26 int 
there_is_n
(char *
line
);

27 char *
read_fd
(char *
nextline
, int 
fd
, int *
error
);

28 char *
create_result
(char *
line
);

29 char *
create_nextline
(char *
result
, char *
line
);

30 char *
get_next_line
(int 
fd
);

31 char *
get_next_line_maxopen
(int 
fd
);

32 int 
check_errors
(int 
fd
, char **
line
);

33 void 
prepare_forstash
(char **
line
, char **
buffer
);

	@libft/includes/libft.h

12 #ifndef 
LIBFT_H


13 #define 
	#LIBFT_H


	)

15 #include 
	~<stddef.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<unistd.h
>

18 #include 
	~"ft_printf.h
"

19 #include 
	~"get_next_line.h
"

21 typedef struct 
	ss_list


23 void *
	mcontent
;

24 struct 
s_list
 *
	mnext
;

25 } 
	tt_list
;

27 void *
ft_memset
(void *
b
, int 
c
, 
size_t
 
len
);

28 void 
ft_bzero
(void *
s
, 
size_t
 
n
);

29 void *
ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
);

30 void *
ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
);

31 void *
ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
);

32 int 
ft_isalpha
(int 
c
);

33 int 
ft_isdigit
(int 
c
);

34 int 
ft_isalnum
(int 
c
);

35 int 
ft_isascii
(int 
c
);

36 int 
ft_isprint
(int 
c
);

37 
size_t
 
ft_strlen
(const char *
s
);

38 int 
ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
);

39 char *
ft_strcpy
(char *
dst
, const char *
src
);

40 
size_t
 
ft_strlcpy
(char *
dst
, const char *
src
, size_t 
dstsize
);

41 
size_t
 
ft_strlcat
(char *
dst
, const char *
src
, size_t 
dstsize
);

42 char *
ft_strchr
(const char *
s
, int 
c
);

43 char *
ft_strrchr
(const char *
s
, int 
c
);

44 char *
ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
);

45 int 
ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
);

46 int 
ft_toupper
(int 
c
);

47 int 
ft_tolower
(int 
c
);

48 int 
ft_atoi
(const char *
str
);

49 void *
ft_calloc
(
size_t
 
count
, size_t 
size
);

50 char *
ft_strdup
(const char *
s1
);

51 char *
ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
);

52 char *
ft_strjoin
(char const *
s1
, char const *
s2
);

53 char *
ft_strtrim
(char const *
s1
, char const *
set
);

54 char **
ft_split
(char const *
s
, char 
c
);

55 char *
ft_itoa
(int 
n
);

56 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char));

57 void 
	`ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*));

58 void 
	`ft_putchar_fd
(char 
c
, int 
fd
);

59 void 
	`ft_putstr_fd
(char *
s
, int 
fd
);

60 void 
	`ft_putendl_fd
(char *
s
, int 
fd
);

61 void 
	`ft_putnbr_fd
(int 
n
, int 
fd
);

64 
t_list
 *
	`ft_lstnew
(void *
content
);

65 void 
	`ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
);

66 int 
	`ft_lstsize
(
t_list
 *
lst
);

67 
t_list
 *
	`ft_lstlast
(t_list *
lst
);

68 void 
	`ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
);

69 void 
	`ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*));

70 void 
	`ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*));

71 void 
	`ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *));

72 
t_list
 *
	`ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *));

73 void 
	`delete_first_el
(
t_list
 **
a
);

74 void 
	`delete_last_el
(
t_list
 **
a
);

75 void 
	`del
(void *
content
);

78 int 
	`power
(int 
str_base
, int 
power
);

79 int 
	`ft_atoi_base
(const char *
str
, int 
str_base
);

80 int 
	`transform
(char 
c
);

81 
size_t
 
	`ft_strcspn
(const char *
s
, const char *
reject
);

82 char *
	`ft_strpbrk
(const char *
s1
, const char *
s2
);

83 
size_t
 
	`ft_strspn
(const char *
s
, const char *
accept
);

84 char *
	`str_lowercase
(char *
str
);

	@libft/libft/del.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$del
(void *
content
)

16 if (
content
)

17 
	`free
(
content
);

18 
	}
}

	@libft/libft/ft_atoi.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_atoi
(const char *
str
)

16 int 
i
;

17 int 
result
;

18 int 
sign
;

20 
i
 = 0;

21 
result
 = 0;

22 
sign
 = 1;

23 while (
str
[
i
] == 32 || (str[i] >= 9 && str[i] <= 13))

24 
i
++;

25 if (
str
[
i
] == '-')

27 
sign
 *= (-1);

28 
i
++;

30 else if (
str
[
i
] == '+')

31 
i
++;

32 while (
str
[
i
] >= '0' && str[i] <= '9')

34 
result
 *= 10;

35 
result
 += 
str
[
i
] - 48;

36 
i
++;

38 return (
sign
 * 
result
);

39 
	}
}

	@libft/libft/ft_atoi_base.c

12 #include 
	~"../includes/libft.h
"

13 #include 
	~"../includes/get_next_line.h
"

15 int 
	$transform
(char 
c
)

17 int 
i
;

18 char 
c2
;

20 
i
 = 10;

21 if (
c
 >= 'A' && c <= 'F')

22 
c2
 = 'A';

23 if (
c
 >= 'a' && c <= 'f')

24 
c2
 = 'a';

25 while (
c
 != 
c2
)

27 
c2
++;

28 
i
++;

30 return (
i
);

31 
	}
}

33 int 
	$ft_atoi_base
(const char *
str
, int 
str_base
)

35 int 
i
;

36 int 
count
;

37 int 
result
;

38 int 
sign
;

40 
i
 = 0;

41 
result
 = 0;

42 
count
 = 
	`ft_strlen_int
(
str
) - 1;

43 
sign
 = 1;

44 if (
str
[
i
] == '-')

46 
i
++;

47 
sign
 = -1;

48 
count
--;

50 while (
str
[
i
++] != 0)

52 if (
str
[
i
] >= '0' && str[i] <= '9')

53 
result
 = result + (
str
[
i
] - '0') * 
	`power
(
str_base
, 
count
);

54 if ((
str
[
i
] >= 'A' && str[i] <= 'F') || \

55 (
str
[
i
] >= 'a' && str[i] <= 'f'))

56 
result
 = result + 
	`transform
(
str
[
i
]) * 
	`power
(
str_base
, 
count
);

57 
count
--;

59 return (
result
 * 
sign
);

60 
	}
}

	@libft/libft/ft_bzero.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_bzero
(void *
s
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (
n
 == 0)

21 while (
i
 < 
n
)

23 *(char *)(
s
 + 
i
) = 0;

24 
i
++;

26 
	}
}

	@libft/libft/ft_calloc.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_calloc
(
size_t
 
count
, size_t 
size
)

16 void *
ptr
;

18 
ptr
 = (void *)
	`malloc
(
count
 * 
size
);

19 if (!
ptr
)

20 return (
NULL
);

21 
	`ft_bzero
(
ptr
, (
count
 * 
size
));

22 return (
ptr
);

23 
	}
}

	@libft/libft/ft_isalnum.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalnum
(int 
c
)

16 if (
	`ft_isalpha
(
c
) == 1 || 
	`ft_isdigit
(c) == 1)

20 
	}
}

	@libft/libft/ft_isalpha.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalpha
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

18 else if (
c
 >= 'a' && c <= 'z')

22 
	}
}

	@libft/libft/ft_isascii.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isascii
(int 
c
)

16 if (
c
 >= 0 && c <= 127)

20 
	}
}

	@libft/libft/ft_isdigit.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isdigit
(int 
c
)

16 if (
c
 >= '0' && c <= '9')

20 
	}
}

	@libft/libft/ft_isprint.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isprint
(int 
c
)

16 if (
c
 >= 32 && c <= 126)

20 
	}
}

	@libft/libft/ft_itoa.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbchar
(int 
n
)

16 
size_t
 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

41 char *
	$ft_nb_is_negative
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

43 int 
result
;

45 
result
 = 0;

46 if (
n
 == -2147483648)

48 
n
 = -214748364;

49 
itoa_str
[
nb_char
 - 1] = (char)(8 + 48);

50 
nb_char
--;

52 
n
 *= (-1);

53 while (
n
 > 0)

55 
result
 = (
n
 % 10);

56 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

57 
n
 = n / 10;

58 
nb_char
--;

60 
itoa_str
[--
nb_char
] = '-';

61 return (
itoa_str
);

62 
	}
}

64 char *
	$ft_nb_is_positive
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

66 int 
result
;

68 
result
 = 0;

69 while (
n
 > 0)

71 
result
 = 
n
 % 10;

72 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

73 
n
 = n / 10;

74 
nb_char
--;

76 return (
itoa_str
);

77 
	}
}

79 char *
	$ft_itoa
(int 
n
)

81 
size_t
 
nb_char
;

82 
size_t
 
buff
;

83 char *
itoa_str
;

85 
buff
 = 0;

86 
nb_char
 = 
	`ft_count_nbchar
(
n
);

87 
itoa_str
 = (char *)
	`ft_calloc
((
nb_char
 + 1), sizeof(char));

88 if (!
itoa_str
)

89 return (
NULL
);

90 while (
buff
 < 
nb_char
)

92 
itoa_str
[
buff
] = '0';

93 
buff
++;

95 if (
n
 == 0)

96 
itoa_str
[0] = (char)(0 + 48);

97 else if (
n
 < 0)

98 
itoa_str
 = 
	`ft_nb_is_negative
(
n
, itoa_str, 
nb_char
);

99 else if (
n
 > 0)

100 
itoa_str
 = 
	`ft_nb_is_positive
(
n
, itoa_str, 
nb_char
);

101 return (
itoa_str
);

102 
	}
}

	@libft/libft/ft_lstadd_back.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
)

16 
t_list
 *
lstlast
;

18 if (*
lst
 == 
NULL
)

19 *
lst
 = 
new
;

20 else if (!
lst
 || !
new
)

24 
lstlast
 = 
	`ft_lstlast
(*
lst
);

25 
lstlast
->
next
 = 
new
;

27 
	}
}

	@libft/libft/ft_lstadd_front.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
)

16 if (*
lst
 == 
NULL
)

18 
new
->
next
 = 
NULL
;

19 *
lst
 = 
new
;

21 else if (*
lst
 != 
NULL
)

23 
new
->
next
 = *
lst
;

24 *
lst
 = 
new
;

26 
	}
}

	@libft/libft/ft_lstclear.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*))

16 
t_list
 *
temp
;

17 
t_list
 *
ptr
;

19 
ptr
 = *
lst
;

20 if (!
del
)

22 while (
ptr
 != 
NULL
)

24 
temp
 = 
ptr
->
next
;

25 
	`ft_lstdelone
(
ptr
, 
del
);

26 
ptr
 = 
temp
;

28 *
lst
 = 
NULL
;

29 
	}
}

	@libft/libft/ft_lstdel_first_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_first_el
(
t_list
 **
a
)

16 
t_list
 *
tmp
;

18 
tmp
 = (*
a
)->
next
;

19 
	`free
 (*
a
);

20 *
a
 = 
tmp
;

21 
	}
}

	@libft/libft/ft_lstdel_last_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_last_el
(
t_list
 **
a
)

16 
t_list
 *
end
;

17 
t_list
 *
prev
;

19 
end
 = *
a
;

20 
prev
 = 
NULL
;

21 while (
end
->
next
)

23 
prev
 = 
end
;

24 
end
 = end->
next
;

26 
prev
->
next
 = 
NULL
;

27 
	`free
 (
end
);

28 
	}
}

	@libft/libft/ft_lstdelone.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*))

16 if (!
lst
 || !
del
)

18 
	`del
(
lst
->
content
);

19 
	`free
(
lst
);

20 
	}
}

	@libft/libft/ft_lstiter.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *))

16 
t_list
 *
ptr
;

18 
ptr
 = 
lst
;

19 while (
ptr
 != 
NULL
)

21 
	`f
(
ptr
->
content
);

22 
ptr
 = ptr->
next
;

24 
	}
}

	@libft/libft/ft_lstlast.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstlast
(
t_list
 *
lst
)

16 while (
lst
 != 
NULL
 && lst->
next
 != NULL)

18 
lst
 = lst->
next
;

20 return (
lst
);

21 
	}
}

	@libft/libft/ft_lstmap.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *))

16 
t_list
 *
new_list
;

17 
t_list
 *
head
;

19 if (!
lst
 || !
f
)

20 return (
NULL
);

21 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

22 if (!
new_list
)

23 return (
NULL
);

24 
head
 = 
new_list
;

25 
lst
 = lst->
next
;

26 while (
lst
 != 
NULL
)

28 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

29 if (!
new_list
)

31 
	`ft_lstclear
(&
head
, 
del
);

32 return (
NULL
);

34 
	`ft_lstadd_back
(&
head
, 
new_list
);

35 
lst
 = lst->
next
;

37 return (
head
);

38 
	}
}

	@libft/libft/ft_lstnew.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstnew
(void *
content
)

16 
t_list
 *
lstnew
;

18 
lstnew
 = (
t_list
 *)
	`malloc
(sizeof(t_list));

19 if (!
lstnew
)

20 return (
NULL
);

21 
lstnew
->
next
 = 
NULL
;

22 
lstnew
->
content
 = (void *)content;

23 return (
lstnew
);

24 
	}
}

	@libft/libft/ft_lstsize.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_lstsize
(
t_list
 *
lst
)

16 int 
i
;

17 
t_list
 *
ptr
;

19 
i
 = 0;

20 
ptr
 = 
NULL
;

21 
ptr
 = 
lst
;

22 while (
ptr
 != 
NULL
)

24 
ptr
 = ptr->
next
;

25 
i
++;

27 return (
i
);

28 
	}
}

	@libft/libft/ft_memchr.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s
 + 
i
) == (unsigned char) 
c
)

23 return ((unsigned char *)(
s
 + 
i
));

26 
i
++;

28 return (
NULL
);

29 
	}
}

	@libft/libft/ft_memcmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s1
 + 
i
) != *(unsigned char *)(
s2
 + i))

23 return (*(unsigned char *)(
s1
 + 
i
) - *(unsigned char *)(
s2
 + i));

26 
i
++;

29 
	}
}

	@libft/libft/ft_memcpy.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 while (
i
 < 
n
)

23 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

24 
i
++;

26 return (
dst
);

27 
	}
}

	@libft/libft/ft_memmove.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 if (
dst
 > 
src
)

23 while (
len
--)

25 *(char *)(
dst
 + 
len
) = *(char *)(
src
 + len);

27 return (
dst
);

29 while (
i
 < 
len
)

31 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

32 
i
++;

34 return (
dst
);

35 
	}
}

	@libft/libft/ft_memset.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memset
(void *
b
, int 
c
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
len
)

21 *(unsigned char *)(
b
 + 
i
) = (unsigned char)
c
;

22 
i
++;

24 return (
b
);

25 
	}
}

	@libft/libft/ft_putchar_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putchar_fd
(char 
c
, int 
fd
)

16 
	`write
(
fd
, &
c
, 1);

17 
	}
}

	@libft/libft/ft_putendl_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putendl_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

26 
	`write
(
fd
, "\n", 1);

28 
	}
}

	@libft/libft/ft_putnbr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putnbr_fd
(int 
n
, int 
fd
)

16 if (
n
 == -2147483648)

18 
	`ft_putstr_fd
("-2147483648", 
fd
);

20 else if (
n
 < 0)

22 
	`ft_putchar_fd
('-', 
fd
);

23 
n
 = n * (-1);

24 
	`ft_putnbr_fd
(
n
, 
fd
);

26 else if (
n
 > 9)

28 
	`ft_putnbr_fd
(
n
 / 10, 
fd
);

29 
	`ft_putnbr_fd
((
n
 % 10), 
fd
);

32 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

33 
	}
}

	@libft/libft/ft_putstr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putstr_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

27 
	}
}

	@libft/libft/ft_split.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbsubstr
(const char *
s
, char 
c
)

16 unsigned int 
i
;

17 
size_t
 
count
;

19 
i
 = 0;

20 
count
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] != 
c
)

25 while (
s
[
i
] != 
c
 && s[i] != '\0')

26 
i
++;

27 
count
++;

29 while (
s
[
i
] == 
c
)

30 
i
++;

32 return (
count
);

33 
	}
}

35 unsigned int 
	$ft_start_index_substr
(char const *
s
, char 
c
, unsigned int 
start
)

37 while (
s
[
start
] == 
c
 && s[start] != '\0')

38 
start
++;

39 return (
start
);

40 
	}
}

42 unsigned int 
	$ft_nb_char_substr
(char const *
s
, char 
c
, unsigned int 
start
)

44 unsigned int 
nb_char_substr
;

46 
nb_char_substr
 = 0;

47 while (
s
[
start
] != 
c
 && s[start] != '\0')

49 
start
++;

50 
nb_char_substr
++;

52 return (
nb_char_substr
);

53 
	}
}

55 char *
ft_create_substr
(\

56 char const *
s
, char 
c
, unsigned int 
start
, unsigned int 
nb_char_substr
)

58 unsigned int 
	gi
;

59 char *
	gsubstr
;

61 
	gi
 = 0;

62 
	gsubstr
 = (char *)
ft_calloc
((
nb_char_substr
 + 1), sizeof(char));

63 if (!
	gsubstr
)

64 return (
	gNULL
);

65 while (
	gs
[
start
] != 
c
 && 
s
[start] != '\0' && 
i
 < 
nb_char_substr
)

66 
substr
[
i
++] = 
s
[
start
++];

67 return (
	gsubstr
);

70 char **
	$ft_split
(char const *
s
, char 
c
)

72 
size_t
 
nb_substr
;

73 
size_t
 
i
;

74 char **
tab2d
;

75 unsigned int 
start
;

76 unsigned int 
nb_char_substr
;

78 
i
 = 0;

79 
start
 = 0;

80 
nb_substr
 = 
	`ft_count_nbsubstr
(
s
, 
c
);

81 
tab2d
 = (char **)
	`ft_calloc
((
nb_substr
 + 1), sizeof(char *));

82 if (!
tab2d
)

83 return (
NULL
);

84 while (
s
[
start
] != '\0' && 
i
 < 
nb_substr
)

86 
start
 = 
	`ft_start_index_substr
(
s
, 
c
, start);

87 
nb_char_substr
 = 
	`ft_nb_char_substr
(
s
, 
c
, 
start
);

88 
tab2d
[
i
] = 
	`ft_create_substr
(
s
, 
c
, 
start
, 
nb_char_substr
);

89 
start
 = start + 
nb_char_substr
;

90 
i
++;

92 return (
tab2d
);

93 
	}
}

	@libft/libft/ft_strchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strchr
(const char *
s
, int 
c
)

16 int 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 if ((char)
c
 == 
s
[
i
])

22 return ((char *)(
s
 + 
i
));

23 
i
++;

25 if ((char)
c
 == '\0')

26 return ((char *)(
s
 + 
i
));

28 return (
NULL
);

29 
	}
}

	@libft/libft/ft_strcpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strcpy
(char *
dst
, const char *
src
)

16 int 
i
;

18 
i
 = 0;

19 while (
src
[
i
])

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 
dst
[
i
] = '\0';

25 return (
dst
);

26 
	}
}

	@libft/libft/ft_strcspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strcspn
(const char *
s
, const char *
reject
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
])

21 if (
	`ft_strchr
(
reject
, 
s
[
i
]) != 
NULL
)

22 return (
i
);

23 
i
++;

25 return (
i
);

26 
	}
}

	@libft/libft/ft_strdup.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strdup
(const char *
s1
)

16 int 
size
;

17 char *
s1_copie
;

19 
size
 = 
	`ft_strlen
(
s1
) + 1;

20 
s1_copie
 = (char *)
	`malloc
(
size
 * sizeof(char));

21 if (!
s1_copie
)

22 return (
NULL
);

23 
	`ft_strlcpy
(
s1_copie
, 
s1
, 
size
);

24 return (
s1_copie
);

25 
	}
}

	@libft/libft/ft_striteri.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*))

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`f
(
i
, &
s
[i]);

24 
i
++;

27 
	}
}

	@libft/libft/ft_strjoin.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strjoin
(char const *
s1
, char const *
s2
)

16 
size_t
 
size_s1
;

17 
size_t
 
size_s2
;

18 char *
strjoin
;

20 
size_s1
 = 
	`ft_strlen
(
s1
);

21 
size_s2
 = 
	`ft_strlen
(
s2
);

22 
strjoin
 = (char *)
	`malloc
((
size_s1
 + 
size_s2
 + 1) * sizeof(char));

23 if (!
strjoin
)

24 return (
NULL
);

25 
	`ft_memcpy
(
strjoin
, 
s1
, 
size_s1
);

26 
	`ft_memcpy
((
strjoin
 + 
size_s1
), 
s2
, 
size_s2
);

27 
	`ft_memset
((
strjoin
 + 
size_s1
 + 
size_s2
), 0, 1);

28 return (
strjoin
);

29 
	}
}

	@libft/libft/ft_strlcat.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcat
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
strlen_src
;

18 
size_t
 
strlen_dst
;

19 
size_t
 
temp
;

21 
i
 = 0;

22 
strlen_src
 = 
	`ft_strlen
(
src
);

23 
strlen_dst
 = 
	`ft_strlen
(
dst
);

24 
temp
 = 
strlen_dst
;

25 if (
dstsize
 < 
strlen_dst
)

26 return (
dstsize
 + 
strlen_src
);

27 if (
dstsize
 > 
strlen_dst
 + 1)

29 while (
src
[
i
] && 
strlen_dst
 != (
dstsize
 - 1))

31 
dst
[
strlen_dst
++] = 
src
[
i
++];

33 
dst
[
strlen_dst
] = '\0';

35 return (
temp
 + 
strlen_src
);

36 
	}
}

	@libft/libft/ft_strlcpy.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcpy
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
j
;

19 
i
 = 0;

20 
j
 = 0;

21 while (
src
[
i
] != '\0')

23 
i
++;

25 if (
dstsize
 > 0)

27 while (
j
 < (
dstsize
 - 1) && 
src
[j] != '\0')

29 
dst
[
j
] = 
src
[j];

30 
j
++;

32 
dst
[
j
] = '\0';

34 return (
i
);

35 
	}
}

	@libft/libft/ft_strlen.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlen
(const char *
s
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 
i
++;

23 return (
i
);

24 
	}
}

	@libft/libft/ft_strmapi.c

12 #include 
	~"../includes/libft.h
"

14 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char))

16 unsigned int 
i
;

17 
size_t
 
size
;

18 char *
strmapi
;

20 
i
 = 0;

21 
size
 = 
	`ft_strlen
(
s
);

22 
strmapi
 = (char *)
	`malloc
((
size
 + 1) * sizeof(char));

23 if (!
strmapi
)

24 return (
NULL
);

25 while (
s
[
i
] != '\0')

27 
strmapi
[
i
] = 
	`f
(i, 
s
[i]);

28 
i
++;

30 
strmapi
[
i
] = '\0';

31 return (
strmapi
);

32 
	}
}

	@libft/libft/ft_strncmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (((unsigned char)
s1
[
i
] || (unsigned char)
s2
[i]) && i < 
n
)

21 if (
s1
[
i
] != 
s2
[i])

22 return ((unsigned char)
s1
[
i
] - (unsigned char)
s2
[i]);

23 
i
++;

26 
	}
}

	@libft/libft/ft_strncpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strncpy
(char *
dst
, const char *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
src
[
i
] && i < 
len
)

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 while (
i
 < 
len
)

26 
dst
[
i
] = '\0';

27 
i
++;

29 return (
dst
);

30 
	}
}

	@libft/libft/ft_strnstr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
)

16 
size_t
 
len_needle
;

17 
size_t
 
len_haystack
;

19 
len_needle
 = 
	`ft_strlen
(
needle
);

20 
len_haystack
 = 
	`ft_strlen
(
haystack
);

21 if (
needle
[0] == '\0')

22 return ((char *)(
haystack
));

23 if (
len_needle
 > 
len_haystack
 || 
len
 < len_needle)

24 return (
NULL
);

25 if (
len
 > 
len_haystack
)

26 
len
 = 
len_haystack
;

27 while (
len
 >= 
len_needle
 && 
haystack
)

29 if (
	`ft_memcmp
(
haystack
, 
needle
, 
len_needle
) == 0)

30 return ((char *)(
haystack
));

33 
haystack
++;

34 
len
--;

37 return (
NULL
);

38 
	}
}

	@libft/libft/ft_strpbrk.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strpbrk
(const char *
s1
, const char *
s2
)

16 int 
i
;

18 
i
 = 0;

19 while (
s1
[
i
] != '\0')

21 if (
	`ft_strchr
(
s2
, 
s1
[
i
]) != 0)

23 return ((char *) &
s1
[
i
]);

25 ++
i
;

28 
	}
}

	@libft/libft/ft_strrchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strrchr
(const char *
s
, int 
c
)

16 int 
i
;

17 int 
k
;

19 
i
 = 0;

20 
k
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] == (char)
c
)

24 
k
 = 
i
;

25 
i
++;

27 if (
s
[
k
] == (char)
c
)

28 return ((char *)(
s
 + 
k
));

29 else if ((char)
c
 == 
s
[
i
])

30 return ((char *)(
s
 + 
i
));

32 return (
NULL
);

33 
	}
}

	@libft/libft/ft_strspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strspn
(const char *
s
, const char *
accept
)

16 
size_t
 
count
;

17 
size_t
 
i
;

19 
count
 = 0;

20 
i
 = 0;

21 while (
s
[
i
] && 
	`ft_strchr
(
accept
, s[i]) != 0)

23 
count
++;

24 
i
++;

26 return (
count
);

27 
	}
}

	@libft/libft/ft_strtrim.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strtrim
(char const *
s1
, char const *
set
)

16 unsigned int 
front
;

17 unsigned int 
end
;

18 unsigned int 
i
;

19 char *
strtrim
;

21 
front
 = 0;

22 
i
 = 0;

23 
end
 = (unsigned int)(
	`ft_strlen
(
s1
));

24 while (
s1
[
front
] != '\0' && 
	`ft_strchr
(
set
, *(s1 + front)) != 
NULL
)

25 
front
++;

26 while (
front
 < 
end
 && 
	`ft_strrchr
(
set
, *(
s1
 + end - 1)) != 
NULL
)

27 
end
--;

28 
strtrim
 = (char *)
	`malloc
((
end
 - 
front
 + 1) * sizeof(char));

29 if (!
strtrim
)

30 return (
NULL
);

31 
i
 = 0;

32 while (
front
 < 
end
)

33 
strtrim
[
i
++] = 
s1
[
front
++];

34 
strtrim
[
i
] = 0;

35 return (
strtrim
);

36 
	}
}

	@libft/libft/ft_substr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
)

16 char *
substr
;

17 unsigned int 
i
;

18 
size_t
 
size
;

20 
i
 = 0;

21 if (!
s
)

22 return (
NULL
);

23 
size
 = 
	`ft_strlen
(
s
);

24 if (
len
 > 
size
)

25 
len
 = 
size
;

26 if (
start
 >= (unsigned int)
size
)

28 
substr
 = (char *)
	`malloc
(1 * sizeof(char));

29 if (!
substr
)

30 return (
NULL
);

31 
substr
[0] = '\0';

32 return (
substr
);

34 
substr
 = (char *)
	`malloc
((
len
 + 1) * sizeof(char));

35 if (!
substr
)

36 return (
NULL
);

37 while (
i
 < (unsigned int)
len
 && 
s
[
start
] != '\0' )

38 
substr
[
i
++] = 
s
[
start
++];

39 
substr
[
i
] = '\0';

40 return (
substr
);

41 
	}
}

	@libft/libft/ft_tolower.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_tolower
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

17 return (
c
 + 32);

19 return (
c
);

20 
	}
}

	@libft/libft/ft_toupper.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_toupper
(int 
c
)

16 if (
c
 >= 'a' && c <= 'z')

17 return (
c
 - 32);

19 return (
c
);

20 
	}
}

	@libft/libft/power.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$power
(int 
str_base
, int 
power
)

16 int 
result
;

18 
result
 = 1;

19 if (
power
 < 0 || 
str_base
 == 0)

23 while (
power
 > 0)

25 
result
 = result * 
str_base
;

26 
power
--;

28 return (
result
);

29 
	}
}

	@libft/libft/str_lowercase.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$str_lowercase
(char *
str
)

16 int 
i
;

18 
i
 = 0;

19 while (
str
[
i
])

21 if (
str
[
i
] >= 'A' && str[i] <= 'Z')

22 
str
[
i
] += 32;

23 
i
++;

25 return (
str
);

26 
	}
}

	@main.c

13 #include 
	~"minishell.h
"

15 
t_shell
 *
	gg_shell
;

21 void 
	$print_env
(
t_env
 **
head
)

23 
t_env
 *
ptr
;

25 
ptr
 = *
head
;

26 if (!
head
 || !*head)

28 while (
ptr
)

30 
	`ft_printf
("print_env function: %s\n", 
ptr
->
var_name
);

31 
	`ft_printf
("print_env function: %s\n", 
ptr
->
var_value
);

32 
ptr
 = ptr->
next
;

34 
	}
}

37 void 
	$free_shell
(void)

39 
	`free_env
(&
g_shell
->
env
);

41 if (
g_shell
)

42 
	`free
(
g_shell
);

43 
	}
}

45 int 
	$init_shell
(char **
envp
)

47 
g_shell
 = 
	`ft_calloc
(1, sizeof(
t_shell
));

48 if (!
g_shell
)

50 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

53 if (!*
envp
)

58 
g_shell
->
env
 = 
	`get_envp
(
envp
);

59 if (!
g_shell
->
env
)

61 
	`free_shell
();

62 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

65 
g_shell
->
exit_status
 = 0;

68 
	}
}

71 int 
	$main
(int 
ac
, char **
av
, char **
envp
)

73 (void)
av
;

74 (void)
ac
;

75 char *
line
;

76 
t_token
 *
token
;

78 if (!
	`init_shell
(
envp
))

80 
line
 = 
NULL
;

82 
line
 = 
	`ft_strdup
("\"$\'coucouc\'wqd\"");

84 
	`printf
("LINE = %s\n", 
line
);

85 
token
 = 
	`parsing
(
line
);

87 
g_shell
->
exit_status
 = 0;

88 if (
token
)

89 
	`free_token
(&
token
);

90 
	`free_shell
();

92 
	}
}

	@malloc_error_print_message.c

12 #include 
	~"minishell.h
"

14 void 
	$malloc_error_print_message
(char *
s
)

16 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
s
);

17 
g_shell
->
exit_status
 = 1;

18 
	}
}

	@minishell.h

13 #ifndef 
MINISHELL_H


14 #define 
	#MINISHELL_H


	)

16 #include 
	~<stdio.h
>

17 #include 
	~<string.h
>

18 #include 
	~<stdlib.h
>

19 #include 
	~<errno.h
>

20 #include 
	~<curses.h
>

21 #include 
	~<term.h
>

22 #include 
	~<signal.h
>

23 #include 
	~<unistd.h
>

24 #include 
	~<fcntl.h
>

25 #include 
	~<stdarg.h
>

26 #include 
	~<sys/wait.h
>

27 #include 
	~<sys/stat.h
>

28 #include 
	~<sys/types.h
>

29 #include 
	~<readline/readline.h
>

30 #include 
	~<readline/history.h
>

31 #include 
	~"libft/includes/libft.h
"

34 #define 
	#RED
 "\x1b[31m"

	)

35 #define 
	#BLU
 "\x1B[34m"

	)

36 #define 
	#BLU_2
 "\e[1;34m"

	)

37 #define 
	#GRN
 "\x1B[32m"

	)

38 #define 
	#YEL
 "\x1B[33m"

	)

39 #define 
	#MAG
 "\x1B[35m"

	)

40 #define 
	#CYN
 "\x1B[36m"

	)

41 #define 
	#WHT
 "\x1B[37m"

	)

42 #define 
	#RESET
 "\x1B[0m"

	)

44 #define 
	#WORD
 1

	)

45 #define 
	#PIPELINE
 2

	)

46 #define 
	#L_CHEVRON
 3

	)

47 #define 
	#R_CHEVRON
 4

	)

48 #define 
	#APPEND
 5

	)

49 #define 
	#HERE_DOC
 6

	)

50 #define 
	#DOLLAR
 7

	)

51 #define 
	#QUESTION
 8

	)

52 #define 
	#EXPAND
 9

	)

53 #define 
	#DELETE
 10

	)

54 #define 
	#EXPANDED
 11

	)

55 #define 
	#CONTINUE
 -1

	)

56 #define 
	#ERROR_EXIT
 -169

	)

57 #define 
	#ERROR_EXIT_
 0

	)

62 typedef struct 
	ss_env


64 char *
	mvar_name
;

65 char *
	mvar_value
;

66 struct 
s_env
 *
	mnext
;

67 } 
	tt_env
;

69 typedef struct 
	ss_token


71 char *
	mcontent
;

72 int 
	mid
;

73 struct 
s_token
 *
	mnext
;

74 } 
	tt_token
;

77 typedef struct 
	ss_cmd


80 char **
	mcmd
;

81 char **
	mredir
;

82 char **
	mpath
;

86 int 
	mfdout
;

87 int 
	mfdin
;

88 int 
	mfd
[2];

89 } 
	tt_cmd
;

91 typedef struct 
	ss_shell


93 
t_env
 *
	menv
;

94 int 
	mexit_status
;

96 } 
	tt_shell
;

99 extern 
t_shell
 *
g_shell
;

101 int 
expansion
(
t_token
 **
token
, t_token *
curr
, int 
pos
);

102 int 
check_dollar
(
t_token
 *
curr
, int 
i
);

103 int 
trim_dollar
(
t_token
 *
curr
, int 
pos
);

106 int 
is_dollar_to_expand
(
t_token
 *
curr
, int 
i
);

107 int 
not_within_squotes
(
t_token
 *
curr
, int 
pos
);

110 int 
trim_dollar
(
t_token
 *
curr
, int 
pos
);

113 int 
loop_dollars
(char *
s
, int 
i
);

114 int 
loop_through
(char *
s
, int 
i
);

115 int 
loop_simple_quotes
(char *
s
, int 
i
);

116 int 
loop_double_quotes
(char *
s
, int 
i
);

119 int 
size_var
(char *
s
);

120 int 
check_var_exist
(
t_token
 *
tmp
);

123 int 
join_tokens
(
t_token
 **
new
, t_token *
curr
);

126 int 
prepare_expand
(
t_token
 *
tmp
, int 
i
);

127 int 
set_id_expansion
(
t_token
 *
token
);

130 int 
quote_removing
(
t_token
 **
head
, t_token *
curr
, int 
pos
);

132 
t_token
 *
delete_token
(t_token **
head
);

133 int 
token_list_size
(
t_token
 **
head
);

136 int 
_pwd
(
t_cmd
 *
cmd
);

137 int 
_env
(
t_env
 *
env
);

140 char **
env_copied
(char **
envp
);

141 void 
free_tab
(char **
table
);

144 
t_env
 *
get_envp
(char **
envp
);

145 void 
free_env
(
t_env
 **
head
);

149 
t_token
 *
parsing
(char *
line
);

150 int 
syntax_error_check
(char *
s
);

151 int 
check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
);

152 int 
check_quotes_errors
(char *
s
, char 
c
, int *
i
);

153 int 
count_metachar
(char *
s
, char 
c
, int 
num
);

154 int 
check_multiple_operators_error
(int 
i
, int 
num
, char 
c
);

155 void 
print_syntax_error_char
(char 
c
);

156 void 
print_syntax_error_dchar
(char 
c
);

157 void 
print_syntax_error_str
(char *
s
);

160 int 
character_extraction
(char *
line
, int 
ind
);

161 int 
token_extraction
(char *
line
, int 
ind
);

162 
t_token
 *
get_tokens
(char *
line
);

163 int 
get_tokens_size
(char *
line
, int *
i
);

164 
t_token
 *
create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
);

167 void 
malloc_error_print_message
(char *
s
);

170 
t_token
 *
new_token
(char *
line
, int 
start
, int 
len
);

171 void 
set_id
(
t_token
 *
token
);

172 int 
token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
);

173 int 
link_token
(
t_token
 **
head
, t_token *
new
);

174 void 
free_token
(
t_token
 **
head
);

177 int 
is_dollar
(char 
c
);

178 int 
is_pipeline
(char 
c
);

179 int 
is_chevron
(char 
c
);

180 int 
is_lchevron
(char 
c
);

181 int 
is_rchevron
(char 
c
);

182 int 
is_operator
(char 
c
);

183 int 
is_newline
(char 
c
);

184 int 
is_white_space
(char 
c
);

185 int 
is_blank
(char 
c
);

186 int 
is_metacharacter
(char 
c
);

187 int 
is_delimiter
(char 
c
);

188 int 
is_word
(char 
c
);

189 int 
is_double_quote
(char 
c
);

190 int 
is_simple_quote
(char 
c
);

191 int 
is_quote
(char 
c
);

192 int 
is_question
(char 
c
);

193 int 
is_punct
(char 
c
);

196 int 
sig_handler
(void);

199 void 
handler_ctr_c
(int 
code
);

202 char **
ft_splitpath
(char *
s
, char 
c
);

	@parsing.c

12 #include 
	~"minishell.h
"

16 void 
	$print_token
(
t_token
 **
head
)

18 int 
i
;

19 
t_token
 *
tmp
;

21 
i
 = 0;

22 if (!*
head
 || !head)

24 
tmp
 = *
head
;

25 while (
tmp
)

27 if (
tmp
->
id
 == 
L_CHEVRON
)

28 
	`printf
("L_CHEVRON: ");

29 else if (
tmp
->
id
 == 
R_CHEVRON
)

30 
	`printf
("R_CHEVRON: ");

31 else if (
tmp
->
id
 == 
PIPELINE
)

32 
	`printf
("PIPELINE: ");

33 else if (
tmp
->
id
 == 
WORD
)

34 
	`printf
("WORD: ");

35 else if (
tmp
->
id
 == 
APPEND
)

36 
	`printf
("APPEND: ");

37 else if (
tmp
->
id
 == 
HERE_DOC
)

38 
	`printf
("HERE_DOC: ");

39 else if (
tmp
->
id
 == 
DOLLAR
)

40 
	`printf
("DOLLAR: ");

41 while (
tmp
->
content
[
i
])

43 
	`printf
 ("%c", 
tmp
->
content
[
i
]);

44 
i
++;

46 
	`printf
 ("%c", 
tmp
->
content
[
i
]);

47 
	`printf
 ("\n");

48 
i
 = 0;

49 
tmp
 = tmp->
next
;

51 
	}
}

53 
t_token
 *
	$parsing
(char *
line
)

55 
t_token
 *
token
;

57 if (!
	`syntax_error_check
(
line
))

58 return (
NULL
);

59 
token
 = 
	`get_tokens
(
line
);

60 if (!
token
)

61 return (
NULL
);

62 if (!
	`expansion
(&
token
, token, 0))

63 return (
NULL
);

64 if (!
	`quote_removing
(&
token
, token, 0))

65 return (
NULL
);

66 
	`print_token
(&
token
);

67 return (
token
);

68 
	}
}

	@parsing_expansion.c

12 #include 
	~"minishell.h
"

14 int 
	$check_dollar
(
t_token
 *
curr
, int 
i
)

16 while (
curr
->
content
[
i
])

18 if (
	`is_dollar
(
curr
->
content
[
i
]) && 
	`not_within_squotes
(curr, i))

20 if (
	`is_dollar_to_expand
(
curr
, 
i
))

21 return (
	`prepare_expand
(
curr
, 
i
));

22 else if (
	`is_dollar
(
curr
->
content
[
i
 + 1]))

23 
i
 = 
	`loop_dollars
(
curr
->
content
, i);

24 else if (
	`is_quote
(
curr
->
content
[
i
 + 1]))

26 if (!
	`trim_dollar
(
curr
, 
i
))

27 return (
ERROR_EXIT
);

29 
i
 = i + 2;

31 else if (
curr
->
content
[
i
 + 1] == '\0')

34 
i
++;

37 
i
++;

39 
curr
->
id
 = 
WORD
;

40 return (
i
);

41 
	}
}

43 static void 
	$expansion_next_token
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

45 
pos
 = 0;

46 if (
curr
->
next
)

48 
curr
 = curr->
next
;

49 
	`expansion
(
head
, 
curr
, 
pos
);

51 
	}
}

53 int 
	$expansion
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

55 if (
curr
)

57 if (
curr
->
id
 == 
DOLLAR
)

59 
pos
 = 
	`check_dollar
(
curr
, pos);

60 if (
pos
 == 
ERROR_EXIT
)

61 return (
	`free_token
(
head
), 0);

62 if (
curr
->
id
 == 
DELETE
)

64 
curr
 = 
	`delete_token
(
head
);

65 if (!
curr
)

67 
head
 = 
NULL
;

70 
pos
 = 0;

72 
	`expansion
(
head
, 
curr
, 
pos
);

75 
	`expansion_next_token
(
head
, 
curr
, 
pos
);

78 
	}
}

	@parsing_expansion_dollar_conditions.c

12 #include 
	~"minishell.h
"

18 int 
	$not_within_squotes
(
t_token
 *
curr
, int 
pos
)

20 int 
i
;

21 int 
start
;

23 
i
 = 0;

24 
start
 = 0;

25 if (!
	`is_dollar
(
curr
->
content
[
pos
]))

27 while (
curr
->
content
[
i
])

29 if (
	`is_double_quote
(
curr
->
content
[
i
]))

30 
i
 = 
	`loop_through
(
curr
->
content
, i);

31 else if (
	`is_simple_quote
(
curr
->
content
[
i
]))

33 
start
 = 
i
;

34 
i
 = 
	`loop_through
(
curr
->
content
, i);

35 if (
pos
 > 
start
 && pos < 
i
)

38 
i
++;

41 
	}
}

43 int 
	$is_dollar_to_expand
(
t_token
 *
curr
, int 
i
)

45 if (
	`is_question
(
curr
->
content
[
i
 + 1]) || \

46 (!
	`is_dollar
(
curr
->
content
[
i
 + 1]) && \

47 !
	`is_quote
(
curr
->
content
[
i
 + 1]) && \

48 !
	`is_punct
(
curr
->
content
[
i
 + 1]) && \

49 
curr
->
content
[
i
 + 1] != '\0'))

54 
	}
}

	@parsing_expansion_expand_var_helper.c

12 #include 
	~"minishell.h
"

14 static int 
	$replace_content
(
t_token
 *
tmp
, char *
s
)

16 
	`free
(
tmp
->
content
);

17 
tmp
->
content
 = 
NULL
;

18 
tmp
->
content
 = 
	`ft_strdup
(
s
);

19 if (!
tmp
->
content
)

21 
	`malloc_error_print_message
("ft_strdup failed");

22 return (
ERROR_EXIT
);

25 
	}
}

27 int 
	$check_var_exist
(
t_token
 *
tmp
)

29 if (
	`ft_strncmp
(&
tmp
->
content
[1], "?", 1) == 0)

31 return (
	`replace_content
(
tmp
, 
	`ft_itoa
(
g_shell
->
exit_status
)));

33 else if (
g_shell
 && g_shell->
env
 && g_shell->env->
var_name
)

35 if (
	`ft_strncmp
(
g_shell
->
env
->
var_name
, &
tmp
->
content
[1], \

36 
	`ft_strlen
(
tmp
->
content
)) == 0)

38 return (
	`replace_content
(
tmp
, 
g_shell
->
env
->
var_value
));

42 
	}
}

44 int 
	$size_var
(char *
s
)

46 int 
i
;

47 int 
count
;

49 
i
 = 0;

50 
count
 = 0;

51 while (
s
[
i
] && 
	`is_white_space
(s[i]))

52 
i
++;

53 while (
s
[
i
] && !
	`is_white_space
(s[i]))

55 
count
++;

56 
i
++;

58 return (
count
);

59 
	}
}

	@parsing_expansion_helper.c

12 #include 
	~"minishell.h
"

14 int 
	$expand_var
(
t_token
 **
new
)

16 
t_token
 *
tmp
;

17 
t_env
 *
save
;

18 int 
res
;

20 
tmp
 = *
new
;

21 
save
 = 
g_shell
->
env
;

22 while (
tmp
->
id
 != 
EXPAND
)

23 
tmp
 = tmp->
next
;

24 while (
g_shell
->
env
)

26 
res
 = 
	`check_var_exist
(
tmp
);

27 if (
res
 == 
ERROR_EXIT
)

28 return (
ERROR_EXIT
);

29 else if (
res
 == 1)

31 
tmp
->
id
 = 
EXPANDED
;

32 
g_shell
->
env
 = 
save
;

33 return (
	`size_var
(
tmp
->
content
));

35 
g_shell
->
env
 = g_shell->env->
next
;

37 
tmp
->
id
 = 
DELETE
;

38 
g_shell
->
env
 = 
save
;

40 
	}
}

42 int 
	$split_tokens
(
t_token
 **
new
, char *
s
, int 
start
, int 
len
)

44 if (
start
 != 0)

46 *
new
 = 
	`new_token
(
s
, 0, 
start
);

47 if (!*
new
)

48 return (
ERROR_EXIT
);

49 (*
new
)->
id
 = 
WORD
;

50 if (!
	`token_linked_list
(
new
, 
s
, 
start
, 
len
))

51 return (
ERROR_EXIT
);

52 (*
new
)->
next
->
id
 = 
EXPAND
;

56 *
new
 = 
	`new_token
(
s
, 
start
, 
len
);

57 if (!*
new
)

58 return (
ERROR_EXIT
);

59 (*
new
)->
id
 = 
EXPAND
;

61 
len
 = 
start
 + len;

62 
start
 = 
len
;

63 while (
s
[
len
])

64 
len
++;

65 if (
len
 != 
start
)

66 if (!
	`token_linked_list
(
new
, 
s
, 
start
, 
len
))

67 return (
ERROR_EXIT
);

69 
	}
}

71 static int 
	$var_len
(char *
s
, int 
i
)

73 int 
len
;

75 
len
 = 0;

76 
i
++;

77 if (
	`is_question
(
s
[
i
]))

81 while (
s
[
i
] && \

82 !
	`is_white_space
(
s
[
i
]) && \

83 !
	`is_quote
(
s
[
i
]) && \

84 !
	`is_question
(
s
[
i
]) && \

85 !
	`is_dollar
(
s
[
i
]) && \

86 !
	`is_punct
(
s
[
i
]))

88 
i
++;

89 
len
++;

92 return (
len
);

93 
	}
}

95 int 
	$new_id
(
t_token
 **
new
)

97 
t_token
 *
ptr
;

99 
ptr
 = *
new
;

100 while (
ptr
)

102 if (
ptr
->
id
 == 
DELETE
 || ptr->id == 
EXPANDED
)

104 
ptr
 = ptr->
next
;

106 if (
ptr
->
next
 == 
NULL
)

107 return (
WORD
);

108 return(
	`set_id_expansion
(
ptr
->
next
));

109 
	}
}

111 int 
	$prepare_expand
(
t_token
 *
curr
, int 
i
)

113 
t_token
 *
new
;

114 int 
len
;

115 int 
id
;

117 
new
 = 
NULL
;

118 
len
 = 
	`var_len
(
curr
->
content
, 
i
);

119 if (
	`split_tokens
(&
new
, 
curr
->
content
, 
i
, 
len
 + 1) == 
ERROR_EXIT
)

120 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

121 
len
 = 
	`expand_var
(&
new
);

122 if (
len
 == 
ERROR_EXIT
)

123 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

124 
id
 = 
	`new_id
 (&
new
);

125 if (
	`join_tokens
(&
new
, 
curr
) == 
ERROR_EXIT
)

126 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

127 if (
curr
->
id
 == 
DELETE
)

129 
curr
->
id
 = id ;

130 return (
len
 + 
i
);

131 
	}
}

	@parsing_expansion_join_tokens.c

12 #include 
	~"minishell.h
"

14 static int 
	$get_expanded_size
(char *
s
, int 
i
)

16 int 
size
;

18 
size
 = 0;

19 while (
	`is_white_space
(
s
[
i
]))

20 
i
++;

21 while (
s
[
i
] && !
	`is_white_space
(s[i]))

23 
i
++;

24 
size
++;

26 return (
size
);

27 
	}
}

29 static int 
	$get_new_size
(
t_token
 **
new
)

31 
t_token
 *
ptr
;

32 int 
size
;

33 int 
i
;

35 
size
 = 0;

36 
ptr
 = *
new
;

37 while (
ptr
)

39 
i
 = 0;

40 if (
ptr
->
id
 == 
EXPANDED
)

41 
size
 += 
	`get_expanded_size
(
ptr
->
content
, 
i
);

42 else if (
ptr
->
id
 != 
DELETE
)

44 while (
ptr
->
content
[
i
])

46 
size
++;

47 
i
++;

50 
ptr
 = ptr->
next
;

52 return (
size
);

53 
	}
}

55 static void 
	$copy_helper
(
t_token
 **
new
, t_token *
curr
)

57 int 
i
;

58 int 
j
;

59 
t_token
 *
ptr
;

61 
i
 = 0;

62 
j
 = 0;

63 
ptr
 = *
new
;

64 while (
ptr
)

66 if (
ptr
->
id
 == 
EXPANDED
)

68 while (
ptr
->
content
[
j
] && 
	`is_white_space
(ptr->content[j]))

69 
j
++;

70 while (
ptr
->
content
[
j
] && !
	`is_white_space
(ptr->content[j]))

71 
curr
->
content
[
i
++] = 
ptr
->content[
j
++];

73 else if (
ptr
->
id
 != 
DELETE
)

74 while (
ptr
->
content
[
j
])

75 
curr
->
content
[
i
++] = 
ptr
->content[
j
++];

76 
ptr
 = ptr->
next
;

77 
j
 = 0;

79 
curr
->
content
[
i
] = '\0';

80 
	}
}

82 static int 
	$copy_join_tokens
(
t_token
 **
new
, t_token *
curr
, int 
size
)

84 int 
i
;

85 int 
j
;

87 
i
 = 0;

88 
j
 = 0;

89 
	`free
(
curr
->
content
);

90 
curr
->
content
 = 
NULL
;

91 
curr
->
content
 = 
	`malloc
((
size
 + 1) * sizeof(char));

92 if (!
curr
->
content
)

94 
	`malloc_error_print_message
(
	`strerror
(
errno
));

95 return (
ERROR_EXIT
);

97 
	`copy_helper
(
new
, 
curr
);

98 
	`free_token
(
new
);

100 
	}
}

102 int 
	$join_tokens
(
t_token
 **
new
, t_token *
curr
)

104 int 
size
;

106 
size
 = 
	`get_new_size
(
new
);

107 if (
size
 == 0)

109 
	`free_token
(
new
);

110 
curr
->
id
 = 
DELETE
;

113 if (
	`copy_join_tokens
(
new
, 
curr
, 
size
) == 
ERROR_EXIT
)

114 return (
ERROR_EXIT
);

116 
	}
}

	@parsing_expansion_looping.c

12 #include 
	~"minishell.h
"

15 int 
	$loop_simple_quotes
(char *
s
, int 
i
)

17 
i
++;

18 while (!
	`is_simple_quote
(
s
[
i
]))

19 
i
++;

20 return (
i
);

21 
	}
}

24 int 
	$loop_double_quotes
(char *
s
, int 
i
)

26 int 
j
;

27 int 
count
;

29 
j
 = 0;

30 
count
 = 0;

31 while (
s
[
j
] && j < 
i
)

33 if (
	`is_simple_quote
(
s
[
j
]))

34 
j
 = 
	`loop_simple_quotes
(
s
, 
i
);

35 else if (
	`is_double_quote
(
s
[
j
]))

37 
count
++;

38 
j
++;

41 
j
++;

43 if (
count
 != 0 && count % 2 == 0)

46 
	}
}

49 int 
	$loop_dollars
(char *
s
, int 
i
)

51 while (
	`is_dollar
(
s
[
i
]) && s[i])

52 
i
++;

53 if (
s
[
i
] != '\0' && !
	`is_white_space
(s[i]))

55 
i
--;

56 
	`printf
 ("i = %d\n", 
i
);

58 return (
i
);

59 
	}
}

67 int 
	$loop_through
(char *
s
, int 
i
)

69 char 
c
;

71 
c
 = 
s
[
i
];

72 
i
++;

73 while (
s
[
i
] != 
c
)

74 
i
++;

75 return (
i
);

76 
	}
}

	@parsing_expansion_trim_dollar.c

12 #include 
	~"minishell.h
"

17 static int 
	$copy_string
(
t_token
 *
curr
, char **
s
, int 
pos
)

19 int 
i
;

20 int 
j
;

22 
i
 = 0;

23 
j
 = 0;

24 *
s
 = 
	`malloc
(sizeof(char) * 
	`ft_strlen
(
curr
->
content
));

25 if (!*
s
)

27 
i
 = 0;

28 while (
curr
->
content
[
i
])

30 if (
i
 == 
pos
)

31 
i
++;

32 (*
s
)[
j
] = 
curr
->
content
[
i
];

33 
i
++;

34 
j
++;

36 (*
s
)[
j
] = '\0';

37 
	`free
(
curr
->
content
);

38 
curr
->
content
 = *
s
;

40 
	}
}

46 int 
	$trim_dollar
(
t_token
 *
curr
, int 
pos
)

48 int 
i
;

49 int 
start
;

50 char *
s
;

52 
s
 = 
NULL
;

53 
i
 = 0;

54 
start
 = 0;

55 while (
curr
->
content
[
i
])

57 if (
	`is_double_quote
(
curr
->
content
[
i
]))

59 
start
 = 
i
;

60 
i
 = 
	`loop_through
(
curr
->
content
, i);

61 if (
pos
 > 
start
 && pos < 
i
)

64 
i
++;

66 if (!
	`copy_string
(
curr
, &
s
, 
pos
))

69 
	}
}

	@parsing_quote_removing.c

12 #include 
	~"minishell.h
"

14 static int 
copy_string_unquoted
(
t_token
 *
curr
, char *
new_str
, \

15 int 
start
, int 
pos
)

17 int 
	gj
;

18 int 
	gi
;

19 int 
	gsave
;

21 
	gj
 = 0;

22 
	gi
 = 0;

23 
	gsave
 = 0;

24 while (
	gcurr
->
	gcontent
[
i
])

26 if (
	gi
 == 
start
)

27 
i
++;

28 else if (
	gi
 == 
pos
)

30 
i
++;

31 
	gsave
 = 
j
;

35 
	gnew_str
[
j
] = 
curr
->
content
[
i
];

36 
	gi
++;

37 
	gj
++;

40 
	gnew_str
[
j
] = '\0';

41 return (
	gsave
);

44 int 
	$string_replace
(
t_token
 *
curr
, int 
start
, int 
pos
)

46 int 
save
;

47 char *
new_str
;

49 
new_str
 = 
	`malloc
(sizeof(char) * (
	`ft_strlen
(
curr
->
content
) - 1));

50 if (!
new_str
)

52 
	`malloc_error_print_message
(
	`strerror
(
errno
));

53 return (
ERROR_EXIT
);

55 
save
 = 
	`copy_string_unquoted
(
curr
, 
new_str
, 
start
, 
pos
);

56 
	`free
(
curr
->
content
);

57 
curr
->
content
 = 
NULL
;

58 
curr
->
content
 = 
new_str
;

59 return (
save
);

60 
	}
}

62 int 
	$remove_q
(
t_token
 *
curr
, int 
pos
)

64 int 
start
;

66 
start
 = 
pos
;

67 
pos
 = 
	`loop_through
(
curr
->
content
, pos);

68 
pos
 = 
	`string_replace
(
curr
, 
start
, pos);

69 if (
pos
 == 
ERROR_EXIT
)

70 return (
ERROR_EXIT
);

71 return (
pos
++);

72 
	}
}

74 int 
	$quote_removing
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

76 if (!
head
 || !*head)

78 if (
curr
->
content
[
pos
] == '\0')

80 if (
curr
->
next
)

82 
pos
 = 0;

83 
curr
 = curr->
next
;

84 
	`quote_removing
(
head
, 
curr
, 
pos
);

88 else if (
	`is_quote
(
curr
->
content
[
pos
]))

90 
pos
 = 
	`remove_q
(
curr
, pos);

91 if (
pos
 == 
ERROR_EXIT
)

93 
	`free_token
(
head
);

96 
	`quote_removing
(
head
, 
curr
, 
pos
);

98 else if (!
	`is_quote
(
curr
->
content
[
pos
]) && curr->content[pos] != 0)

100 
pos
++;

101 
	`quote_removing
(
head
, 
curr
, 
pos
);

104 
	}
}

	@parsing_syntax_errors.c

12 #include 
	~"minishell.h
"

14 int 
	$check_multiple_operators_error
(int 
i
, int 
num
, char 
c
)

16 if (
i
 > 
num
)

18 if (
	`is_chevron
(
c
))

19 
	`print_syntax_error_dchar
(
c
);

20 else if (
	`is_pipeline
(
c
))

21 
	`print_syntax_error_char
(
c
);

25 
	}
}

27 int 
	$count_metachar
(char *
s
, char 
c
, int 
num
)

29 int 
i
;

31 
i
 = 1;

32 while (
s
[
i
] && s[i] == 
c
)

33 
i
++;

34 if (!
	`check_multiple_operators_error
(
i
, 
num
, 
c
))

36 while (
s
[
i
] && 
	`is_blank
(s[i]))

37 
i
++;

38 if (
	`is_operator
(
s
[
i
]) && !
	`is_pipeline
(
c
))

40 
c
 = 
s
[
i
];

41 if (
	`is_chevron
(
c
) && is_chevron(
s
[
i
 + 1]))

42 return (
	`print_syntax_error_dchar
(
c
), 0);

44 
	`print_syntax_error_char
(
c
);

47 else if (
s
[
i
] == '\0')

48 return (
	`print_syntax_error_str
("newline"), 0);

50 
	}
}

52 int 
	$check_quotes_errors
(char *
s
, char 
c
, int *
i
)

54 int 
j
;

56 
j
 = *
i
 + 1;

57 while (
s
[
j
] && s[j] != 
c
)

58 
j
++;

59 if (
s
[
j
] != 
c
)

61 
	`print_syntax_error_char
(
c
);

64 (*
i
)++;

65 while (
s
[*
i
] && s[*i] != 
c
)

66 (*
i
)++;

68 
	}
}

70 int 
	$check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
)

72 int 
j
;

74 
j
 = 0;

75 while (
s
[
j
] && 
	`is_blank
(s[j]))

76 
j
++;

77 if (
s
[
j
] == 
c
)

79 
	`print_syntax_error_char
(
c
);

82 if (!
	`count_metachar
(&
s
[
i
], 
c
, 
num
))

85 
	}
}

132 int 
	$syntax_error_check
(char *
s
)

134 int 
i
;

136 
i
 = 0;

137 while (
s
[
i
])

139 if (
	`is_quote
(
s
[
i
]))

141 if (!
	`check_quotes_errors
(
s
, s[
i
], &i))

142 return (
	`free
(
s
), 0);

144 else if ((
	`is_lchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '<', 2)) || \

145 (
	`is_rchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '>', 2)))

146 return (
	`free
(
s
), 0);

147 else if (
	`is_pipeline
(
s
[
i
]) && !
	`check_pipeline_errors
(s, i, '|', 1))

148 return (
	`free
(
s
), 0);

149 
i
++;

152 
	}
}

	@parsing_syntax_errors_print_message.c

12 #include 
	~"minishell.h
"

19 void 
	$print_syntax_error_char
(char 
c
)

21 
	`ft_dprintf
(2, "minishell: ");

22 
	`ft_dprintf
(2, "syntax error near unexpected token ");

23 
	`ft_dprintf
(2, "\'%c\'\n", 
c
);

24 
g_shell
->
exit_status
 = 258;

25 
	}
}

27 void 
	$print_syntax_error_dchar
(char 
c
)

29 
	`ft_dprintf
(2, "minishell: ");

30 
	`ft_dprintf
(2, "syntax error near unexpected token ");

31 
	`ft_dprintf
(2, "\'%c%c\'\n", 
c
, c);

32 
g_shell
->
exit_status
 = 258;

33 
	}
}

35 void 
	$print_syntax_error_str
(char *
s
)

37 
	`ft_dprintf
(2, "minishell: ");

38 
	`ft_dprintf
(2, "syntax error near unexpected token ");

39 
	`ft_dprintf
(2, "\'%s\'\n", 
s
);

40 
g_shell
->
exit_status
 = 258;

41 
	}
}

	@parsing_token_extraction.c

12 #include 
	~"minishell.h
"

21 int 
	$character_extraction
(char *
line
, int 
ind
)

23 if ((
line
[
ind
] == '>' && line[ind + 1] == '>') || \

24 (
line
[
ind
] == '<' && line[ind + 1] == '<'))

27 
	}
}

43 int 
	$word_extraction
(char *
line
, int 
ind
)

45 int 
start
;

46 char 
c
;

48 
start
 = 
ind
;

49 while (
	`is_word
(
line
[
ind
]) && line[ind])

51 if (
	`is_quote
(
line
[
ind
]))

53 
c
 = 
line
[
ind
];

54 
ind
++;

55 while (
line
[
ind
] && line[ind] != 
c
)

56 
ind
++;

58 
ind
++;

60 return (
ind
 - 
start
);

61 
	}
}

64 int 
	$get_tokens_size
(char *
line
, int *
i
)

66 int 
len
;

68 
len
 = 0;

69 while (
	`is_blank
(
line
[*
i
]))

70 (*
i
)++;

71 if (
	`is_word
(
line
[*
i
]))

72 
len
 = 
	`word_extraction
(
line
, *
i
);

73 else if (
	`is_operator
(
line
[*
i
]))

74 
len
 = 
	`character_extraction
(
line
, *
i
);

75 return (
len
);

76 
	}
}

83 
t_token
 *
	$create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
)

85 
t_token
 *
head
;

87 
head
 = 
	`new_token
(
line
, 
i
, 
len
);

88 if (!
head
)

89 return (
NULL
);

90 *
flag
 = 1;

91 return (
head
);

92 
	}
}

122 
t_token
 *
	$get_tokens
(char *
line
)

124 int 
i
;

125 int 
len
;

126 int 
flag
;

127 
t_token
 *
head
;

129 
i
 = 0;

130 
flag
 = 0;

131 
head
 = 
NULL
;

132 while (
line
[
i
])

134 
len
 = 
	`get_tokens_size
(
line
, &
i
);

135 if (
len
 == 0)

137 if (!
flag
)

139 
head
 = 
	`create_token_head
(
line
, 
i
, 
len
, &
flag
);

140 if (!
head
)

141 return (
	`free
(
line
), 
NULL
);

144 if (!
	`token_linked_list
(&
head
, 
line
, 
i
, 
len
))

145 return (
	`free_token
(&
head
), 
	`free
(
line
), 
NULL
);

146 
i
 += 
len
;

148 return (
	`free
(
line
), 
head
);

149 
	}
}

	@token_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_token
(
t_token
 **
head
)

16 
t_token
 *
ptr
;

17 
t_token
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
content
);

27 
	`free
(
tmp
);

29 *
head
 = 
NULL
;

30 
	}
}

45 
t_token
 *
	$new_token
(char *
line
, int 
start
, int 
len
)

47 
t_token
 *
token
;

49 
token
 = 
NULL
;

50 
token
 = 
	`malloc
(sizeof(
t_token
));

51 if (!
token
)

53 
	`malloc_error_print_message
(
	`strerror
(
errno
));

54 return (
NULL
);

56 
token
->
content
 = 
	`ft_substr
(
line
, 
start
, 
len
);

57 if (!
token
->
content
)

59 
	`malloc_error_print_message
(
	`strerror
(
errno
));

60 return (
	`free_token
(&
token
), 
NULL
);

62 
	`set_id
(
token
);

63 
token
->
next
 = 
NULL
;

64 return (
token
);

65 
	}
}

74 int 
	$link_token
(
t_token
 **
head
, t_token *
new
)

76 
t_token
 *
ptr
;

78 if (!
new
)

80 
ptr
 = *
head
;

81 while (
ptr
)

83 if (!
ptr
->
next
)

85 
ptr
 = ptr->
next
;

87 
ptr
->
next
 = 
new
;

89 
	}
}

112 int 
	$token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
)

114 
t_token
 *
new
;

116 if (!
head
)

118 
new
 = 
	`new_token
(
line
, 
start
, 
len
);

119 if (!
new
)

121 if (!
	`link_token
(
head
, 
new
))

124 
	}
}

	@token_routine_delete.c

12 #include 
	~"minishell.h
"

14 int 
	$token_list_size
(
t_token
 **
head
)

16 
t_token
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

29 static 
t_token
 *
delete_helper
(t_token **
head
, t_token *
curr
, \

30 
t_token
 *
prev
, int 
i
)

32 int 
	gsize
;

34 
	gsize
 = 
token_list_size
(
head
);

35 if (
	gi
 == 0 && 
size
 == 1)

37 
free
(
curr
->
content
);

38 
free
(
curr
);

39 *
	ghead
 = 
NULL
;

40 return (*
	ghead
);

42 else if (
	gi
 == 0 && 
size
 > 1)

44 *
head
 = 
curr
->
next
;

45 
	gprev
 = *
head
;

47 else if (
	gi
 == 
size
 - 1)

48 
prev
->
next
 = 
NULL
;

50 
	gprev
->
	gnext
 = 
curr
->
next
;

51 
free
(
curr
->
content
);

52 
free
(
curr
);

53 
	gcurr
 = 
NULL
;

54 return (
	gprev
);

57 
t_token
 *
	$delete_token
(
t_token
 **
head
)

59 int 
i
;

60 
t_token
 *
curr
;

61 
t_token
 *
prev
;

63 
i
 = 0;

64 
curr
 = *
head
;

65 
prev
 = 
NULL
;

66 while (
curr
->
id
 != 
DELETE
)

68 
prev
 = 
curr
;

69 
curr
 = curr->
next
;

70 
i
++;

72 return (
	`delete_helper
(
head
, 
curr
, 
prev
, 
i
));

73 
	}
}

	@token_routine_set_id.c

12 #include 
	~"minishell.h
"

14 int 
	$set_id_expansion
(
t_token
 *
token
)

16 if (
	`ft_strchr
(
token
->
content
, '$'))

17 return(
DOLLAR
);

18 return (
WORD
);

19 
	}
}

21 void 
	$set_id
(
t_token
 *
token
)

23 if (
	`ft_strncmp
(
token
->
content
, "|", 2) == 0)

24 
token
->
id
 = 
PIPELINE
;

25 else if (
	`ft_strncmp
(
token
->
content
, "<", 2) == 0)

26 
token
->
id
 = 
L_CHEVRON
;

27 else if (
	`ft_strncmp
(
token
->
content
, ">", 2) == 0)

28 
token
->
id
 = 
R_CHEVRON
;

29 else if (
	`ft_strncmp
(
token
->
content
, "<<", 3) == 0)

30 
token
->
id
 = 
HERE_DOC
;

31 else if (
	`ft_strncmp
(
token
->
content
, ">>", 3) == 0)

32 
token
->
id
 = 
APPEND
;

33 else if (
	`ft_strchr
(
token
->
content
, '$'))

34 
token
->
id
 = 
DOLLAR
;

36 
token
->
id
 = 
WORD
;

38 
	}
}

	@
1
.
0
98
2531
envp_routine.c
is_dollar.c
is_operator.c
is_question.c
is_quote.c
is_token.c
is_white_space.c
libft/ft_printf/ft_count_int.c
libft/ft_printf/ft_count_unsigned_int.c
libft/ft_printf/ft_dprintf.c
libft/ft_printf/ft_printf.c
libft/ft_printf/ft_printf_address.c
libft/ft_printf/ft_printf_char.c
libft/ft_printf/ft_printf_hexa.c
libft/ft_printf/ft_printf_int.c
libft/ft_printf/ft_printf_str.c
libft/ft_printf/ft_printf_unsint.c
libft/ft_printf/ft_put_hexanbr_fd.c
libft/ft_printf/ft_put_int.c
libft/ft_printf/ft_put_unsnbr_fd.c
libft/get_next_line/get_next_line.c
libft/get_next_line/get_next_line_bonus.c
libft/get_next_line/get_next_line_utils.c
libft/includes/ft_printf.h
libft/includes/get_next_line.h
libft/includes/libft.h
libft/libft/del.c
libft/libft/ft_atoi.c
libft/libft/ft_atoi_base.c
libft/libft/ft_bzero.c
libft/libft/ft_calloc.c
libft/libft/ft_isalnum.c
libft/libft/ft_isalpha.c
libft/libft/ft_isascii.c
libft/libft/ft_isdigit.c
libft/libft/ft_isprint.c
libft/libft/ft_itoa.c
libft/libft/ft_lstadd_back.c
libft/libft/ft_lstadd_front.c
libft/libft/ft_lstclear.c
libft/libft/ft_lstdel_first_el.c
libft/libft/ft_lstdel_last_el.c
libft/libft/ft_lstdelone.c
libft/libft/ft_lstiter.c
libft/libft/ft_lstlast.c
libft/libft/ft_lstmap.c
libft/libft/ft_lstnew.c
libft/libft/ft_lstsize.c
libft/libft/ft_memchr.c
libft/libft/ft_memcmp.c
libft/libft/ft_memcpy.c
libft/libft/ft_memmove.c
libft/libft/ft_memset.c
libft/libft/ft_putchar_fd.c
libft/libft/ft_putendl_fd.c
libft/libft/ft_putnbr_fd.c
libft/libft/ft_putstr_fd.c
libft/libft/ft_split.c
libft/libft/ft_strchr.c
libft/libft/ft_strcpy.c
libft/libft/ft_strcspn.c
libft/libft/ft_strdup.c
libft/libft/ft_striteri.c
libft/libft/ft_strjoin.c
libft/libft/ft_strlcat.c
libft/libft/ft_strlcpy.c
libft/libft/ft_strlen.c
libft/libft/ft_strmapi.c
libft/libft/ft_strncmp.c
libft/libft/ft_strncpy.c
libft/libft/ft_strnstr.c
libft/libft/ft_strpbrk.c
libft/libft/ft_strrchr.c
libft/libft/ft_strspn.c
libft/libft/ft_strtrim.c
libft/libft/ft_substr.c
libft/libft/ft_tolower.c
libft/libft/ft_toupper.c
libft/libft/power.c
libft/libft/str_lowercase.c
main.c
malloc_error_print_message.c
minishell.h
parsing.c
parsing_expansion.c
parsing_expansion_dollar_conditions.c
parsing_expansion_expand_var_helper.c
parsing_expansion_helper.c
parsing_expansion_join_tokens.c
parsing_expansion_looping.c
parsing_expansion_trim_dollar.c
parsing_quote_removing.c
parsing_syntax_errors.c
parsing_syntax_errors_print_message.c
parsing_token_extraction.c
token_routine.c
token_routine_delete.c
token_routine_set_id.c
