cscope 15 $HOME/Documents/GitHub/minishell/rita -c -q 0000000534 0000113124
	@builtins/cd.c

12 #include 
	~"minishell.h
"

14 static void 
	$change_env_error
(char *
oldpwd
, char *
pwd
, 
t_cmd
 *
cmd
)

16 
	`malloc_error_print_message
("ft_strdup failed");

17 if (
oldpwd
)

18 
	`free
 (
oldpwd
);

19 if (
pwd
)

20 
	`free
 (
pwd
);

21 
	`free_and_exit_prog
(&
cmd
, 1);

22 
	}
}

24 static void 
	$change_env
(char *
oldpwd
, char *
pwd
, 
t_cmd
 *
cmd
)

26 
t_env
 *
env
;

28 
env
 = 
g_shell
->env;

29 while (
env
 != 
NULL
)

31 if (
	`ft_strncmp
(
env
->
var_name
, "OLDPWD", 7) == 0)

33 
	`free
(
env
->
var_value
);

34 
env
->
var_value
 = 
NULL
;

35 
env
->
var_value
 = 
	`ft_strdup
(
oldpwd
);

36 if (!
env
->
var_value
)

37 
	`change_env_error
(
oldpwd
, 
pwd
, 
cmd
);

39 if (
	`ft_strncmp
(
env
->
var_name
, "PWD", 4) == 0)

41 
	`free
(
env
->
var_value
);

42 
env
->
var_value
 = 
NULL
;

43 
env
->
var_value
 = 
	`ft_strdup
(
pwd
);

44 if (!
env
->
var_value
)

45 
	`change_env_error
(
oldpwd
, 
pwd
, 
cmd
);

47 
env
 = env->
next
;

49 
g_shell
->
exit_status
 = 0;

50 return (
	`free
(
oldpwd
), free(
pwd
));

51 
	}
}

53 static void 
	$print_chdir_error
(char *
arg
, char *
err
)

55 
	`ft_dprintf
(2, "minishell: cd: %s: ", 
arg
);

56 
	`ft_dprintf
(2, "%s\n", 
err
);

57 
g_shell
->
exit_status
 = 1;

58 
	}
}

60 static int 
	$change_dir
(char *
oldpwd
, char *
path
)

62 int 
res
;

64 
res
 = 
	`chdir
(
path
);

65 if (
res
 == -1)

67 
	`free
(
oldpwd
);

68 
	`print_chdir_error
(
path
, 
	`strerror
(
errno
));

71 
g_shell
->
exit_status
 = 0;

73 
	}
}

76 void 
	$_cd
(
t_cmd
 *
cmd
)

78 int 
res
;

79 char *
oldpwd
;

80 char *
pwd
;

82 
oldpwd
 = 
	`getcwd
(
NULL
, 0);

83 if (!
oldpwd
)

85 
	`print_getcwd_error
(
	`strerror
(
errno
));

88 if (
	`size_tab2d
(
cmd
->cmd) == 1)

89 
res
 = 
	`change_dir
(
oldpwd
, 
	`get_env_var_value
("HOME"));

91 
res
 = 
	`change_dir
(
oldpwd
, 
cmd
->cmd[1]);

92 if (!
res
)

94 
pwd
 = 
	`getcwd
(
NULL
, 0);

95 if (!
pwd
)

97 
	`free
(
oldpwd
);

98 
	`print_getcwd_error
(
	`strerror
(
errno
));

101 
	`change_env
(
oldpwd
, 
pwd
, 
cmd
);

102 
	}
}

	@builtins/echo.c

12 #include 
	~"minishell.h
"

14 static void 
	$print_echo
(char **
s
, int 
i
)

16 int 
size
;

18 
size
 = 
i
;

19 while (
s
[
size
])

20 
size
++;

21 if (
size
 == 
i
)

23 while (
s
[
i
])

25 
	`ft_printf
("%s", 
s
[
i
]);

26 if (
i
 != 
size
 - 1)

27 
	`ft_printf
(" ");

28 
i
++;

30 
	}
}

32 static int 
	$size_echo_cmd
(char **
s
)

34 int 
i
;

36 
i
 = 0;

37 while (
s
[
i
])

38 
i
++;

39 return (
i
);

40 
	}
}

42 int 
	$_echo
(
t_cmd
 *
cmd
)

44 if (
	`size_echo_cmd
(
cmd
->cmd) == 1)

46 
	`ft_printf
("\n");

47 
g_shell
->
exit_status
 = 0;

50 if (
	`ft_strncmp
(
cmd
->cmd[1], "-n", 3) != 0)

52 
	`print_echo
(
cmd
->cmd, 1);

53 
	`ft_printf
("\n");

56 
	`print_echo
(
cmd
->cmd, 2);

57 
g_shell
->
exit_status
 = 0;

59 
	}
}

	@builtins/env.c

12 #include 
	~"minishell.h
"

14 static int 
	$check_env
(
t_cmd
 *
cmd
)

16 int 
size
;

18 
size
 = 
	`size_tab2d
(
cmd
->cmd);

19 if (
size
 == 1)

21 
	`ft_dprintf
(2, "env: %s: ", 
cmd
->cmd[1]);

22 
	`ft_dprintf
(2, "No such file or directory\n");

23 
g_shell
->
exit_status
 = 127;

25 
	}
}

27 void 
	$_env
(
t_cmd
 *
cmd
, 
t_env
 *
env
)

29 int 
res
;

31 
res
 = 
	`check_env
(
cmd
);

32 if (!
res
)

34 if (!
env
)

36 
g_shell
->
exit_status
 = 0;

39 while (
env
 != 
NULL
)

41 if (
env
->
var_value
)

43 
	`ft_printf
("%s=", 
env
->
var_name
);

44 if (
env
->
var_value
)

45 
	`ft_printf
("%s\n", 
env
->
var_value
);

47 
env
 = env->
next
;

49 
g_shell
->
exit_status
 = 0;

51 
	}
}

	@builtins/exit.c

12 #include 
	~"minishell.h
"

14 static void 
	$first_argument_is_numeric
(
t_cmd
 *
cmd
, int 
size
)

16 long long 
exit_status
;

18 
exit_status
 = 0;

19 if (
size
 == 2)

21 
	`printf
("exit\n");

22 
exit_status
 = 
	`ft_atoi
(
cmd
->cmd[1]);

23 
	`free_before_exit
(&
cmd
);

24 
	`exit
 (
exit_status
 % 256);

26 else if (
size
 > 2)

28 
	`ft_dprintf
(2, "exit\n");

29 
	`ft_dprintf
(2, "minishell: exit: too many arguments\n");

30 
g_shell
->
exit_status
 = 1;

32 
	}
}

34 static int 
	$change_i
(
t_cmd
 *
cmd
, int 
i
)

36 while (
cmd
->cmd[1][
i
] == 32 || \

37 (
cmd
->cmd[1][
i
] >= 9 && cmd->cmd[1][i] <= 13))

38 
i
++;

39 if (
cmd
->cmd[1][
i
] == '-')

40 
i
++;

41 else if (
cmd
->cmd[1][
i
] == '+')

42 
i
++;

43 return (
i
);

44 
	}
}

46 static int 
	$check_exit_arguments
(
t_cmd
 *
cmd
)

48 int 
size
;

49 int 
i
;

51 
i
 = 0;

52 
size
 = 
	`size_tab2d
(
cmd
->cmd);

53 if (
size
 == 1)

55 
i
 = 
	`change_i
(
cmd
, i);

56 if (
cmd
->cmd[1][
i
] >= '0' && cmd->cmd[1][i] <= '9' && \

57 
	`no_int_errors
(
cmd
->cmd[1]))

58 
	`first_argument_is_numeric
(
cmd
, 
size
);

61 
	`ft_dprintf
(2, "exit\n");

62 
	`ft_dprintf
(2, "minishell: exit: %s: ", 
cmd
->cmd[1]);

63 
	`ft_dprintf
(2, "numeric argument required\n");

64 
	`free_before_exit
(&
cmd
);

65 
	`exit
 (255);

68 
	}
}

70 void 
	$ft_exit
(
t_cmd
 *
cmd
)

72 int 
res
;

73 int 
exit_status
;

75 
res
 = 
	`check_exit_arguments
(
cmd
);

76 if (!
res
)

78 
exit_status
 = 
g_shell
->exit_status;

79 
	`free_before_exit
(&
cmd
);

80 
	`printf
("exit\n");

81 
	`exit
 (
exit_status
);

83 
	}
}

	@builtins/export.c

12 #include 
	~"minishell.h
"

14 static int 
	$change_env_var
(char *
s
, char *
var_name
, int 
i
)

16 
t_env
 *
env
;

18 
env
 = 
g_shell
->env;

19 while (
env
)

21 if (
	`ft_strncmp
(
var_name
, 
env
->var_name, 
	`ft_strlen
(var_name)) == 0)

23 
env
 = env->
next
;

25 
	`free
(
env
->
var_value
);

26 
env
->
var_value
 = 
NULL
;

27 
env
->
var_value
 = 
	`ft_substr
(
s
, 
i
 + 1, 
	`ft_strlen
(s) - (i + 1));

28 if (!
env
->
var_value
)

30 
	`malloc_error_print_message
("ft_strdup failed");

34 
	}
}

36 static int 
	$export_with_args_helper
(char *
var_name
, char *
s
, int 
i
)

38 int 
res
;

39 
t_env
 *
new
;

41 
res
 = 
	`check_if_var_exists
(
var_name
);

42 if (!
res
)

44 
new
 = 
	`new_env
(
s
);

45 if (!
new
)

47 if (!
g_shell
->
env
)

48 
g_shell
->
env
 = 
new
;

50 
	`link_env
(&
g_shell
->
env
, 
new
);

52 else if (
res
 && 
s
[
i
] == '=')

54 if (!
	`change_env_var
(
s
, 
var_name
, 
i
))

58 
	}
}

60 static int 
	$export_with_args
(char *
s
)

62 int 
res
;

63 int 
i
;

64 char *
var_name
;

66 
i
 = 0;

67 
res
 = 
	`check_if_valid_identifier
(
s
, "export");

68 if (!
res
)

70 while (
s
[
i
] && s[i] != '=')

71 
i
++;

72 if (
s
[
i
] == '=' && (
	`is_blank
(s[i - 1]) || is_blank(s[i + 1])))

74 
	`print_export_unset_error
(
s
, "export");

77 
var_name
 = 
	`ft_substr
(
s
, 0, 
i
);

78 if (!
var_name
)

80 
	`malloc_error_print_message
("ft_substr failed");

81 return (
ERROR_EXIT
);

83 
res
 = 
	`export_with_args_helper
(
var_name
, 
s
, 
i
);

84 
	`free
(
var_name
);

85 return (
res
);

86 
	}
}

88 static void 
	$export_no_args
(void)

90 
t_env
 *
env
;

92 
env
 = 
g_shell
->env;

93 while (
env
)

95 if (
env
->
var_value
)

97 
	`ft_printf
("declare -x %s=", 
env
->
var_name
);

98 
	`ft_printf
("\"%s\"\n", 
env
->
var_value
);

101 
	`ft_printf
("declare -x %s\n", 
env
->
var_name
);

102 
env
 = env->
next
;

104 
	}
}

111 void 
	$_export
(
t_cmd
 *
cmd
)

113 int 
i
;

114 int 
res
;

115 int 
save
;

117 
save
 = 1;

118 
i
 = 
	`size_tab2d
(
cmd
->cmd);

119 if (
i
 == 1)

121 
	`export_no_args
();

124 
i
 = 1;

125 while (
cmd
->cmd[
i
])

127 
res
 = 
	`export_with_args
(
cmd
->cmd[
i
]);

128 if (
res
 == 
ERROR_EXIT
)

129 
	`free_and_exit_prog
(&
cmd
, 1);

130 else if (!
res
)

131 
save
 = 
res
;

132 
i
++;

134 if (!
save
)

135 
g_shell
->
exit_status
 = 1;

137 
g_shell
->
exit_status
 = 0;

138 
	}
}

	@builtins/export_unset_helper.c

12 #include 
	~"minishell.h
"

14 void 
	$print_export_unset_error
(char *
identifier
, char *
command
)

16 
	`ft_dprintf
(2, "minishell: %s: ", 
command
);

17 
	`ft_dprintf
(2, "`%s': not a valid identifier\n", 
identifier
);

18 
g_shell
->
exit_status
 = 1;

19 
	}
}

26 int 
	$check_if_valid_identifier
(char *
s
, char *
command
)

28 int 
i
;

30 
i
 = 0;

31 if (
	`is_punct
(
s
[0]) || 
	`ft_isdigit
(s[0]) || s[0] == '_')

33 
	`print_export_unset_error
(
s
, 
command
);

36 while (
s
[
i
] && s[i] != '=')

37 
i
++;

38 
i
--;

39 if (
	`is_punct
(
s
[
i
]) || s[i] == ' ')

41 
	`print_export_unset_error
(
s
, 
command
);

45 
	}
}

53 int 
	$check_if_var_exists
(char *
s
)

55 
t_env
 *
env
;

57 
env
 = 
g_shell
->env;

58 while (
env
)

60 if (
	`ft_strncmp
(
s
, 
env
->
var_name
, 
	`ft_strlen
(s)) == 0)

62 
env
 = env->
next
;

65 
	}
}

	@builtins/int_min_max.c

12 #include 
	~"minishell.h
"

14 static int 
	$negative_int_check
(char *
str
)

16 char *
s_int_min
;

17 int 
len
;

19 if (!
str
)

21 
s_int_min
 = "-9223372036854775808";

22 
len
 = 
	`ft_strlen
(
str
);

23 if (
len
 > 20)

25 if (
len
 == 20 && 
	`ft_strncmp
(
s_int_min
, 
str
, 20) < 0)

28 
	}
}

30 static int 
	$positive_int_check
(char *
str
)

32 char *
s_int_max
;

33 int 
len
;

35 if (!
str
)

37 
s_int_max
 = "+9223372036854775807";

38 
len
 = 
	`ft_strlen
(
str
);

39 if (
len
 > 20)

41 if (
len
 == 20 && 
	`ft_strncmp
(
s_int_max
, 
str
, 20) < 0)

44 
	}
}

46 static int 
	$int_check
(char *
str
)

48 char *
s_int_max
;

49 int 
i
;

50 int 
len
;

52 
s_int_max
 = "9223372036854775807";

53 
i
 = 0;

54 if (!
str
)

56 
len
 = 
	`ft_strlen
(
str
);

57 if (
len
 > 19)

59 if (
len
 == 19 && 
	`ft_strncmp
(
s_int_max
, 
str
, 19) < 0)

62 
	}
}

64 int 
	$no_int_errors
(char *
str
)

66 if (!
str
)

68 if (
str
[0] == '-')

70 if (!
	`negative_int_check
(
str
))

73 else if (
str
[0] == '+')

75 if (!
	`positive_int_check
(
str
))

80 if (!
	`int_check
(
str
))

84 
	}
}

	@builtins/pwd.c

12 #include 
	~"minishell.h
"

14 void 
	$print_getcwd_error
(char *
s
)

16 
	`ft_dprintf
(2, "minishell: cd: getcwd: %s\n", 
s
);

17 
g_shell
->
exit_status
 = 1;

18 
	}
}

20 void 
	$_pwd
(void)

22 char *
cwd
;

24 
cwd
 = 
	`getcwd
(
NULL
, 0);

25 if (!
cwd
)

27 
	`print_getcwd_error
(
	`strerror
(
errno
));

30 
	`ft_printf
("%s\n", 
cwd
);

31 
	`free
(
cwd
);

32 
g_shell
->
exit_status
 = 0;

34 
	}
}

	@builtins/unset.c

12 #include 
	~"minishell.h
"

14 static int 
	$env_list_size
(
t_env
 **
head
)

16 
t_env
 *
env
;

17 int 
i
;

19 
env
 = *
head
;

20 
i
 = 0;

21 while (
env
)

23 
env
 = env->
next
;

24 
i
++;

26 return (
i
);

27 
	}
}

29 static void 
	$free_env_var
(
t_env
 *
curr
)

31 
	`free
(
curr
->
var_name
);

32 if (
curr
->
var_value
)

33 
	`free
(
curr
->
var_value
);

34 
	`free
(
curr
);

35 
	}
}

37 static void 
delete_env_helper
(
t_env
 **
head
, t_env *
curr
, \

38 
t_env
 *
prev
, int 
i
)

40 int 
	gsize
;

42 
	gsize
 = 
env_list_size
(
head
);

43 if (
	gi
 == 0 && 
size
 == 1)

45 
free_env_var
(
curr
);

46 *
	ghead
 = 
NULL
;

49 else if (
	gi
 == 0 && 
size
 > 1)

51 *
head
 = 
curr
->
next
;

52 
	gprev
 = *
head
;

54 else if (
	gi
 == 
size
 - 1)

55 
prev
->
next
 = 
NULL
;

57 
	gprev
->
	gnext
 = 
curr
->
next
;

58 
free_env_var
(
curr
);

62 static void 
	$delete_env_var
(
t_env
 **
head
, char *
s
)

64 int 
i
;

65 
t_env
 *
curr
;

66 
t_env
 *
prev
;

68 
i
 = 0;

69 
curr
 = *
head
;

70 
prev
 = 
NULL
;

71 while (
curr
 && 
	`ft_strncmp
(
s
, curr->
var_name
, 
	`ft_strlen
(s)) != 0)

73 
prev
 = 
curr
;

74 
curr
 = curr->
next
;

75 
i
++;

77 if (!
curr
)

79 if (
	`ft_strncmp
(
s
, 
curr
->
var_name
, 
	`ft_strlen
(s)) == 0)

80 
	`delete_env_helper
(
head
, 
curr
, 
prev
, 
i
);

81 
g_shell
->
exit_status
 = 0;

82 
	}
}

84 void 
	$_unset
(
t_cmd
 *
cmd
)

86 int 
i
;

87 int 
res
;

88 int 
save
;

90 
i
 = 1;

91 
res
 = 0;

92 
save
 = 1;

93 while (
cmd
->cmd[
i
])

95 
res
 = 
	`check_if_valid_identifier
(
cmd
->cmd[
i
], "unset");

96 if (
res
)

97 
	`delete_env_var
(&
g_shell
->
env
, 
cmd
->cmd[
i
]);

98 else if (!
res
)

99 
save
 = 
res
;

100 
i
++;

102 if (!
save
)

103 
g_shell
->
exit_status
 = 1;

104 
	}
}

	@command_struct/free_cmd.c

12 #include 
	~"minishell.h
"

14 void 
	$free_tab2d
(char **
s
)

16 int 
i
;

18 if (!
s
 || !*s)

20 
i
 = 0;

21 while (
s
[
i
])

23 
	`free
 (
s
[
i
]);

24 
i
++;

26 
	`free
 (
s
);

27 
	}
}

29 void 
	$free_cmd
(
t_cmd
 **
head
)

31 
t_cmd
 *
ptr
;

32 
t_cmd
 *
tmp
;

34 if (!
head
 || !*head)

36 
ptr
 = *
head
;

37 while (
ptr
)

39 
tmp
 = 
ptr
;

40 
ptr
 = ptr->
next
;

41 
	`free_tab2d
(
tmp
->
cmd
);

42 
	`free_tab2d
(
tmp
->
redir
);

43 
tmp
->
cmd
 = 
NULL
;

44 
tmp
->
redir
 = 
NULL
;

45 
	`free
(
tmp
);

47 *
head
 = 
NULL
;

48 
	}
}

	@command_struct/init_cmd.c

12 #include 
	~"minishell.h
"

14 static void 
	$cmd_backadd
(
t_cmd
 **
head
, t_cmd *
new
)

16 
t_cmd
 *
ptr
;

18 if (!
head
 || !
new
)

20 if (!*
head
)

22 *
head
 = 
new
;

25 
ptr
 = *
head
;

26 while (
ptr
)

28 if (!
ptr
->
next
)

30 
ptr
 = ptr->
next
;

32 
ptr
->
next
 = 
new
;

33 
	}
}

35 static void 
	$init_fds
(
t_cmd
 *
cmd
)

37 
cmd
->
ffd_in
 = -1;

38 
cmd
->
ffd_out
 = -1;

39 
cmd
->
save_fdout
 = -1;

40 
cmd
->
save_fdin
 = -1;

41 
	}
}

56 static 
t_cmd
 *
	$init_cmd
(
t_token
 **
token
)

58 
t_cmd
 *
cmd
;

59 int 
res
;

61 
res
 = 0;

62 
cmd
 = 
	`ft_calloc
(1, sizeof(
t_cmd
));

63 if (!
cmd
)

65 
	`malloc_error_print_message
("ft_calloc failed");

66 return (
NULL
);

68 
cmd
->
next
 = 
NULL
;

69 
res
 = 
	`create_cmd
(
token
, 
cmd
);

70 if (!
res
)

72 
	`free_cmd
(&
cmd
);

73 return (
NULL
);

75 
res
 = 
	`create_redir
(
token
, 
cmd
);

76 if (!
res
)

78 
	`free_cmd
(&
cmd
);

79 return (
NULL
);

81 
	`init_fds
(
cmd
);

82 return (
cmd
);

83 
	}
}

85 static void 
	$create_cmd_linked_list
(
t_token
 **
token
, 
t_cmd
 *
head
)

87 
t_cmd
 *
new
;

88 
t_token
 *
ptr
;

90 
ptr
 = *
token
;

91 
new
 = 
NULL
;

92 while (
ptr
)

94 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

95 
ptr
 = ptr->
next
;

96 if (!
ptr
)

98 
ptr
 = ptr->
next
;

99 
new
 = 
	`init_cmd
(&
ptr
);

100 if (!
new
)

102 
	`free_cmd
(&
head
);

105 
	`cmd_backadd
(&
head
, 
new
);

107 
	}
}

126 
t_cmd
 *
	$cmd_linked_list
(
t_token
 **
token
)

128 
t_cmd
 *
head
;

129 
t_token
 *
ptr
;

131 if (!
token
 || !*token)

132 return (
NULL
);

133 
ptr
 = *
token
;

134 
head
 = 
NULL
;

135 
head
 = 
	`init_cmd
(&
ptr
);

136 if (!
head
)

137 return (
NULL
);

138 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

139 
ptr
 = ptr->
next
;

140 
	`create_cmd_linked_list
(&
ptr
, 
head
);

141 
	`free_token
(
token
);

142 if (!
head
)

143 return (
NULL
);

144 return (
head
);

145 
	}
}

	@command_struct/init_cmd_cmd.c

12 #include 
	~"minishell.h
"

14 static int 
	$copy_cmd_helper
(
t_token
 *
ptr
, 
t_cmd
 *
cmd
, int 
i
)

16 
cmd
->cmd[
i
] = 
	`ft_strdup
(
ptr
->
content
);

17 if (!
cmd
->cmd[
i
])

19 
	`malloc_error_print_message
("ft_strdup failed");

23 
	}
}

46 static 
t_token
 *
	$get_next_ptr
(
t_token
 *
ptr
)

48 if (
ptr
->
id
 == 
L_CHEVRON
 || ptr->id == 
R_CHEVRON
 || \

49 
ptr
->
id
 == 
APPEND
)

50 
ptr
 = ptr->
next
->next;

51 else if (
ptr
->
id
 == 
HERE_DOC
)

53 if (!
ptr
->
next
)

54 return (
NULL
);

55 else if (
ptr
->
next
->
id
 == 
KEY_WORD
 && ptr->next->next)

56 
ptr
 = ptr->
next
->next;

58 return (
NULL
);

60 return (
ptr
);

61 
	}
}

63 static int 
	$copy_cmd
(
t_token
 **
token
, 
t_cmd
 *
cmd
)

65 
t_token
 *
ptr
;

66 int 
i
;

68 
ptr
 = *
token
;

69 
i
 = 0;

70 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

72 if (
ptr
->
id
 == 
L_CHEVRON
 || ptr->id == 
R_CHEVRON
 || \

73 
ptr
->
id
 == 
APPEND
 || ptr->id == 
HERE_DOC
)

74 
ptr
 = 
	`get_next_ptr
(ptr);

77 if (!
	`copy_cmd_helper
(
ptr
, 
cmd
, 
i
))

79 
ptr
 = ptr->
next
;

80 
i
++;

83 
cmd
->cmd[
i
] = 
NULL
;

85 
	}
}

87 static int 
	$get_cmd_size
(
t_token
 **
token
)

89 
t_token
 *
ptr
;

90 int 
i
;

92 
i
 = 0;

93 
ptr
 = *
token
;

94 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

96 if (
ptr
->
id
 == 
L_CHEVRON
 || ptr->id == 
R_CHEVRON
 || \

97 
ptr
->
id
 == 
APPEND
 || ptr->id == 
HERE_DOC
)

98 
ptr
 = 
	`get_next_ptr
(ptr);

101 
i
++;

102 
ptr
 = ptr->
next
;

105 return (
i
);

106 
	}
}

125 int 
	$create_cmd
(
t_token
 **
token
, 
t_cmd
 *
cmd
)

127 int 
i
;

128 int 
res
;

130 
i
 = 
	`get_cmd_size
(
token
);

131 if (
i
 == 0)

133 
cmd
->cmd = 
	`malloc
(sizeof(char *) * (
i
 + 1));

134 if (!
cmd
->cmd)

136 
	`malloc_error_print_message
(
	`strerror
(
errno
));

139 
res
 = 
	`copy_cmd
(
token
, 
cmd
);

140 if (!
res
)

143 
	}
}

	@command_struct/init_cmd_redir.c

12 #include 
	~"minishell.h
"

14 static int 
	$get_redir_size
(
t_token
 *
ptr
)

16 int 
i
;

18 
i
 = 0;

19 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

21 if (
ptr
->
id
 == 
L_CHEVRON
 || ptr->id == 
R_CHEVRON
 || \

22 
ptr
->
id
 == 
APPEND
)

23 
i
 = i + 2;

24 else if (
ptr
->
id
 == 
HERE_DOC
 && ptr->
next
 && ptr->next->id == 
KEY_WORD
)

25 
i
 = i + 2;

26 else if (
ptr
->
id
 == 
HERE_DOC
)

27 
i
 = i + 1;

28 
ptr
 = ptr->
next
;

30 return (
i
);

31 
	}
}

33 static int 
	$copy_redir_helper
(
t_token
 *
ptr
, 
t_cmd
 *
cmd
, int 
i
)

35 
cmd
->
redir
[
i
] = 
	`ft_strdup
(
ptr
->
content
);

36 if (!
cmd
->
redir
[
i
])

38 
	`malloc_error_print_message
("ft_strdup failed");

41 if (
ptr
->
id
 == 
HERE_DOC
)

42 return (
i
);

43 
i
++;

44 
ptr
 = ptr->
next
;

45 
cmd
->
redir
[
i
] = 
	`ft_strdup
(
ptr
->
content
);

46 if (!
cmd
->
redir
[
i
])

48 
	`malloc_error_print_message
("ft_strdup failed");

51 return (
i
);

52 
	}
}

74 static int 
	$copy_redir
(
t_token
 **
token
, 
t_cmd
 *
cmd
)

76 
t_token
 *
ptr
;

77 int 
i
;

79 
ptr
 = *
token
;

80 
i
 = 0;

81 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

83 if (
ptr
->
id
 == 
L_CHEVRON
 || ptr->id == 
R_CHEVRON
 || \

84 
ptr
->
id
 == 
APPEND
 || ptr->id == 
HERE_DOC
)

86 
i
 = 
	`copy_redir_helper
(
ptr
, 
cmd
, i);

87 if (
i
 == -1)

89 
i
++;

91 
ptr
 = ptr->
next
;

94 
	}
}

120 int 
	$create_redir
(
t_token
 **
token
, 
t_cmd
 *
cmd
)

122 
t_token
 *
ptr
;

123 int 
i
;

124 int 
res
;

126 
res
 = 0;

127 
ptr
 = *
token
;

128 
i
 = 
	`get_redir_size
(
ptr
);

129 if (
i
 == 0)

131 
cmd
->
redir
 = 
	`ft_calloc
(
i
 + 1, sizeof(char *));

132 if (!
cmd
->
redir
)

134 
	`malloc_error_print_message
("ft_calloc failed");

137 
res
 = 
	`copy_redir
(
token
, 
cmd
);

138 if (!
res
)

140 
	`free_tab2d
(
cmd
->
redir
);

144 
	}
}

	@environnement/envp_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_env
(
t_env
 **
head
)

16 
t_env
 *
ptr
;

17 
t_env
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 if (
tmp
->
var_name
)

27 
	`free
(
tmp
->
var_name
);

28 if (
tmp
->
var_value
)

29 
	`free
(
tmp
->
var_value
);

30 
	`free
(
tmp
);

32 *
head
 = 
NULL
;

33 
	}
}

43 int 
	$new_env_helper
(char *
envp
, int 
end
)

45 while (
envp
[
end
] != '=' && envp[end])

46 
end
++;

47 return (
end
);

48 
	}
}

50 
t_env
 *
	$new_env
(char *
envp
)

52 
t_env
 *
env
;

53 int 
end
;

54 int 
start
;

56 if (!
envp
)

57 return (
NULL
);

58 
start
 = 0;

59 
end
 = 0;

60 
env
 = 
	`ft_calloc
(1, sizeof(
t_env
));

61 if (!
env
)

62 return (
	`malloc_error_print_message
("ft_calloc failed"), 
NULL
);

63 
end
 = 
	`new_env_helper
(
envp
, end);

64 
env
->
var_name
 = 
	`ft_substr
(
envp
, 0, 
end
);

65 if (!
env
->
var_name
)

66 return (
NULL
);

67 if (
envp
[
end
++] == '\0')

68 return (
env
);

69 
start
 = 
end
;

70 while (
envp
[
end
] != '\0')

71 
end
++;

72 
env
->
var_value
 = 
	`ft_substr
(
envp
, 
start
, 
end
 - start);

73 if (!
env
->
var_value
)

74 return (
	`malloc_error_print_message
("ft stubstr failed"), 
NULL
);

75 
env
->
next
 = 
NULL
;

76 return (
env
);

77 
	}
}

82 int 
	$link_env
(
t_env
 **
head
, t_env *
last
)

84 
t_env
 *
ptr
;

86 if (!
last
)

88 
ptr
 = *
head
;

89 while (
ptr
)

91 if (!
ptr
->
next
)

93 
ptr
 = ptr->
next
;

95 
ptr
->
next
 = 
last
;

97 
	}
}

106 
t_env
 *
	$get_envp
(char **
envp
)

108 
t_env
 **
head
;

109 
t_env
 *
env
;

110 int 
i
;

112 
i
 = 0;

113 
head
 = 
NULL
;

114 if (!
envp
)

115 return (
NULL
);

116 
env
 = 
	`new_env
(
envp
[
i
]);

117 if (!
env
)

118 return (
NULL
);

119 
head
 = &
env
;

120 
i
++;

121 while (
envp
[
i
])

123 if (
	`link_env
(
head
, 
	`new_env
(
envp
[
i
])) < 0)

124 return (
	`free_env
(
head
), 
NULL
);

125 
i
++;

127 return (*
head
);

128 
	}
}

	@environnement/get_env.c

12 #include 
	~"minishell.h
"

14 char *
	$get_env_var_value
(char *
var_name
)

16 
t_env
 *
env
;

18 
env
 = 
g_shell
->env;

19 while (
env
 != 
NULL
)

21 if (
	`ft_strncmp
(
env
->
var_name
, var_name, 
	`ft_strlen
(var_name)) == 0)

22 return (
env
->
var_value
);

23 
env
 = env->
next
;

25 return (
NULL
);

26 
	}
}

	@environnement/pipex_helper.c

	@execution/copy_env_tab.c

12 #include 
	~"minishell.h
"

14 int 
	$column_size
(
t_env
 **
head
)

16 
t_env
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

29 char *
	$joined_malloc
(int 
len_name
, int 
len_value
)

31 char *
joined_1
;

33 
joined_1
 = 
	`malloc
(sizeof(char) * (
len_name
 + 
len_value
 + 2));

34 if (!
joined_1
)

36 
	`malloc_error_print_message
(
	`strerror
(
errno
));

37 return (
NULL
);

39 return (
joined_1
);

40 
	}
}

42 char *
	$name_plus_value
(char *
name
, char *
value
)

44 char *
joined
;

45 int 
len_name
;

46 int 
len_value
;

47 int 
i
;

48 int 
j
;

50 
i
 = 0;

51 
j
 = 0;

52 
len_name
 = 
	`ft_strlen
(
name
);

53 
len_value
 = 0;

54 if (
value
)

55 
len_value
 = 
	`ft_strlen
(
value
);

56 
joined
 = 
	`joined_malloc
(
len_name
, 
len_value
);

57 while (
i
 < 
len_name
)

58 
joined
[
i
++] = 
name
[
j
++];

59 
joined
[
i
] = '=';

60 
j
 = 0;

61 
i
++;

62 while (
j
 < 
len_value
)

63 
joined
[
i
++] = 
value
[
j
++];

64 
joined
[
i
] = '\0';

65 return (
joined
);

66 
	}
}

68 int 
	$copy_env_tab
(void)

70 int 
column
;

71 int 
i
;

72 
t_env
 *
env
;

74 
env
 = 
g_shell
->env;

75 
i
 = 0;

76 
column
 = 
	`column_size
(&
env
);

77 if (
column
 == 0)

79 
g_shell
->
save_env
 = 
	`malloc
(sizeof(char *) * (
column
 + 1));

80 if (!
g_shell
->
save_env
)

82 
	`malloc_error_print_message
(
	`strerror
(
errno
));

85 while (
env
)

87 
g_shell
->
save_env
[
i
] = 
	`name_plus_value
(
env
->
var_name
, env->
var_value
);

88 if (!
g_shell
->
save_env
[
i
])

90 
i
++;

91 
env
 = env->
next
;

93 
g_shell
->
save_env
[
i
] = 
NULL
;

95 
	}
}

	@execution/exec_bin.c

12 #include 
	~"minishell.h
"

14 static int 
	$check_access
(
t_cmd
 *
cmd
)

16 int 
res
;

18 if (!
cmd
->
path
)

20 
	`ft_dprintf
(2, "minishell: %s: command not found\n", 
cmd
->cmd[0]);

21 
g_shell
->
exit_status
 = 127;

24 
res
 = 
	`access
(
cmd
->
path
, 
F_OK
 & 
X_OK
);

25 if (
res
)

27 
	`ft_dprintf
(2, "minishell: %s\n", 
	`strerror
(
errno
));

28 
g_shell
->
exit_status
 = 127;

32 
	}
}

34 static void 
	$check_execve
(
t_cmd
 *
cmd
)

36 if (!
cmd
->cmd)

38 
	`ft_dprintf
(2, "minishell: %s: is a directory\n", 
cmd
->
path
);

39 
g_shell
->
exit_status
 = 126;

42 
cmd
->
res
 = 
	`execve
(cmd->
path
, cmd->cmd, 
g_shell
->
save_env
);

43 if (
cmd
->
res
 < 0)

45 if (
errno
 == 
ENOEXEC
)

47 
	`ft_dprintf
(2, "minishell: %s: Permission denied\n", 
cmd
->
path
);

48 
g_shell
->
exit_status
 = 126;

51 
	`ft_dprintf
(2, "minishell: %s: %s\n", 
cmd
->
path
, 
	`strerror
(
errno
));

52 if (
errno
 == 
EACCES
)

54 
g_shell
->
exit_status
 = 126;

57 
g_shell
->
exit_status
 = 127;

60 
g_shell
->
exit_status
 = 0;

61 
	}
}

63 void 
	$execute_bin
(
t_cmd
 *
cmd
)

65 int 
res
;

67 
res
 = 0;

68 if (!
cmd
 || !cmd->cmd)

70 if (!
	`get_path
(
cmd
))

72 
res
 = 
	`check_access
(
cmd
);

73 if (
res
)

74 
	`check_execve
(
cmd
);

75 if (
cmd
->
path
)

76 
	`free
(
cmd
->
path
);

77 if (
cmd
->cmd)

78 
	`free_tab2d
(
cmd
->cmd);

80 
	}
}

	@execution/exec_builtins.c

12 #include 
	~"minishell.h
"

14 int 
	$cmd_is_builtin
(char *
s
)

16 if (
s
)

18 if (
	`ft_strncmp
(
s
, "echo", 5) == 0)

20 else if (
	`ft_strncmp
(
s
, "cd", 3) == 0)

22 else if (
	`ft_strncmp
(
s
, "pwd", 4) == 0)

24 else if (
	`ft_strncmp
(
s
, "export", 7) == 0)

26 else if (
	`ft_strncmp
(
s
, "unset", 6) == 0)

28 else if (
	`ft_strncmp
(
s
, "env", 4) == 0)

30 else if (
	`ft_strncmp
(
s
, "exit", 5) == 0)

34 
	}
}

36 void 
	$execute_builtin
(
t_cmd
 *
cmd
)

38 if (
	`ft_strncmp
(
cmd
->cmd[0], "exit", 6) == 0)

39 
	`ft_exit
(
cmd
);

40 else if (
	`ft_strncmp
(
cmd
->cmd[0], "pwd", 4) == 0)

41 
	`_pwd
();

42 else if (
	`ft_strncmp
(
cmd
->cmd[0], "echo", 5) == 0)

43 
	`_echo
(
cmd
);

44 else if (
	`ft_strncmp
(
cmd
->cmd[0], "env", 4) == 0)

45 
	`_env
(
cmd
, 
g_shell
->
env
);

46 else if (
	`ft_strncmp
(
cmd
->cmd[0], "cd", 3) == 0)

47 
	`_cd
(
cmd
);

48 else if (
	`ft_strncmp
(
cmd
->cmd[0], "export", 7) == 0)

49 
	`_export
(
cmd
);

50 else if (
	`ft_strncmp
(
cmd
->cmd[0], "unset", 6) == 0)

51 
	`_unset
(
cmd
);

53 
	}
}

	@execution/exec_one_cmd.c

12 #include 
	~"minishell.h
"

14 static void 
	$print_signal_message
(int 
sig_code
)

16 if (
sig_code
 == 
SIGTERM
)

18 
g_shell
->
terminated
++;

19 
	`ft_printf
("[%d]\t Terminated: 15\n", 
g_shell
->
terminated
);

21 else if (
sig_code
 == 
SIGQUIT
)

22 
	`ft_printf
("QUIT: 3\n");

23 else if (
sig_code
 == 
SIGINT
)

24 
	`ft_printf
("\n");

25 else if (
sig_code
 == 
SIGKILL
)

26 
	`ft_printf
("Killed: 9 \n");

27 
	}
}

29 static void 
	$execute_one_bin
(
t_cmd
 *
cmd
)

31 
cmd
->
pid
 = 
	`fork
();

32 if (
cmd
->
pid
 < 0)

33 return (
	`perror
("minishell: fork: "));

34 if (
cmd
->
pid
 == 0)

36 
	`child_signal_handler
();

37 
	`execute_bin
(
cmd
);

38 
cmd
->
status
 = 
g_shell
->
exit_status
;

39 
	`exit
(
g_shell
->
exit_status
);

43 
	`signal
(
SIGINT
, 
SIG_IGN
);

44 
	`waitpid
(
cmd
->
pid
, &cmd->
status
, 0);

45 if (
	`WIFSIGNALED
(
cmd
->
status
))

47 
	`print_signal_message
(
	`WTERMSIG
(
cmd
->
status
));

48 
g_shell
->
exit_status
 = 
	`WTERMSIG
(
cmd
->
status
) + 128;

50 else if (
	`WIFEXITED
(
cmd
->
status
))

51 
g_shell
->
exit_status
 = 
	`WEXITSTATUS
(
cmd
->
status
);

53 
	}
}

55 void 
	$one_cmd
(
t_cmd
 *
cmd
)

57 int 
res
;

59 
res
 = 
	`make_redirections
(
cmd
, 0);

60 if (!
res
 || !
cmd
->cmd)

62 
	`restaure_fds
(
cmd
, 0);

65 if (
	`cmd_is_builtin
(
cmd
->cmd[0]))

66 
	`execute_builtin
(
cmd
);

68 
	`execute_one_bin
(
cmd
);

69 
	`restaure_fds
(
cmd
, 0);

70 
	}
}

	@execution/execution.c

12 #include 
	~"minishell.h
"

14 static int 
	$count_nb_cmds
(
t_cmd
 **
head
)

16 
t_cmd
 *
cmd
;

17 int 
i
;

19 
i
 = 0;

20 
cmd
 = *
head
;

21 while (
cmd
)

23 
i
++;

24 
cmd
 = cmd->
next
;

26 return (
i
);

27 
	}
}

29 static int 
	$reset_env_tab
(void)

31 if (
g_shell
->
save_env
)

33 
	`free_tab2d
(
g_shell
->
save_env
);

34 
g_shell
->
save_env
 = 
NULL
;

36 if (!
	`copy_env_tab
())

39 
	}
}

41 void 
	$execution
(
t_cmd
 **
head
)

43 int 
nb_cmds
;

45 if (!
head
 || !*head)

47 
nb_cmds
 = 
	`count_nb_cmds
(
head
);

48 if (!
	`reset_env_tab
())

50 if (
nb_cmds
 == 1)

51 
	`one_cmd
(*
head
);

53 
	`pipex
(
head
);

54 
	}
}

	@execution/get_path.c

12 #include 
	~"minishell.h
"

14 static int 
	$is_dir
(char *
path
, 
t_cmd
 *
cmd
)

16 struct 
stat
 
buf
;

18 if (
	`stat
(
path
, &
buf
) == 0)

20 if (
	`S_ISDIR
(
buf
.
st_mode
))

22 
	`free_tab2d
(
cmd
->cmd);

23 
cmd
->cmd = 
NULL
;

28 
	}
}

30 static int 
	$extract_cmd_path
(char *
path
, 
t_cmd
 *
cmd
)

32 int 
start
;

33 int 
end
;

35 
start
 = 0;

36 
end
 = 0;

37 if (
	`is_dir
(
path
, 
cmd
))

39 while (
path
[
end
])

40 
end
++;

41 
start
 = 
end
--;

42 while (
path
[
start
] != '/')

43 
start
--;

44 
	`free
(
cmd
->cmd[0]);

45 
cmd
->cmd[0] = 
NULL
;

46 
cmd
->cmd[0] = 
	`ft_substr
(
path
, 
start
 + 1, 
end
 - start);

47 if (!
cmd
->cmd[0])

49 
	`malloc_error_print_message
("ft_substr failed");

53 
	}
}

55 int 
	$get_path
(
t_cmd
 *
cmd
)

57 if (
	`ft_strchr
(
cmd
->cmd[0], '/'))

59 
cmd
->
path
 = 
	`ft_strdup
(cmd->cmd[0]);

60 if (!
cmd
->
path
)

62 
	`malloc_error_print_message
("ft_strdup failed");

65 if (!
	`extract_cmd_path
(
cmd
->
path
, cmd))

69 if (!
	`search_path
(
cmd
, 
g_shell
->
save_env
))

72 
	}
}

	@execution/pipex.c

12 #include 
	~"minishell.h
"

14 static void 
	$print_signal_message
(int 
sig_code
, int *
flag
)

16 if (
sig_code
 == 
SIGTERM
)

18 
g_shell
->
terminated
++;

19 
	`ft_printf
("[%d]\t Terminated: 15\n", 
g_shell
->
terminated
);

21 else if (
sig_code
 == 
SIGQUIT
)

22 
	`ft_printf
("Quit: 3\n");

23 else if (
sig_code
 == 
SIGINT
)

25 *
flag
 = 1;

26 
	`ft_printf
("\n");

28 else if (
sig_code
 == 
SIGKILL
)

29 
	`ft_printf
("Killed: 9 \n");

30 
	}
}

32 static void 
	$kill_zombies
(
t_cmd
 **
head
, int 
flag
)

34 
t_cmd
 *
cmd
;

35 int 
res
;

37 
cmd
 = *
head
;

38 while (
cmd
)

40 
res
 = 
	`waitpid
(
cmd
->
pid
, &cmd->
status
, 0);

41 if (
res
 >= 0 && 
	`WIFSIGNALED
(
cmd
->
status
) && \

42 
	`WTERMSIG
(
cmd
->
status
) == 
SIGINT
)

44 if (
flag
 == 0)

45 
	`ft_printf
("\n");

47 
cmd
 = cmd->
next
;

49 
	}
}

51 static void 
	$pipex_get_exit_status
(
t_cmd
 *
cmd
, t_cmd **
head
)

53 
t_cmd
 *
last
;

54 int 
flag
;

56 
cmd
 = *
head
;

57 
flag
 = 0;

58 while (
cmd
)

60 
	`waitpid
(
cmd
->
pid
, &cmd->
status
, 0);

61 
last
 = 
cmd
;

62 
cmd
 = cmd->
next
;

64 if (
	`WIFEXITED
(
last
->
status
))

65 
g_shell
->
exit_status
 = 
	`WEXITSTATUS
(
last
->
status
);

66 else if (
	`WIFSIGNALED
(
last
->
status
))

68 
	`print_signal_message
(
	`WTERMSIG
(
last
->
status
), &
flag
);

69 if (
	`WTERMSIG
(
last
->
status
) == 
SIGINT
)

70 
g_shell
->
exit_status
 = 
	`WTERMSIG
(
last
->
status
) + 128;

72 
	`kill_zombies
(
head
, 
flag
);

73 
	}
}

75 static void 
	$pipex_helper
(int 
fd_pipe
[2], 
t_cmd
 *
cmd
, int 
i
, int *
save_fdin
)

77 if (
cmd
->
pid
 == 0)

79 if (
cmd
->
next
 != 
NULL
)

80 
	`dup2
(
fd_pipe
[1], 
STDOUT_FILENO
);

81 
	`close
(
fd_pipe
[0]);

82 
	`close
(
fd_pipe
[1]);

83 
	`ft_exe
(
i
, *
save_fdin
, 
cmd
);

84 
	`exit
(
g_shell
->
exit_status
);

88 
	`close
(
fd_pipe
[1]);

89 
	`close
(*
save_fdin
);

90 *
save_fdin
 = 
fd_pipe
[0];

92 
	}
}

94 void 
	$pipex
(
t_cmd
 **
head
)

96 int 
fd_pipe
[2];

97 int 
save_fdin
;

98 
t_cmd
 *
cmd
;

99 int 
i
;

101 
i
 = 0;

102 if (!
head
 || !*head)

104 
cmd
 = *
head
;

105 while (
cmd
)

107 
	`pipe
(
fd_pipe
);

108 
cmd
->
pid
 = 
	`fork
();

109 
	`pipex_signal_handler
();

110 
	`pipex_helper
(
fd_pipe
, 
cmd
, 
i
, &
save_fdin
);

111 
cmd
 = cmd->
next
;

112 
i
++;

114 
	`pipex_get_exit_status
(
cmd
, 
head
);

115 
	`close
(
save_fdin
);

116 
	}
}

	@execution/pipex_helper.c

12 #include 
	~"minishell.h
"

14 static int 
	$check_fdin_redir
(
t_cmd
 *
cmd
)

16 int 
i
;

17 int 
flag
;

19 
flag
 = 0;

20 
i
 = 0;

21 if (!
cmd
->
redir
)

22 return (
flag
);

23 while (
cmd
->
redir
[
i
])

25 if (
	`ft_strncmp
(
cmd
->
redir
[
i
], "<<", 3) == 0 || \

26 
	`ft_strncmp
(
cmd
->
redir
[
i
], "<", 2) == 0)

28 
flag
 = 1;

31 
i
++;

33 return (
flag
);

34 
	}
}

36 void 
	$ft_exe
(int 
i
, int 
save_fdin
, 
t_cmd
 *
cmd
)

38 int 
res
;

40 if (
i
 != 0 && !
	`check_fdin_redir
(
cmd
))

42 
	`dup2
(
save_fdin
, 
STDIN_FILENO
);

43 
	`close
(
save_fdin
);

45 
res
 = 
	`make_redirections
(
cmd
, 
i
);

46 if (!
res
 || !
cmd
->cmd)

48 
	`restaure_fds
(
cmd
, 
i
);

51 if (
	`cmd_is_builtin
(
cmd
->cmd[0]))

52 
	`execute_builtin
(
cmd
);

54 
	`execute_bin
(
cmd
);

55 
	`restaure_fds
(
cmd
, 
i
);

57 
	}
}

	@execution/search_path_in_env_table.c

12 #include 
	~"minishell.h
"

14 static void 
	$copy_path
(int 
start
, int 
end
, char *
s
, 
t_cmd
 *
cmd
)

16 int 
i
;

18 
i
 = 0;

19 while (
start
 < 
end
)

21 
cmd
->
path
[
i
] = 
s
[
start
];

22 
i
++;

23 
start
++;

25 
cmd
->
path
[
i
] = '/';

26 
i
++;

27 
start
 = 0;

28 while (
cmd
->cmd[0][
start
])

30 
cmd
->
path
[
i
] = cmd->cmd[0][
start
];

31 
i
++;

32 
start
++;

34 
cmd
->
path
[
i
] = '\0';

35 
	}
}

37 static int 
	$check_access
(int 
start
, int 
end
, char *
s
, 
t_cmd
 *
cmd
)

39 int 
size
;

41 
size
 = 
end
 - 
start
 + 
	`ft_strlen
(
cmd
->cmd[0]) + 2;

42 
cmd
->
path
 = 
	`malloc
(sizeof(char) * 
size
);

43 if (!
cmd
->
path
)

45 
	`malloc_error_print_message
("ft_substr failed");

46 
g_shell
->
exit_status
 = 1;

47 return (
ERROR_EXIT
);

49 
	`copy_path
(
start
, 
end
, 
s
, 
cmd
);

50 if (
	`access
(
cmd
->
path
, 
F_OK
 & 
X_OK
) == 0)

52 
	`free
(
cmd
->
path
);

53 
cmd
->
path
 = 
NULL
;

55 
	}
}

57 static int 
	$check_each_path
(char *
s
, 
t_cmd
 *
cmd
)

59 int 
i
;

60 int 
start
;

61 int 
res
;

63 
i
 = 0;

64 
start
 = 0;

65 while (
s
[
i
])

67 if (
s
[
i
] == ':')

69 
res
 = 
	`check_access
(
start
, 
i
, 
s
, 
cmd
);

70 if (
res
 == 1)

72 else if (
res
 == 
ERROR_EXIT
)

74 
start
 = 
i
 + 1;

76 
i
++;

78 
res
 = 
	`check_access
(
start
, 
i
, 
s
, 
cmd
);

79 if (
res
 == 1 || res == 0)

82 
	}
}

84 int 
	$search_path
(
t_cmd
 *
cmd
, char **
env
)

86 int 
i
;

87 int 
res
;

89 
i
 = 0;

90 while (
env
[
i
] && 
	`ft_strncmp
("PATH=", env[i], 5) != 0)

91 
i
++;

92 if (!
env
[
i
])

94 
	`ft_dprintf
(2, "minishell: %s: No such file or directory\n", 
cmd
->cmd[0]);

95 
g_shell
->
exit_status
 = 127;

98 if (
cmd
->cmd[0][0] == 0)

100 
res
 = 
	`check_each_path
((
env
[
i
] + 5), 
cmd
);

101 return (
res
);

102 
	}
}

	@global_variable/init_global.c

12 #include 
	~"minishell.h
"

15 void 
	$free_shell
(void)

17 
	`free_env
(&
g_shell
->
env
);

18 if (
g_shell
->
save_env
)

19 
	`free_tab2d
(
g_shell
->
save_env
);

20 if (
g_shell
)

21 
	`free
(
g_shell
);

22 
	}
}

24 static int 
	$shell_no_env
(void)

26 
t_env
 *
env_no
;

28 
env_no
 = 
	`malloc
(sizeof(
t_env
));

29 if (!
env_no
)

31 
	`malloc_error_print_message
(
	`strerror
(
errno
));

34 
env_no
->
var_name
 = 
	`ft_strdup
("SHLVL");

35 
env_no
->
var_value
 = 
	`ft_strdup
("1");

36 
env_no
->
next
 = 
NULL
;

37 
g_shell
->
env
 = 
env_no
;

39 
	}
}

41 static int 
	$increment_shlvl
(void)

43 
t_env
 *
env
;

44 int 
i
;

46 
env
 = 
g_shell
->env;

47 while (
env
)

49 if (
	`ft_strncmp
(
env
->
var_name
, "SHLVL", 6) == 0)

51 if (!
	`is_numeric
(
env
->
var_value
))

53 
i
 = 
	`ft_atoi
(
env
->
var_value
) + 1;

54 
	`free
(
env
->
var_value
);

55 
env
->
var_value
 = 
NULL
;

56 
env
->
var_value
 = 
	`ft_itoa
(
i
);

57 if (!
env
->
var_value
)

59 
	`malloc_error_print_message
("ft_itoa failed");

64 
env
 = env->
next
;

67 
	}
}

69 void 
	$reset_oldpwd
(void)

71 
t_env
 *
env
;

73 
env
 = 
g_shell
->env;

74 while (
env
)

76 if (
	`ft_strncmp
(
env
->
var_name
, "OLDPWD", 7) == 0)

78 
	`free
(
env
->
var_value
);

79 
env
->
var_value
 = 
NULL
;

82 
env
 = env->
next
;

84 
	}
}

86 int 
	$init_shell
(char **
envp
)

88 
g_shell
 = 
	`ft_calloc
(1, sizeof(
t_shell
));

89 if (!
g_shell
)

91 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

94 if (!*
envp
)

96 if (!
	`shell_no_env
())

101 
g_shell
->
env
 = 
	`get_envp
(
envp
);

102 if (!
g_shell
->
env
)

103 return (
	`free_shell
(), 0);

104 if (!
	`increment_shlvl
())

105 return (
	`free_shell
(), 0);

106 
	`reset_oldpwd
();

109 
	}
}

	@is_smth/is_dollar.c

12 #include 
	~"minishell.h
"

16 int 
	$is_dollar
(char 
c
)

18 if (
c
 == '$')

21 
	}
}

	@is_smth/is_numeric.c

12 #include 
	~"minishell.h
"

14 int 
	$is_numeric
(char *
s
)

16 int 
i
;

18 
i
 = 0;

19 while (
s
[
i
])

21 if (
	`ft_isdigit
(
s
[
i
]) == 0)

23 
i
++;

26 
	}
}

	@is_smth/is_operator.c

12 #include 
	~"minishell.h
"

16 int 
	$is_pipeline
(char 
c
)

18 if (
c
 == '|')

21 
	}
}

25 int 
	$is_lchevron
(char 
c
)

27 if (
c
 == '<')

30 
	}
}

32 int 
	$is_rchevron
(char 
c
)

34 if (
c
 == '>')

37 
	}
}

39 int 
	$is_chevron
(char 
c
)

41 if (
	`is_lchevron
(
c
) || 
	`is_rchevron
(c))

44 
	}
}

48 int 
	$is_operator
(char 
c
)

50 if (
	`is_pipeline
(
c
) || 
	`is_chevron
(c))

53 
	}
}

	@is_smth/is_question.c

12 #include 
	~"minishell.h
"

14 int 
	$is_question
(char 
c
)

16 if (
c
 == '?')

19 
	}
}

21 int 
	$is_punct
(char 
c
)

23 if ((
c
 >= 33 && c <= 47) || \

24 (
c
 >= 58 && c <= 64) || \

25 (
c
 >= 91 && c <= 94) || \

26 (
c
 == 96) || \

27 (
c
 >= 123 && c <= 126))

30 
	}
}

	@is_smth/is_quote.c

12 #include 
	~"minishell.h
"

16 int 
	$is_double_quote
(char 
c
)

18 if (
c
 == '\"')

21 
	}
}

23 int 
	$is_simple_quote
(char 
c
)

25 if (
c
 == '\'')

28 
	}
}

30 int 
	$is_quote
(char 
c
)

32 if (
	`is_double_quote
(
c
) || 
	`is_simple_quote
(c))

35 
	}
}

	@is_smth/is_token.c

12 #include 
	~"minishell.h
"

16 int 
	$is_metacharacter
(char 
c
)

18 if (
	`is_blank
(
c
) || 
	`is_newline
(c) || 
	`is_operator
(c))

21 
	}
}

25 int 
	$is_delimiter
(char 
c
)

27 if (
	`is_metacharacter
(
c
))

30 
	}
}

34 int 
	$is_word
(char 
c
)

36 if (!
	`is_delimiter
(
c
))

39 
	}
}

	@is_smth/is_white_space.c

12 #include 
	~"minishell.h
"

14 int 
	$is_blank
(char 
c
)

16 if (
c
 == ' ' || c == '\t')

19 
	}
}

21 int 
	$is_newline
(char 
c
)

23 if (
c
 == '\n')

26 
	}
}

28 int 
	$is_white_space
(char 
c
)

30 if (
	`is_blank
(
c
) || 
	`is_newline
(c))

33 
	}
}

	@libft/ft_printf/ft_count_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_int
(int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

	@libft/ft_printf/ft_count_unsigned_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_unsigned_int
(unsigned int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 else if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 return (
count
);

30 
	}
}

	@libft/ft_printf/ft_dprintf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 
fd
, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 
fd
, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 
fd
, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 
fd
, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 
fd
, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_dprintf
(int 
fd
, const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 
fd
, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 
fd
, &
count
);

50 
	`ft_format_specifier_fd
(
last
[
i
 + 1], 
ap
, &
count
, 
fd
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@libft/ft_printf/ft_printf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier
(char 
format
, 
va_list
 
ap
, int *
count
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 1, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 1, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 1, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 1, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 1, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 1, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 1, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_printf
(const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 1, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 1, &
count
);

50 
	`ft_format_specifier
(
last
[
i
 + 1], 
ap
, &
count
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@libft/ft_printf/ft_printf_address.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
);

16 void 
	$ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
)

18 
	`ft_printf_str
("0x", 
fd
, 
count
);

19 
	`ft_put_uintptr_fd
(
n
, 
fd
, 
count
);

20 
	}
}

22 void 
	$ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
)

24 if (
n
 > 15)

26 
	`ft_put_uintptr_fd
(
n
 / 16, 
fd
, 
count
);

27 
	`ft_put_uintptr_fd
(
n
 % 16, 
fd
, 
count
);

29 if (
n
 < 10)

30 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

31 else if (
n
 > 9 && n < 16)

32 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

33 
	}
}

	@libft/ft_printf/ft_printf_char.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_char
(char 
c
, int 
fd
, int *
count
)

16 
	`ft_putchar_fd
(
c
, 
fd
);

17 *
count
 += 1;

18 
	}
}

	@libft/ft_printf/ft_printf_hexa.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
)

16 if (
n
 > 15)

18 
	`ft_printf_hexa
(
n
 / 16, 
fd
, 
count
, 
c
);

19 
	`ft_printf_hexa
(
n
 % 16, 
fd
, 
count
, 
c
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

25 if (
c
 == 'x')

26 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

27 else if (
c
 == 'X')

28 
	`ft_printf_char
(
n
 + 55, 
fd
, 
count
);

30 
	}
}

	@libft/ft_printf/ft_printf_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_int
(int 
n
, int 
fd
, int *
count
)

16 
	`ft_putnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_int
(
n
);

18 
	}
}

	@libft/ft_printf/ft_printf_str.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_str
(char *
s
, int 
fd
, int *
count
)

16 int 
i
;

18 
i
 = 0;

19 if (
s
 != 
NULL
)

21 while (
s
[
i
] != '\0')

22 
i
++;

23 
	`ft_putstr_fd
(
s
, 
fd
);

27 
	`ft_putstr_fd
("(null)", 1);

28 
i
 = 6;

30 *
count
 += 
i
;

31 
	}
}

	@libft/ft_printf/ft_printf_unsint.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
)

16 
	`ft_put_unsnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_unsigned_int
(
n
);

18 
	}
}

	@libft/ft_printf/ft_put_hexanbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_hexanbr_fd
(unsigned int 
n
, int 
fd
, int *
count
)

16 if (
n
 > 15)

18 
	`ft_put_hexanbr_fd
(
n
 / 16, 
fd
, 
count
);

19 
	`ft_put_hexanbr_fd
(
n
 % 16, 
fd
, 
count
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

24 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

25 
	}
}

	@libft/ft_printf/ft_put_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_put_int
(int 
n
, int 
fd
, int *
count
)

16 int 
a
;

18 
a
 = *
count
;

19 
	`ft_putnbr_fd
(
n
, 
fd
);

20 
a
 += 
	`ft_count_int
(
n
);

21 return (
a
);

22 
	}
}

	@libft/ft_printf/ft_put_unsnbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
)

16 if (
n
 > 9)

18 
	`ft_put_unsnbr_fd
(
n
 / 10, 
fd
);

19 
	`ft_put_unsnbr_fd
((
n
 % 10), 
fd
);

22 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

23 
	}
}

	@libft/get_next_line/get_next_line.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$create_nextline
(char *
result
, char *
line
)

16 int 
start
;

17 int 
size
;

18 char *
nextline
;

20 
start
 = 
	`ft_strlen_int
(
result
);

21 
size
 = 
	`ft_strlen_int
(
line
);

22 
size
 = size - 
start
;

23 if (
size
 == 0)

25 
	`free
 (
line
);

26 return (
NULL
);

28 
nextline
 = 
	`malloc
((
size
 + 1) * sizeof(char));

29 if (!
nextline
)

30 return (
NULL
);

31 
size
 = 0;

32 while (
line
[
start
] != '\0')

34 
nextline
[
size
] = 
line
[
start
];

35 
size
++;

36 
start
++;

38 
nextline
[
size
] = '\0';

39 
	`free
(
line
);

40 return (
nextline
);

41 
	}
}

55 char *
	$create_result
(char *
line
)

57 int 
i
;

58 char *
result
;

60 
i
 = 
	`there_is_n
(
line
);

61 if (
i
 == -1 && *
line
)

62 
i
 = 
	`ft_strlen_int
(
line
);

63 else if (
i
 == -1 && !*
line
)

64 return (
NULL
);

65 
result
 = 
	`malloc
((
i
 + 1) * sizeof(char));

66 if (!
result
)

67 return (
NULL
);

68 
i
 = 0;

69 while (
line
[
i
] != '\0')

71 
result
[
i
] = 
line
[i];

72 if (
line
[
i
] == '\n')

74 
i
++;

77 
i
++;

79 
result
[
i
] = '\0';

80 return (
result
);

81 
	}
}

94 char *
	$read_fd
(char *
line
, int 
fd
, int *
error
)

96 char *
buffer
;

97 int 
ret
;

99 
ret
 = 1;

100 
	`prepare_forstash
(&
line
, &
buffer
);

101 while (
ret
 > 0 && 
	`there_is_n
(
buffer
) == -1 && there_is_n(
line
) == -1)

103 
ret
 = (int)
	`read
(
fd
, 
buffer
, 
BUFFER_SIZE
);

104 if (
ret
 < 0)

106 
	`free
(
buffer
);

107 *
error
 = -1;

108 return (
NULL
);

110 if (
ret
 == 0)

112 *
error
 = 0;

115 
buffer
[
ret
] = '\0';

116 
line
 = 
	`ft_join
(line, 
buffer
);

118 
	`free
(
buffer
);

119 return (
line
);

120 
	}
}

130 int 
	$check_errors
(int 
fd
, char **
line
)

132 if (
fd
 < 0 || 
BUFFER_SIZE
 <= 0 || 
	`read
(fd, 0, 0) < 0)

134 
	`free
(*
line
);

135 *
line
 = 0;

139 
	}
}

150 char *
	$get_next_line
(int 
fd
)

152 static char *
line
;

153 char *
result
;

154 int 
error
;

156 
error
 = 
	`check_errors
(
fd
, &
line
);

157 if (
error
 == 0)

158 return (
NULL
);

159 
line
 = 
	`read_fd
(line, 
fd
, &
error
);

160 if (
error
 == -1 || (error == 0 && !*
line
))

162 
	`free
(
line
);

163 
line
 = 0;

164 return (
NULL
);

166 if (!
line
)

167 return (
NULL
);

168 
result
 = 
	`create_result
(
line
);

169 if (!
result
)

171 
line
 = 0;

172 
	`free
(
line
);

174 
line
 = 
	`create_nextline
(
result
, line);

175 return (
result
);

176 
	}
}

	@libft/get_next_line/get_next_line_bonus.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$get_next_line_maxopen
(int 
fd
)

16 static char *
line
[
OPEN_MAX
];

17 char *
result
;

18 int 
error
;

20 
error
 = 
	`check_errors
(
fd
, &
line
[fd]);

21 if (
error
 == 0)

22 return (
NULL
);

23 
line
[
fd
] = 
	`read_fd
(line[fd], fd, &
error
);

24 if (
error
 == -1 || (error == 0 && !*
line
[
fd
]))

26 
	`free
(
line
[
fd
]);

27 
line
[
fd
] = 0;

28 return (
NULL
);

30 if (!
line
[
fd
])

31 return (
NULL
);

32 
result
 = 
	`create_result
(
line
[
fd
]);

33 if (!
result
)

35 
line
[
fd
] = 0;

36 
	`free
(
line
[
fd
]);

38 
line
[
fd
] = 
	`create_nextline
(
result
, line[fd]);

39 return (
result
);

40 
	}
}

	@libft/get_next_line/get_next_line_utils.c

12 #include 
	~"../includes/get_next_line.h
"

14 void 
	$prepare_forstash
(char **
line
, char **
buffer
)

16 *
buffer
 = 
	`ft_calloc_count
(
BUFFER_SIZE
);

17 if (*
line
 == 
NULL
)

18 *
line
 = 
	`ft_calloc_count
(0);

19 
	}
}

21 char *
	$ft_join
(char *
line
, char *
buffer
)

23 int 
i
;

24 int 
j
;

25 char *
stash
;

27 if (!
line
 || !
buffer
)

28 return (
NULL
);

29 
i
 = 
	`ft_strlen_int
(
line
);

30 
j
 = 
	`ft_strlen_int
(
buffer
);

31 
stash
 = 
	`malloc
((
i
 + 
j
 + 1) * sizeof(char));

32 if (!
stash
)

33 return (
NULL
);

34 
i
 = 0;

35 
j
 = 0;

36 while (
line
[
i
] != '\0')

38 
stash
[
i
] = 
line
[i];

39 
i
++;

41 while (
buffer
[
j
] != '\0')

42 
stash
[
i
++] = 
buffer
[
j
++];

43 
stash
[
i
] = '\0';

44 
	`free
(
line
);

45 return (
stash
);

46 
	}
}

48 char *
	$ft_calloc_count
(int 
count
)

50 char *
string
;

51 int 
i
;

53 
i
 = 0;

54 
string
 = 
	`malloc
((
count
 + 1) * sizeof(char));

55 if (!
string
)

56 return (
NULL
);

57 while (
i
 <= 
count
)

59 
string
[
i
] = '\0';

60 
i
++;

62 return (
string
);

63 
	}
}

65 int 
	$ft_strlen_int
(const char *
string
)

67 int 
i
;

69 
i
 = 0;

70 while (
string
[
i
] != '\0')

71 
i
++;

72 return (
i
);

73 
	}
}

75 int 
	$there_is_n
(char *
line
)

77 int 
i
;

79 
i
 = 0;

80 while (
line
[
i
] != '\0')

82 if (
line
[
i
] == '\n')

83 return (
i
 + 1);

84 
i
++;

87 
	}
}

	@libft/includes/ft_printf.h

12 #ifndef 
FT_PRINTF_H


13 #define 
	#FT_PRINTF_H


	)

15 #include 
	~"libft.h
"

16 #include 
	~<stdarg.h
>

18 int 
ft_printf
(const char *
last
, ...);

19 void 
ft_printf_char
(char 
c
, int 
fd
, int *
count
);

20 void 
ft_printf_str
(char *
s
, int 
fd
, int *
count
);

21 void 
ft_printf_int
(int 
n
, int 
fd
, int *
count
);

22 int 
ft_count_int
(int 
n
);

23 void 
ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
);

24 void 
ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
);

25 int 
ft_count_unsigned_int
(unsigned int 
n
);

26 void 
ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
);

27 void 
ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
);

31 void 
ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
);

32 int 
ft_dprintf
(int 
fd
, const char *
last
, ...);

	@libft/includes/get_next_line.h

12 #ifndef 
GET_NEXT_LINE_H


13 #define 
	#GET_NEXT_LINE_H


	)

15 #include 
	~<unistd.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<limits.h
>

19 #ifndef 
BUFFER_SIZE


20 #define 
	#BUFFER_SIZE
 42

	)

23 char *
ft_calloc_count
(int 
count
);

24 int 
ft_strlen_int
(const char *
string
);

25 char *
ft_join
(char *
nextline
, char *
buffer
);

26 int 
there_is_n
(char *
line
);

27 char *
read_fd
(char *
nextline
, int 
fd
, int *
error
);

28 char *
create_result
(char *
line
);

29 char *
create_nextline
(char *
result
, char *
line
);

30 char *
get_next_line
(int 
fd
);

31 char *
get_next_line_maxopen
(int 
fd
);

32 int 
check_errors
(int 
fd
, char **
line
);

33 void 
prepare_forstash
(char **
line
, char **
buffer
);

	@libft/includes/libft.h

12 #ifndef 
LIBFT_H


13 #define 
	#LIBFT_H


	)

15 #include 
	~<stddef.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<unistd.h
>

18 #include 
	~"ft_printf.h
"

19 #include 
	~"get_next_line.h
"

21 typedef struct 
	ss_list


23 void *
	mcontent
;

24 struct 
s_list
 *
	mnext
;

25 } 
	tt_list
;

27 void *
ft_memset
(void *
b
, int 
c
, 
size_t
 
len
);

28 void 
ft_bzero
(void *
s
, 
size_t
 
n
);

29 void *
ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
);

30 void *
ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
);

31 void *
ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
);

32 int 
ft_isalpha
(int 
c
);

33 int 
ft_isdigit
(int 
c
);

34 int 
ft_isalnum
(int 
c
);

35 int 
ft_isascii
(int 
c
);

36 int 
ft_isprint
(int 
c
);

37 
size_t
 
ft_strlen
(const char *
s
);

38 int 
ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
);

39 char *
ft_strcpy
(char *
dst
, const char *
src
);

40 
size_t
 
ft_strlcpy
(char *
dst
, const char *
src
, size_t 
dstsize
);

41 
size_t
 
ft_strlcat
(char *
dst
, const char *
src
, size_t 
dstsize
);

42 char *
ft_strchr
(const char *
s
, int 
c
);

43 char *
ft_strrchr
(const char *
s
, int 
c
);

44 char *
ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
);

45 int 
ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
);

46 int 
ft_toupper
(int 
c
);

47 int 
ft_tolower
(int 
c
);

48 int 
ft_atoi
(const char *
str
);

49 void *
ft_calloc
(
size_t
 
count
, size_t 
size
);

50 char *
ft_strdup
(const char *
s1
);

51 char *
ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
);

52 char *
ft_strjoin
(char const *
s1
, char const *
s2
);

53 char *
ft_strtrim
(char const *
s1
, char const *
set
);

54 char **
ft_split
(char const *
s
, char 
c
);

55 char *
ft_itoa
(int 
n
);

56 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char));

57 void 
	`ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*));

58 void 
	`ft_putchar_fd
(char 
c
, int 
fd
);

59 void 
	`ft_putstr_fd
(char *
s
, int 
fd
);

60 void 
	`ft_putendl_fd
(char *
s
, int 
fd
);

61 void 
	`ft_putnbr_fd
(int 
n
, int 
fd
);

64 
t_list
 *
	`ft_lstnew
(void *
content
);

65 void 
	`ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
);

66 int 
	`ft_lstsize
(
t_list
 *
lst
);

67 
t_list
 *
	`ft_lstlast
(t_list *
lst
);

68 void 
	`ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
);

69 void 
	`ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*));

70 void 
	`ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*));

71 void 
	`ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *));

72 
t_list
 *
	`ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *));

73 void 
	`delete_first_el
(
t_list
 **
a
);

74 void 
	`delete_last_el
(
t_list
 **
a
);

75 void 
	`del
(void *
content
);

78 int 
	`power
(int 
str_base
, int 
power
);

79 int 
	`ft_atoi_base
(const char *
str
, int 
str_base
);

80 int 
	`transform
(char 
c
);

81 
size_t
 
	`ft_strcspn
(const char *
s
, const char *
reject
);

82 char *
	`ft_strpbrk
(const char *
s1
, const char *
s2
);

83 
size_t
 
	`ft_strspn
(const char *
s
, const char *
accept
);

84 char *
	`str_lowercase
(char *
str
);

	@libft/libft/del.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$del
(void *
content
)

16 if (
content
)

17 
	`free
(
content
);

18 
	}
}

	@libft/libft/ft_atoi.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_atoi
(const char *
str
)

16 int 
i
;

17 int 
result
;

18 int 
sign
;

20 
i
 = 0;

21 
result
 = 0;

22 
sign
 = 1;

23 while (
str
[
i
] == 32 || (str[i] >= 9 && str[i] <= 13))

24 
i
++;

25 if (
str
[
i
] == '-')

27 
sign
 *= (-1);

28 
i
++;

30 else if (
str
[
i
] == '+')

31 
i
++;

32 while (
str
[
i
] >= '0' && str[i] <= '9')

34 
result
 *= 10;

35 
result
 += 
str
[
i
] - 48;

36 
i
++;

38 return (
sign
 * 
result
);

39 
	}
}

	@libft/libft/ft_atoi_base.c

12 #include 
	~"../includes/libft.h
"

13 #include 
	~"../includes/get_next_line.h
"

15 int 
	$transform
(char 
c
)

17 int 
i
;

18 char 
c2
;

20 
i
 = 10;

21 if (
c
 >= 'A' && c <= 'F')

22 
c2
 = 'A';

23 if (
c
 >= 'a' && c <= 'f')

24 
c2
 = 'a';

25 while (
c
 != 
c2
)

27 
c2
++;

28 
i
++;

30 return (
i
);

31 
	}
}

33 int 
	$ft_atoi_base
(const char *
str
, int 
str_base
)

35 int 
i
;

36 int 
count
;

37 int 
result
;

38 int 
sign
;

40 
i
 = 0;

41 
result
 = 0;

42 
count
 = 
	`ft_strlen_int
(
str
) - 1;

43 
sign
 = 1;

44 if (
str
[
i
] == '-')

46 
i
++;

47 
sign
 = -1;

48 
count
--;

50 while (
str
[
i
++] != 0)

52 if (
str
[
i
] >= '0' && str[i] <= '9')

53 
result
 = result + (
str
[
i
] - '0') * 
	`power
(
str_base
, 
count
);

54 if ((
str
[
i
] >= 'A' && str[i] <= 'F') || \

55 (
str
[
i
] >= 'a' && str[i] <= 'f'))

56 
result
 = result + 
	`transform
(
str
[
i
]) * 
	`power
(
str_base
, 
count
);

57 
count
--;

59 return (
result
 * 
sign
);

60 
	}
}

	@libft/libft/ft_bzero.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_bzero
(void *
s
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (
n
 == 0)

21 while (
i
 < 
n
)

23 *(char *)(
s
 + 
i
) = 0;

24 
i
++;

26 
	}
}

	@libft/libft/ft_calloc.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_calloc
(
size_t
 
count
, size_t 
size
)

16 void *
ptr
;

18 
ptr
 = (void *)
	`malloc
(
count
 * 
size
);

19 if (!
ptr
)

20 return (
NULL
);

21 
	`ft_bzero
(
ptr
, (
count
 * 
size
));

22 return (
ptr
);

23 
	}
}

	@libft/libft/ft_isalnum.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalnum
(int 
c
)

16 if (
	`ft_isalpha
(
c
) == 1 || 
	`ft_isdigit
(c) == 1)

20 
	}
}

	@libft/libft/ft_isalpha.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalpha
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

18 else if (
c
 >= 'a' && c <= 'z')

22 
	}
}

	@libft/libft/ft_isascii.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isascii
(int 
c
)

16 if (
c
 >= 0 && c <= 127)

20 
	}
}

	@libft/libft/ft_isdigit.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isdigit
(int 
c
)

16 if (
c
 >= '0' && c <= '9')

20 
	}
}

	@libft/libft/ft_isprint.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isprint
(int 
c
)

16 if (
c
 >= 32 && c <= 126)

20 
	}
}

	@libft/libft/ft_itoa.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbchar
(int 
n
)

16 
size_t
 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

41 char *
	$ft_nb_is_negative
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

43 int 
result
;

45 
result
 = 0;

46 if (
n
 == -2147483648)

48 
n
 = -214748364;

49 
itoa_str
[
nb_char
 - 1] = (char)(8 + 48);

50 
nb_char
--;

52 
n
 *= (-1);

53 while (
n
 > 0)

55 
result
 = (
n
 % 10);

56 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

57 
n
 = n / 10;

58 
nb_char
--;

60 
itoa_str
[--
nb_char
] = '-';

61 return (
itoa_str
);

62 
	}
}

64 char *
	$ft_nb_is_positive
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

66 int 
result
;

68 
result
 = 0;

69 while (
n
 > 0)

71 
result
 = 
n
 % 10;

72 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

73 
n
 = n / 10;

74 
nb_char
--;

76 return (
itoa_str
);

77 
	}
}

79 char *
	$ft_itoa
(int 
n
)

81 
size_t
 
nb_char
;

82 
size_t
 
buff
;

83 char *
itoa_str
;

85 
buff
 = 0;

86 
nb_char
 = 
	`ft_count_nbchar
(
n
);

87 
itoa_str
 = (char *)
	`ft_calloc
((
nb_char
 + 1), sizeof(char));

88 if (!
itoa_str
)

89 return (
NULL
);

90 while (
buff
 < 
nb_char
)

92 
itoa_str
[
buff
] = '0';

93 
buff
++;

95 if (
n
 == 0)

96 
itoa_str
[0] = (char)(0 + 48);

97 else if (
n
 < 0)

98 
itoa_str
 = 
	`ft_nb_is_negative
(
n
, itoa_str, 
nb_char
);

99 else if (
n
 > 0)

100 
itoa_str
 = 
	`ft_nb_is_positive
(
n
, itoa_str, 
nb_char
);

101 return (
itoa_str
);

102 
	}
}

	@libft/libft/ft_lstadd_back.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
)

16 
t_list
 *
lstlast
;

18 if (*
lst
 == 
NULL
)

19 *
lst
 = 
new
;

20 else if (!
lst
 || !
new
)

24 
lstlast
 = 
	`ft_lstlast
(*
lst
);

25 
lstlast
->
next
 = 
new
;

27 
	}
}

	@libft/libft/ft_lstadd_front.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
)

16 if (*
lst
 == 
NULL
)

18 
new
->
next
 = 
NULL
;

19 *
lst
 = 
new
;

21 else if (*
lst
 != 
NULL
)

23 
new
->
next
 = *
lst
;

24 *
lst
 = 
new
;

26 
	}
}

	@libft/libft/ft_lstclear.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*))

16 
t_list
 *
temp
;

17 
t_list
 *
ptr
;

19 
ptr
 = *
lst
;

20 if (!
del
)

22 while (
ptr
 != 
NULL
)

24 
temp
 = 
ptr
->
next
;

25 
	`ft_lstdelone
(
ptr
, 
del
);

26 
ptr
 = 
temp
;

28 *
lst
 = 
NULL
;

29 
	}
}

	@libft/libft/ft_lstdel_first_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_first_el
(
t_list
 **
a
)

16 
t_list
 *
tmp
;

18 
tmp
 = (*
a
)->
next
;

19 
	`free
 (*
a
);

20 *
a
 = 
tmp
;

21 
	}
}

	@libft/libft/ft_lstdel_last_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_last_el
(
t_list
 **
a
)

16 
t_list
 *
end
;

17 
t_list
 *
prev
;

19 
end
 = *
a
;

20 
prev
 = 
NULL
;

21 while (
end
->
next
)

23 
prev
 = 
end
;

24 
end
 = end->
next
;

26 
prev
->
next
 = 
NULL
;

27 
	`free
 (
end
);

28 
	}
}

	@libft/libft/ft_lstdelone.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*))

16 if (!
lst
 || !
del
)

18 
	`del
(
lst
->
content
);

19 
	`free
(
lst
);

20 
	}
}

	@libft/libft/ft_lstiter.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *))

16 
t_list
 *
ptr
;

18 
ptr
 = 
lst
;

19 while (
ptr
 != 
NULL
)

21 
	`f
(
ptr
->
content
);

22 
ptr
 = ptr->
next
;

24 
	}
}

	@libft/libft/ft_lstlast.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstlast
(
t_list
 *
lst
)

16 while (
lst
 != 
NULL
 && lst->
next
 != NULL)

18 
lst
 = lst->
next
;

20 return (
lst
);

21 
	}
}

	@libft/libft/ft_lstmap.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *))

16 
t_list
 *
new_list
;

17 
t_list
 *
head
;

19 if (!
lst
 || !
f
)

20 return (
NULL
);

21 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

22 if (!
new_list
)

23 return (
NULL
);

24 
head
 = 
new_list
;

25 
lst
 = lst->
next
;

26 while (
lst
 != 
NULL
)

28 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

29 if (!
new_list
)

31 
	`ft_lstclear
(&
head
, 
del
);

32 return (
NULL
);

34 
	`ft_lstadd_back
(&
head
, 
new_list
);

35 
lst
 = lst->
next
;

37 return (
head
);

38 
	}
}

	@libft/libft/ft_lstnew.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstnew
(void *
content
)

16 
t_list
 *
lstnew
;

18 
lstnew
 = (
t_list
 *)
	`malloc
(sizeof(t_list));

19 if (!
lstnew
)

20 return (
NULL
);

21 
lstnew
->
next
 = 
NULL
;

22 
lstnew
->
content
 = (void *)content;

23 return (
lstnew
);

24 
	}
}

	@libft/libft/ft_lstsize.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_lstsize
(
t_list
 *
lst
)

16 int 
i
;

17 
t_list
 *
ptr
;

19 
i
 = 0;

20 
ptr
 = 
NULL
;

21 
ptr
 = 
lst
;

22 while (
ptr
 != 
NULL
)

24 
ptr
 = ptr->
next
;

25 
i
++;

27 return (
i
);

28 
	}
}

	@libft/libft/ft_memchr.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s
 + 
i
) == (unsigned char) 
c
)

23 return ((unsigned char *)(
s
 + 
i
));

26 
i
++;

28 return (
NULL
);

29 
	}
}

	@libft/libft/ft_memcmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s1
 + 
i
) != *(unsigned char *)(
s2
 + i))

23 return (*(unsigned char *)(
s1
 + 
i
) - *(unsigned char *)(
s2
 + i));

26 
i
++;

29 
	}
}

	@libft/libft/ft_memcpy.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 while (
i
 < 
n
)

23 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

24 
i
++;

26 return (
dst
);

27 
	}
}

	@libft/libft/ft_memmove.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 if (
dst
 > 
src
)

23 while (
len
--)

25 *(char *)(
dst
 + 
len
) = *(char *)(
src
 + len);

27 return (
dst
);

29 while (
i
 < 
len
)

31 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

32 
i
++;

34 return (
dst
);

35 
	}
}

	@libft/libft/ft_memset.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memset
(void *
b
, int 
c
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
len
)

21 *(unsigned char *)(
b
 + 
i
) = (unsigned char)
c
;

22 
i
++;

24 return (
b
);

25 
	}
}

	@libft/libft/ft_putchar_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putchar_fd
(char 
c
, int 
fd
)

16 
	`write
(
fd
, &
c
, 1);

17 
	}
}

	@libft/libft/ft_putendl_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putendl_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

26 
	`write
(
fd
, "\n", 1);

28 
	}
}

	@libft/libft/ft_putnbr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putnbr_fd
(int 
n
, int 
fd
)

16 if (
n
 == -2147483648)

18 
	`ft_putstr_fd
("-2147483648", 
fd
);

20 else if (
n
 < 0)

22 
	`ft_putchar_fd
('-', 
fd
);

23 
n
 = n * (-1);

24 
	`ft_putnbr_fd
(
n
, 
fd
);

26 else if (
n
 > 9)

28 
	`ft_putnbr_fd
(
n
 / 10, 
fd
);

29 
	`ft_putnbr_fd
((
n
 % 10), 
fd
);

32 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

33 
	}
}

	@libft/libft/ft_putstr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putstr_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

27 
	}
}

	@libft/libft/ft_split.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbsubstr
(const char *
s
, char 
c
)

16 unsigned int 
i
;

17 
size_t
 
count
;

19 
i
 = 0;

20 
count
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] != 
c
)

25 while (
s
[
i
] != 
c
 && s[i] != '\0')

26 
i
++;

27 
count
++;

29 while (
s
[
i
] == 
c
)

30 
i
++;

32 return (
count
);

33 
	}
}

35 unsigned int 
	$ft_start_index_substr
(char const *
s
, char 
c
, unsigned int 
start
)

37 while (
s
[
start
] == 
c
 && s[start] != '\0')

38 
start
++;

39 return (
start
);

40 
	}
}

42 unsigned int 
	$ft_nb_char_substr
(char const *
s
, char 
c
, unsigned int 
start
)

44 unsigned int 
nb_char_substr
;

46 
nb_char_substr
 = 0;

47 while (
s
[
start
] != 
c
 && s[start] != '\0')

49 
start
++;

50 
nb_char_substr
++;

52 return (
nb_char_substr
);

53 
	}
}

55 char *
ft_create_substr
(\

56 char const *
s
, char 
c
, unsigned int 
start
, unsigned int 
nb_char_substr
)

58 unsigned int 
	gi
;

59 char *
	gsubstr
;

61 
	gi
 = 0;

62 
	gsubstr
 = (char *)
ft_calloc
((
nb_char_substr
 + 1), sizeof(char));

63 if (!
	gsubstr
)

64 return (
	gNULL
);

65 while (
	gs
[
start
] != 
c
 && 
s
[start] != '\0' && 
i
 < 
nb_char_substr
)

66 
substr
[
i
++] = 
s
[
start
++];

67 return (
	gsubstr
);

70 char **
	$ft_split
(char const *
s
, char 
c
)

72 
size_t
 
nb_substr
;

73 
size_t
 
i
;

74 char **
tab2d
;

75 unsigned int 
start
;

76 unsigned int 
nb_char_substr
;

78 
i
 = 0;

79 
start
 = 0;

80 
nb_substr
 = 
	`ft_count_nbsubstr
(
s
, 
c
);

81 
tab2d
 = (char **)
	`ft_calloc
((
nb_substr
 + 1), sizeof(char *));

82 if (!
tab2d
)

83 return (
NULL
);

84 while (
s
[
start
] != '\0' && 
i
 < 
nb_substr
)

86 
start
 = 
	`ft_start_index_substr
(
s
, 
c
, start);

87 
nb_char_substr
 = 
	`ft_nb_char_substr
(
s
, 
c
, 
start
);

88 
tab2d
[
i
] = 
	`ft_create_substr
(
s
, 
c
, 
start
, 
nb_char_substr
);

89 
start
 = start + 
nb_char_substr
;

90 
i
++;

92 return (
tab2d
);

93 
	}
}

	@libft/libft/ft_strchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strchr
(const char *
s
, int 
c
)

16 int 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 if ((char)
c
 == 
s
[
i
])

22 return ((char *)(
s
 + 
i
));

23 
i
++;

25 if ((char)
c
 == '\0')

26 return ((char *)(
s
 + 
i
));

28 return (
NULL
);

29 
	}
}

	@libft/libft/ft_strcpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strcpy
(char *
dst
, const char *
src
)

16 int 
i
;

18 
i
 = 0;

19 while (
src
[
i
])

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 
dst
[
i
] = '\0';

25 return (
dst
);

26 
	}
}

	@libft/libft/ft_strcspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strcspn
(const char *
s
, const char *
reject
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
])

21 if (
	`ft_strchr
(
reject
, 
s
[
i
]) != 
NULL
)

22 return (
i
);

23 
i
++;

25 return (
i
);

26 
	}
}

	@libft/libft/ft_strdup.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strdup
(const char *
s1
)

16 int 
size
;

17 char *
s1_copie
;

19 
size
 = 
	`ft_strlen
(
s1
) + 1;

20 
s1_copie
 = (char *)
	`malloc
(
size
 * sizeof(char));

21 if (!
s1_copie
)

22 return (
NULL
);

23 
	`ft_strlcpy
(
s1_copie
, 
s1
, 
size
);

24 return (
s1_copie
);

25 
	}
}

	@libft/libft/ft_striteri.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*))

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`f
(
i
, &
s
[i]);

24 
i
++;

27 
	}
}

	@libft/libft/ft_strjoin.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strjoin
(char const *
s1
, char const *
s2
)

16 
size_t
 
size_s1
;

17 
size_t
 
size_s2
;

18 char *
strjoin
;

20 
size_s1
 = 
	`ft_strlen
(
s1
);

21 
size_s2
 = 
	`ft_strlen
(
s2
);

22 
strjoin
 = (char *)
	`malloc
((
size_s1
 + 
size_s2
 + 1) * sizeof(char));

23 if (!
strjoin
)

24 return (
NULL
);

25 
	`ft_memcpy
(
strjoin
, 
s1
, 
size_s1
);

26 
	`ft_memcpy
((
strjoin
 + 
size_s1
), 
s2
, 
size_s2
);

27 
	`ft_memset
((
strjoin
 + 
size_s1
 + 
size_s2
), 0, 1);

28 return (
strjoin
);

29 
	}
}

	@libft/libft/ft_strlcat.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcat
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
strlen_src
;

18 
size_t
 
strlen_dst
;

19 
size_t
 
temp
;

21 
i
 = 0;

22 
strlen_src
 = 
	`ft_strlen
(
src
);

23 
strlen_dst
 = 
	`ft_strlen
(
dst
);

24 
temp
 = 
strlen_dst
;

25 if (
dstsize
 < 
strlen_dst
)

26 return (
dstsize
 + 
strlen_src
);

27 if (
dstsize
 > 
strlen_dst
 + 1)

29 while (
src
[
i
] && 
strlen_dst
 != (
dstsize
 - 1))

31 
dst
[
strlen_dst
++] = 
src
[
i
++];

33 
dst
[
strlen_dst
] = '\0';

35 return (
temp
 + 
strlen_src
);

36 
	}
}

	@libft/libft/ft_strlcpy.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcpy
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
j
;

19 
i
 = 0;

20 
j
 = 0;

21 while (
src
[
i
] != '\0')

23 
i
++;

25 if (
dstsize
 > 0)

27 while (
j
 < (
dstsize
 - 1) && 
src
[j] != '\0')

29 
dst
[
j
] = 
src
[j];

30 
j
++;

32 
dst
[
j
] = '\0';

34 return (
i
);

35 
	}
}

	@libft/libft/ft_strlen.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlen
(const char *
s
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 
i
++;

23 return (
i
);

24 
	}
}

	@libft/libft/ft_strmapi.c

12 #include 
	~"../includes/libft.h
"

14 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char))

16 unsigned int 
i
;

17 
size_t
 
size
;

18 char *
strmapi
;

20 
i
 = 0;

21 
size
 = 
	`ft_strlen
(
s
);

22 
strmapi
 = (char *)
	`malloc
((
size
 + 1) * sizeof(char));

23 if (!
strmapi
)

24 return (
NULL
);

25 while (
s
[
i
] != '\0')

27 
strmapi
[
i
] = 
	`f
(i, 
s
[i]);

28 
i
++;

30 
strmapi
[
i
] = '\0';

31 return (
strmapi
);

32 
	}
}

	@libft/libft/ft_strncmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (((unsigned char)
s1
[
i
] || (unsigned char)
s2
[i]) && i < 
n
)

21 if (
s1
[
i
] != 
s2
[i])

22 return ((unsigned char)
s1
[
i
] - (unsigned char)
s2
[i]);

23 
i
++;

26 
	}
}

	@libft/libft/ft_strncpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strncpy
(char *
dst
, const char *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
src
[
i
] && i < 
len
)

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 while (
i
 < 
len
)

26 
dst
[
i
] = '\0';

27 
i
++;

29 return (
dst
);

30 
	}
}

	@libft/libft/ft_strnstr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
)

16 
size_t
 
len_needle
;

17 
size_t
 
len_haystack
;

19 
len_needle
 = 
	`ft_strlen
(
needle
);

20 
len_haystack
 = 
	`ft_strlen
(
haystack
);

21 if (
needle
[0] == '\0')

22 return ((char *)(
haystack
));

23 if (
len_needle
 > 
len_haystack
 || 
len
 < len_needle)

24 return (
NULL
);

25 if (
len
 > 
len_haystack
)

26 
len
 = 
len_haystack
;

27 while (
len
 >= 
len_needle
 && 
haystack
)

29 if (
	`ft_memcmp
(
haystack
, 
needle
, 
len_needle
) == 0)

30 return ((char *)(
haystack
));

33 
haystack
++;

34 
len
--;

37 return (
NULL
);

38 
	}
}

	@libft/libft/ft_strpbrk.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strpbrk
(const char *
s1
, const char *
s2
)

16 int 
i
;

18 
i
 = 0;

19 while (
s1
[
i
] != '\0')

21 if (
	`ft_strchr
(
s2
, 
s1
[
i
]) != 0)

23 return ((char *) &
s1
[
i
]);

25 ++
i
;

28 
	}
}

	@libft/libft/ft_strrchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strrchr
(const char *
s
, int 
c
)

16 int 
i
;

17 int 
k
;

19 
i
 = 0;

20 
k
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] == (char)
c
)

24 
k
 = 
i
;

25 
i
++;

27 if (
s
[
k
] == (char)
c
)

28 return ((char *)(
s
 + 
k
));

29 else if ((char)
c
 == 
s
[
i
])

30 return ((char *)(
s
 + 
i
));

32 return (
NULL
);

33 
	}
}

	@libft/libft/ft_strspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strspn
(const char *
s
, const char *
accept
)

16 
size_t
 
count
;

17 
size_t
 
i
;

19 
count
 = 0;

20 
i
 = 0;

21 while (
s
[
i
] && 
	`ft_strchr
(
accept
, s[i]) != 0)

23 
count
++;

24 
i
++;

26 return (
count
);

27 
	}
}

	@libft/libft/ft_strtrim.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strtrim
(char const *
s1
, char const *
set
)

16 unsigned int 
front
;

17 unsigned int 
end
;

18 unsigned int 
i
;

19 char *
strtrim
;

21 
front
 = 0;

22 
i
 = 0;

23 
end
 = (unsigned int)(
	`ft_strlen
(
s1
));

24 while (
s1
[
front
] != '\0' && 
	`ft_strchr
(
set
, *(s1 + front)) != 
NULL
)

25 
front
++;

26 while (
front
 < 
end
 && 
	`ft_strrchr
(
set
, *(
s1
 + end - 1)) != 
NULL
)

27 
end
--;

28 
strtrim
 = (char *)
	`malloc
((
end
 - 
front
 + 1) * sizeof(char));

29 if (!
strtrim
)

30 return (
NULL
);

31 
i
 = 0;

32 while (
front
 < 
end
)

33 
strtrim
[
i
++] = 
s1
[
front
++];

34 
strtrim
[
i
] = 0;

35 return (
strtrim
);

36 
	}
}

	@libft/libft/ft_substr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
)

16 char *
substr
;

17 unsigned int 
i
;

18 
size_t
 
size
;

20 
i
 = 0;

21 if (!
s
)

22 return (
NULL
);

23 
size
 = 
	`ft_strlen
(
s
);

24 if (
len
 > 
size
)

25 
len
 = 
size
;

26 if (
start
 >= (unsigned int)
size
)

28 
substr
 = (char *)
	`malloc
(1 * sizeof(char));

29 if (!
substr
)

30 return (
NULL
);

31 
substr
[0] = '\0';

32 return (
substr
);

34 
substr
 = (char *)
	`malloc
((
len
 + 1) * sizeof(char));

35 if (!
substr
)

36 return (
NULL
);

37 while (
i
 < (unsigned int)
len
 && 
s
[
start
] != '\0' )

38 
substr
[
i
++] = 
s
[
start
++];

39 
substr
[
i
] = '\0';

40 return (
substr
);

41 
	}
}

	@libft/libft/ft_tolower.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_tolower
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

17 return (
c
 + 32);

19 return (
c
);

20 
	}
}

	@libft/libft/ft_toupper.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_toupper
(int 
c
)

16 if (
c
 >= 'a' && c <= 'z')

17 return (
c
 - 32);

19 return (
c
);

20 
	}
}

	@libft/libft/power.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$power
(int 
str_base
, int 
power
)

16 int 
result
;

18 
result
 = 1;

19 if (
power
 < 0 || 
str_base
 == 0)

23 while (
power
 > 0)

25 
result
 = result * 
str_base
;

26 
power
--;

28 return (
result
);

29 
	}
}

	@libft/libft/str_lowercase.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$str_lowercase
(char *
str
)

16 int 
i
;

18 
i
 = 0;

19 while (
str
[
i
])

21 if (
str
[
i
] >= 'A' && str[i] <= 'Z')

22 
str
[
i
] += 32;

23 
i
++;

25 return (
str
);

26 
	}
}

	@main.c

12 #include 
	~"minishell.h
"

14 
t_shell
 *
	gg_shell
;

16 char *
	$readline_routine
(void)

18 char *
line
;

20 
line
 = 
NULL
;

21 
line
 = 
	`readline
("minishell$ ");

22 if (!
line
)

24 
	`rl_clear_history
();

25 return (
NULL
);

27 if (
line
[0])

28 
	`add_history
(
line
);

29 return (
line
);

30 
	}
}

32 void 
	$check_for_malloc_error
(
t_cmd
 **
head
)

34 if (
g_shell
->
error_exit
 == 1)

35 
	`free_and_exit_prog
(
head
, 1);

36 
	}
}

38 int 
	$main
(int 
ac
, char **
av
, char **
envp
)

40 char *
line
;

41 
t_token
 *
token
;

42 
t_cmd
 *
cmd
;

43 int 
exit_status
;

45 (void)
av
;

46 (void)
ac
;

47 if (!
	`init_shell
(
envp
))

51 
	`parent_signal_handler
();

52 
line
 = 
	`readline_routine
();

53 if (!
line
)

55 
token
 = 
	`parsing
(
line
);

56 
cmd
 = 
	`cmd_linked_list
(&
token
);

57 
	`execution
(&
cmd
);

58 
	`check_for_malloc_error
(&
cmd
);

59 
	`free_cmd
(&
cmd
);

61 
exit_status
 = 
g_shell
->exit_status;

62 
	`free_shell
();

63 
	`printf
("exit\n");

64 return (
exit_status
);

65 
	}
}

	@malloc_error/malloc_error_print_message.c

12 #include 
	~"minishell.h
"

14 void 
	$malloc_error_print_message
(char *
s
)

16 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
s
);

17 
g_shell
->
error_exit
 = 1;

18 
g_shell
->
exit_status
 = 1;

19 
	}
}

	@minishell.h

13 #ifndef 
MINISHELL_H


14 #define 
	#MINISHELL_H


	)

16 #include 
	~<stdio.h
>

17 #include 
	~<string.h
>

18 #include 
	~<stdlib.h
>

19 #include 
	~<errno.h
>

20 #include 
	~<curses.h
>

21 #include 
	~<term.h
>

22 #include 
	~<signal.h
>

23 #include 
	~<unistd.h
>

24 #include 
	~<fcntl.h
>

25 #include 
	~<stdarg.h
>

26 #include 
	~<sys/wait.h
>

27 #include 
	~<sys/stat.h
>

28 #include 
	~<sys/types.h
>

29 #include 
	~<readline/readline.h
>

30 #include 
	~<readline/history.h
>

31 #include 
	~"libft/includes/libft.h
"

33 #define 
	#RED
 "\x1b[31m"

	)

34 #define 
	#BLU
 "\x1B[34m"

	)

35 #define 
	#BLU_2
 "\e[1;34m"

	)

36 #define 
	#GRN
 "\x1B[32m"

	)

37 #define 
	#YEL
 "\x1B[33m"

	)

38 #define 
	#MAG
 "\e[1;35m"

	)

39 #define 
	#CYN
 "\x1B[36m"

	)

40 #define 
	#WHT
 "\x1B[37m"

	)

41 #define 
	#RESET
 "\x1B[0m"

	)

43 #define 
	#WORD
 1

	)

44 #define 
	#PIPELINE
 2

	)

45 #define 
	#L_CHEVRON
 3

	)

46 #define 
	#R_CHEVRON
 4

	)

47 #define 
	#APPEND
 5

	)

48 #define 
	#HERE_DOC
 6

	)

49 #define 
	#DOLLAR
 7

	)

50 #define 
	#QUESTION
 8

	)

51 #define 
	#EXPAND
 9

	)

52 #define 
	#DELETE
 10

	)

53 #define 
	#EXPANDED
 11

	)

54 #define 
	#KEY_WORD
 12

	)

55 #define 
	#ERROR_EXIT
 -1

	)

60 typedef struct 
	ss_env


62 char *
	mvar_name
;

63 char *
	mvar_value
;

64 struct 
s_env
 *
	mnext
;

65 } 
	tt_env
;

67 typedef struct 
	ss_token


69 char *
	mcontent
;

70 int 
	mid
;

71 int 
	mres
;

72 int 
	mpos
;

73 struct 
s_token
 *
	mnext
;

74 } 
	tt_token
;

76 typedef struct 
	ss_cmd


78 
pid_t
 
	mpid
;

79 char **
	mcmd
;

80 char **
	mredir
;

81 char *
	mpath
;

82 int 
	mstatus
;

83 int 
	mffd_in
;

84 int 
	mffd_out
;

85 int 
	msave_fdout
;

86 int 
	msave_fdin
;

87 int 
	mfd
[2];

88 int 
	mres
;

89 struct 
s_cmd
 *
	mnext
;

90 } 
	tt_cmd
;

92 typedef struct 
	ss_shell


94 
t_env
 *
	menv
;

95 volatile int 
	mexit_status
;

96 volatile int 
	mterminated
;

97 int 
	merror_exit
;

98 char **
	msave_env
;

99 int 
	mpid
;

100 } 
	tt_shell
;

102 extern 
t_shell
 *
g_shell
;

105 int 
here_doc
(
t_token
 **
head
);

107 int 
make_redirections
(
t_cmd
 *
cmd
, int 
i
);

108 void 
restaure_fds
(
t_cmd
 *
cmd
, int 
i
);

109 int 
redir_fdout
(
t_cmd
 *
cmd
, char *
redir_op
, char *
file_path
);

110 int 
redir_fdin
(
t_cmd
 *
cmd
, char *
redir_op
, char *
file_path
, int 
j
);

111 int 
append
(
t_cmd
 *
cmd
, char *
file_path
);

114 void 
free_before_exit
(
t_cmd
 **
head
);

115 void 
free_and_exit_prog
(
t_cmd
 **
head
, int 
exit_code
);

116 int 
size_tab2d
(char **
s
);

119 void 
execution
(
t_cmd
 **
head
);

120 int 
copy_env_tab
(void);

121 void 
one_cmd
(
t_cmd
 *
cmd
);

122 void 
pipex
(
t_cmd
 **
head
);

123 void 
ft_exe
(int 
i
, int 
save_fdin
, 
t_cmd
 *
cmd
);

126 int 
cmd_is_builtin
(char *
s
);

127 void 
execute_builtin
(
t_cmd
 *
cmd
);

128 void 
_pwd
(void);

129 void 
_env
(
t_cmd
 *
cmd
, 
t_env
 *
env
);

130 void 
print_getcwd_error
(char *
s
);

131 int 
_echo
(
t_cmd
 *
cmd
);

132 void 
ft_exit
(
t_cmd
 *
cmd
);

133 int 
no_int_errors
(char *
str
);

134 void 
_cd
(
t_cmd
 *
cmd
);

135 void 
_export
(
t_cmd
 *
cmd
);

136 int 
check_if_var_exists
(char *
s
);

137 int 
check_if_valid_identifier
(char *
s
, char *
command
);

138 void 
print_export_unset_error
(char *
identifier
, char *
command
);

139 void 
_unset
(
t_cmd
 *
cmd
);

142 void 
execute_bin
(
t_cmd
 *
cmd
);

143 int 
search_path
(
t_cmd
 *
cmd
, char **
env
);

144 int 
get_path
(
t_cmd
 *
cmd
);

147 
t_cmd
 *
cmd_linked_list
(
t_token
 **
token
);

148 void 
free_tab2d
(char **
s
);

149 void 
free_cmd
(
t_cmd
 **
head
);

152 int 
create_redir
(
t_token
 **
token
, 
t_cmd
 *
cmd
);

155 int 
create_cmd
(
t_token
 **
token
, 
t_cmd
 *
cmd
);

158 int 
expansion
(
t_token
 **
token
, t_token *
curr
, int 
pos
);

159 int 
check_dollar
(
t_token
 *
curr
, int 
i
);

160 int 
trim_dollar
(
t_token
 *
curr
, int 
pos
);

163 int 
is_dollar_to_expand
(
t_token
 *
curr
, int 
i
);

164 int 
not_within_squotes
(
t_token
 *
curr
, int 
pos
);

167 int 
trim_dollar
(
t_token
 *
curr
, int 
pos
);

170 int 
loop_dollars
(char *
s
, int 
i
);

171 int 
loop_through
(char *
s
, int 
i
);

174 int 
size_var
(char *
s
);

175 int 
check_var_exist
(
t_token
 *
tmp
);

178 int 
join_tokens
(
t_token
 **
new
, t_token *
curr
);

181 int 
prepare_expand
(
t_token
 *
tmp
, int 
i
);

182 int 
set_id_expansion
(
t_token
 *
token
);

185 int 
quote_removing
(
t_token
 **
head
, t_token *
curr
, int 
pos
);

187 
t_token
 *
delete_token
(t_token **
head
);

188 int 
token_list_size
(
t_token
 **
head
);

191 
t_token
 *
parsing
(char *
line
);

192 int 
syntax_error_check
(char *
s
);

193 int 
check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
);

194 int 
check_quotes_errors
(char *
s
, char 
c
, int *
i
);

195 int 
count_metachar
(char *
s
, char 
c
, int 
num
);

196 int 
check_multiple_operators_error
(int 
i
, int 
num
, char 
c
);

197 void 
print_syntax_error_char
(char 
c
);

198 void 
print_syntax_error_dchar
(char 
c
);

199 void 
print_syntax_error_str
(char *
s
);

202 int 
character_extraction
(char *
line
, int 
ind
);

203 int 
token_extraction
(char *
line
, int 
ind
);

204 
t_token
 *
get_tokens
(char *
line
);

205 int 
get_tokens_size
(char *
line
, int *
i
);

206 
t_token
 *
create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
);

209 void 
malloc_error_print_message
(char *
s
);

212 
t_token
 *
new_token
(char *
line
, int 
start
, int 
len
);

213 void 
set_id
(
t_token
 **
head
, t_token *
token
);

214 int 
token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
);

215 int 
link_token
(
t_token
 **
head
, t_token *
new
);

216 void 
free_token
(
t_token
 **
head
);

219 int 
is_dollar
(char 
c
);

220 int 
is_pipeline
(char 
c
);

221 int 
is_chevron
(char 
c
);

222 int 
is_lchevron
(char 
c
);

223 int 
is_rchevron
(char 
c
);

224 int 
is_operator
(char 
c
);

225 int 
is_newline
(char 
c
);

226 int 
is_white_space
(char 
c
);

227 int 
is_blank
(char 
c
);

228 int 
is_metacharacter
(char 
c
);

229 int 
is_delimiter
(char 
c
);

230 int 
is_word
(char 
c
);

231 int 
is_double_quote
(char 
c
);

232 int 
is_simple_quote
(char 
c
);

233 int 
is_quote
(char 
c
);

234 int 
is_question
(char 
c
);

235 int 
is_punct
(char 
c
);

236 int 
is_numeric
(char *
s
);

239 
t_env
 *
new_env
(char *
envp
);

240 int 
link_env
(
t_env
 **
head
, t_env *
last
);

241 char *
get_env_var_value
(char *
var_name
);

244 int 
init_shell
(char **
envp
);

245 void 
free_shell
(void);

248 void 
init_sigset
(
sigset_t
 *
set
);

249 void 
parent_signal_handler
(void);

250 void 
child_signal_handler
(void);

251 void 
here_doc_signal_handler
(void);

252 void 
pipex_signal_handler
(void);

255 char **
ft_splitpath
(char *
s
, char 
c
);

258 
t_env
 *
get_envp
(char **
envp
);

259 void 
free_env
(
t_env
 **
head
);

	@parsing/expansion.c

12 #include 
	~"minishell.h
"

41 int 
	$check_dollar
(
t_token
 *
curr
, int 
i
)

43 while (
curr
->
content
[
i
])

45 if (
	`is_dollar
(
curr
->
content
[
i
]) && 
	`not_within_squotes
(curr, i))

47 if (
	`is_dollar_to_expand
(
curr
, 
i
))

48 return (
	`prepare_expand
(
curr
, 
i
));

49 else if (
	`is_dollar
(
curr
->
content
[
i
 + 1]))

50 
i
 = 
	`loop_dollars
(
curr
->
content
, i);

51 else if (
	`is_quote
(
curr
->
content
[
i
 + 1]))

53 
curr
->
res
 = 
	`trim_dollar
(curr, 
i
);

54 if (
curr
->
res
 == 
ERROR_EXIT
)

55 return (
ERROR_EXIT
);

56 
i
 += 
curr
->
res
;

58 else if (
curr
->
content
[
i
 + 1] == '\0')

61 
i
++;

64 
i
++;

66 
curr
->
id
 = 
WORD
;

67 return (
i
);

68 
	}
}

70 static void 
	$expansion_next_token
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

72 
pos
 = 0;

73 if (
curr
->
next
)

75 
curr
 = curr->
next
;

76 
	`expansion
(
head
, 
curr
, 
pos
);

78 
	}
}

104 int 
	$expansion
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

106 if (
curr
)

108 if (
curr
->
id
 == 
DOLLAR
)

110 
pos
 = 
	`check_dollar
(
curr
, pos);

111 if (
pos
 == 
ERROR_EXIT
)

112 return (
	`free_token
(
head
), 0);

113 if (
curr
->
id
 == 
DELETE
)

115 
curr
 = 
	`delete_token
(
head
);

116 if (!
curr
)

118 
head
 = 
NULL
;

121 
pos
 = 0;

123 
	`expansion
(
head
, 
curr
, 
pos
);

126 
	`expansion_next_token
(
head
, 
curr
, 
pos
);

129 
	}
}

	@parsing/expansion_dollar_conditions.c

12 #include 
	~"minishell.h
"

14 int 
	$not_within_squotes
(
t_token
 *
curr
, int 
pos
)

16 int 
i
;

17 int 
start
;

19 
i
 = 0;

20 
start
 = 0;

21 if (!
	`is_dollar
(
curr
->
content
[
pos
]))

23 while (
curr
->
content
[
i
])

25 if (
	`is_double_quote
(
curr
->
content
[
i
]))

26 
i
 = 
	`loop_through
(
curr
->
content
, i);

27 else if (
	`is_simple_quote
(
curr
->
content
[
i
]))

29 
start
 = 
i
;

30 
i
 = 
	`loop_through
(
curr
->
content
, i);

31 if (
pos
 > 
start
 && pos < 
i
)

34 
i
++;

37 
	}
}

39 int 
	$is_dollar_to_expand
(
t_token
 *
curr
, int 
i
)

41 if (
	`is_question
(
curr
->
content
[
i
 + 1]) || \

42 (!
	`is_dollar
(
curr
->
content
[
i
 + 1]) && \

43 !
	`is_quote
(
curr
->
content
[
i
 + 1]) && \

44 !
	`is_punct
(
curr
->
content
[
i
 + 1]) && \

45 !
	`is_white_space
(
curr
->
content
[
i
 + 1]) && \

46 
curr
->
content
[
i
 + 1] != '\0'))

51 
	}
}

	@parsing/expansion_expand_var_helper.c

12 #include 
	~"minishell.h
"

14 static int 
	$replace_content
(
t_token
 *
tmp
, char *
s
)

16 
	`free
(
tmp
->
content
);

17 
tmp
->
content
 = 
NULL
;

18 
tmp
->
content
 = 
	`ft_strdup
(
s
);

19 if (!
tmp
->
content
)

21 
	`malloc_error_print_message
("ft_strdup failed");

22 return (
ERROR_EXIT
);

25 
	}
}

27 int 
	$check_var_exist
(
t_token
 *
tmp
)

29 if (
	`ft_strncmp
(&
tmp
->
content
[1], "?", 1) == 0)

31 return (
	`replace_content
(
tmp
, 
	`ft_itoa
(
g_shell
->
exit_status
)));

33 else if (
g_shell
 && g_shell->
env
 && g_shell->env->
var_name
)

35 if (
	`ft_strncmp
(
g_shell
->
env
->
var_name
, &
tmp
->
content
[1], \

36 
	`ft_strlen
(
tmp
->
content
)) == 0)

38 return (
	`replace_content
(
tmp
, 
g_shell
->
env
->
var_value
));

42 
	}
}

44 int 
	$size_var
(char *
s
)

46 int 
i
;

47 int 
count
;

49 
i
 = 0;

50 
count
 = 0;

51 while (
s
[
i
] && 
	`is_white_space
(s[i]))

52 
i
++;

53 while (
s
[
i
] && !
	`is_white_space
(s[i]))

55 
count
++;

56 
i
++;

58 return (
count
);

59 
	}
}

	@parsing/expansion_helper.c

12 #include 
	~"minishell.h
"

14 int 
	$expand_var
(
t_token
 **
new
)

16 
t_token
 *
tmp
;

17 
t_env
 *
save
;

18 int 
res
;

20 
tmp
 = *
new
;

21 
save
 = 
g_shell
->
env
;

22 while (
tmp
->
id
 != 
EXPAND
)

23 
tmp
 = tmp->
next
;

24 while (
g_shell
->
env
)

26 
res
 = 
	`check_var_exist
(
tmp
);

27 if (
res
 == 
ERROR_EXIT
)

28 return (
ERROR_EXIT
);

29 else if (
res
 == 1)

31 
tmp
->
id
 = 
EXPANDED
;

32 
g_shell
->
env
 = 
save
;

33 return (
	`size_var
(
tmp
->
content
));

35 
g_shell
->
env
 = g_shell->env->
next
;

37 
tmp
->
id
 = 
DELETE
;

38 
g_shell
->
env
 = 
save
;

40 
	}
}

42 int 
	$split_tokens
(
t_token
 **
new
, char *
s
, int 
start
, int 
len
)

44 if (
start
 != 0)

46 *
new
 = 
	`new_token
(
s
, 0, 
start
);

47 if (!*
new
)

48 return (
ERROR_EXIT
);

49 (*
new
)->
id
 = 
WORD
;

50 if (!
	`token_linked_list
(
new
, 
s
, 
start
, 
len
))

51 return (
ERROR_EXIT
);

52 (*
new
)->
next
->
id
 = 
EXPAND
;

56 *
new
 = 
	`new_token
(
s
, 
start
, 
len
);

57 if (!*
new
)

58 return (
ERROR_EXIT
);

59 (*
new
)->
id
 = 
EXPAND
;

61 
start
 += 
len
;

62 
len
 = 
start
;

63 while (
s
[
len
])

64 
len
++;

65 if (
len
 != 
start
)

66 if (!
	`token_linked_list
(
new
, 
s
, 
start
, 
len
))

67 return (
ERROR_EXIT
);

69 
	}
}

71 static int 
	$var_len
(char *
s
, int 
i
)

73 int 
len
;

75 
len
 = 0;

76 
i
++;

77 if (
	`is_question
(
s
[
i
]))

81 while (
s
[
i
] && \

82 !
	`is_white_space
(
s
[
i
]) && \

83 !
	`is_quote
(
s
[
i
]) && \

84 !
	`is_question
(
s
[
i
]) && \

85 !
	`is_dollar
(
s
[
i
]) && \

86 !
	`is_punct
(
s
[
i
]))

88 
i
++;

89 
len
++;

92 return (
len
);

93 
	}
}

95 int 
	$new_id
(
t_token
 **
new
)

97 
t_token
 *
ptr
;

99 
ptr
 = *
new
;

100 while (
ptr
)

102 if (
ptr
->
id
 == 
DELETE
 || ptr->id == 
EXPANDED
)

104 
ptr
 = ptr->
next
;

106 if (
ptr
->
next
 == 
NULL
)

107 return (
WORD
);

108 return (
	`set_id_expansion
(
ptr
->
next
));

109 
	}
}

116 int 
	$prepare_expand
(
t_token
 *
curr
, int 
i
)

118 
t_token
 *
new
;

119 int 
len
;

120 int 
id
;

122 
new
 = 
NULL
;

123 
len
 = 
	`var_len
(
curr
->
content
, 
i
);

124 if (
	`split_tokens
(&
new
, 
curr
->
content
, 
i
, 
len
 + 1) == 
ERROR_EXIT
)

125 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

126 
len
 = 
	`expand_var
(&
new
);

127 if (
len
 == 
ERROR_EXIT
)

128 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

129 
id
 = 
	`new_id
 (&
new
);

130 if (
	`join_tokens
(&
new
, 
curr
) == 
ERROR_EXIT
)

131 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

132 if (
curr
->
id
 == 
DELETE
)

134 
curr
->
id
 = id ;

135 return (
len
 + 
i
);

136 
	}
}

	@parsing/expansion_join_tokens.c

12 #include 
	~"minishell.h
"

14 static int 
	$get_expanded_size
(char *
s
, int 
i
)

16 int 
size
;

18 
size
 = 0;

19 while (
	`is_white_space
(
s
[
i
]))

20 
i
++;

21 while (
s
[
i
] && !
	`is_white_space
(s[i]))

23 
i
++;

24 
size
++;

26 return (
size
);

27 
	}
}

29 static int 
	$get_new_size
(
t_token
 **
new
)

31 
t_token
 *
ptr
;

32 int 
size
;

33 int 
i
;

35 
size
 = 0;

36 
ptr
 = *
new
;

37 while (
ptr
)

39 
i
 = 0;

40 if (
ptr
->
id
 == 
EXPANDED
)

41 
size
 += 
	`get_expanded_size
(
ptr
->
content
, 
i
);

42 else if (
ptr
->
id
 != 
DELETE
)

44 while (
ptr
->
content
[
i
])

46 
size
++;

47 
i
++;

50 
ptr
 = ptr->
next
;

52 return (
size
);

53 
	}
}

55 static void 
	$copy_helper
(
t_token
 **
new
, t_token *
curr
)

57 int 
i
;

58 int 
j
;

59 
t_token
 *
ptr
;

61 
i
 = 0;

62 
j
 = 0;

63 
ptr
 = *
new
;

64 while (
ptr
)

66 if (
ptr
->
id
 == 
EXPANDED
)

68 while (
ptr
->
content
[
j
] && 
	`is_white_space
(ptr->content[j]))

69 
j
++;

70 while (
ptr
->
content
[
j
] && !
	`is_white_space
(ptr->content[j]))

71 
curr
->
content
[
i
++] = 
ptr
->content[
j
++];

73 else if (
ptr
->
id
 != 
DELETE
)

74 while (
ptr
->
content
[
j
])

75 
curr
->
content
[
i
++] = 
ptr
->content[
j
++];

76 
ptr
 = ptr->
next
;

77 
j
 = 0;

79 
curr
->
content
[
i
] = '\0';

80 
	}
}

82 static int 
	$copy_join_tokens
(
t_token
 **
new
, t_token *
curr
, int 
size
)

84 
	`free
(
curr
->
content
);

85 
curr
->
content
 = 
NULL
;

86 
curr
->
content
 = 
	`malloc
((
size
 + 1) * sizeof(char));

87 if (!
curr
->
content
)

89 
	`malloc_error_print_message
(
	`strerror
(
errno
));

90 return (
ERROR_EXIT
);

92 
	`copy_helper
(
new
, 
curr
);

93 
	`free_token
(
new
);

95 
	}
}

97 int 
	$join_tokens
(
t_token
 **
new
, t_token *
curr
)

99 int 
size
;

101 
size
 = 
	`get_new_size
(
new
);

102 if (
size
 == 0)

104 
	`free_token
(
new
);

105 
curr
->
id
 = 
DELETE
;

108 if (
	`copy_join_tokens
(
new
, 
curr
, 
size
) == 
ERROR_EXIT
)

109 return (
ERROR_EXIT
);

111 
	}
}

	@parsing/expansion_looping.c

12 #include 
	~"minishell.h
"

53 int 
	$loop_dollars
(char *
s
, int 
i
)

55 while (
	`is_dollar
(
s
[
i
]) && s[i])

56 
i
++;

57 if (
s
[
i
] != '\0' && !
	`is_white_space
(s[i]))

58 
i
--;

59 return (
i
);

60 
	}
}

68 int 
	$loop_through
(char *
s
, int 
i
)

70 char 
c
;

72 
c
 = 
s
[
i
];

73 
i
++;

74 while (
s
[
i
] != 
c
)

75 
i
++;

76 return (
i
);

77 
	}
}

	@parsing/expansion_trim_dollar.c

12 #include 
	~"minishell.h
"

17 static int 
	$copy_string
(
t_token
 *
curr
, char **
s
, int 
pos
)

19 int 
i
;

20 int 
j
;

22 
i
 = 0;

23 
j
 = 0;

24 *
s
 = 
	`malloc
(sizeof(char) * 
	`ft_strlen
(
curr
->
content
));

25 if (!*
s
)

27 
i
 = 0;

28 while (
curr
->
content
[
i
])

30 if (
i
 == 
pos
)

31 
i
++;

32 (*
s
)[
j
] = 
curr
->
content
[
i
];

33 
i
++;

34 
j
++;

36 (*
s
)[
j
] = '\0';

37 
	`free
(
curr
->
content
);

38 
curr
->
content
 = *
s
;

40 
	}
}

46 int 
	$trim_dollar
(
t_token
 *
curr
, int 
pos
)

48 int 
i
;

49 int 
start
;

50 char *
s
;

52 
s
 = 
NULL
;

53 
i
 = 0;

54 
start
 = 0;

55 while (
curr
->
content
[
i
])

57 if (
	`is_double_quote
(
curr
->
content
[
i
]))

59 
start
 = 
i
;

60 
i
 = 
	`loop_through
(
curr
->
content
, i);

61 if (
pos
 > 
start
 && pos < 
i
)

64 
i
++;

66 if (!
	`copy_string
(
curr
, &
s
, 
pos
))

67 return (
ERROR_EXIT
);

69 
	}
}

	@parsing/here_doc.c

12 #include 
	~"minishell.h
"

14 static void 
	$child_process_helper
(char *
key_word
, int 
flag
, int 
fd
)

16 char *
line
;

18 
line
 = 
NULL
;

21 if (
line
)

22 
	`free
(
line
);

23 
line
 = 
	`readline
("> ");

24 if (!
line
)

26 else if ((!
flag
 && \

27 
	`ft_strncmp
(
key_word
, 
line
, 
	`ft_strlen
(key_word) + 1) == 0))

29 
	`free
(
line
);

32 else if (
flag
 && 
	`ft_strncmp
(
line
, "\0", 1) == 0)

34 
	`free
(
line
);

37 
	`ft_dprintf
(
fd
, "%s\n", 
line
);

39 
	}
}

41 static void 
	$child_process
(char *
key_word
, int 
j
)

43 char *
file
;

44 int 
fd
;

45 int 
flag
;

47 
flag
 = 0;

48 if (
	`ft_strncmp
(
key_word
, "\'\'", 3) == 0 || \

49 
	`ft_strncmp
(
key_word
, "\"\"", 3) == 0)

51 
flag
 = 1;

53 
file
 = 
	`ft_strjoin
(".here_doc", 
	`ft_itoa
(
j
));

54 if (
	`access
(
file
, 
F_OK
))

55 
	`unlink
(
file
);

56 
fd
 = 
	`open
(
file
, 
O_WRONLY
 | 
O_CREAT
 | 
O_TRUNC
, 0644);

57 if (
fd
 < 0)

59 
	`ft_dprintf
(2, "minishell: open: %s\n", 
	`strerror
(
errno
));

60 
	`exit
(1);

62 
	`child_process_helper
(
key_word
, 
flag
, 
fd
);

63 
	`close
(
fd
);

64 
	}
}

66 static int 
	$write_in_heredoc
(char *
key_word
, int 
j
)

68 int 
pid
;

69 int 
status
;

71 
pid
 = 
	`fork
();

72 if (
pid
 == 0)

74 
	`here_doc_signal_handler
();

75 
	`child_process
(
key_word
, 
j
);

76 
	`parent_signal_handler
();

77 
	`exit
(0);

81 
	`signal
(
SIGINT
, 
SIG_IGN
);

82 
	`waitpid
(
pid
, &
status
, 0);

83 if (
	`WIFEXITED
(
status
) && 
	`WEXITSTATUS
(status) == 1)

85 
g_shell
->
exit_status
 = 1;

90 
	}
}

92 int 
	$here_doc
(
t_token
 **
head
)

94 
t_token
 *
token
;

95 int 
i
;

97 
i
 = 0;

98 
token
 = *
head
;

99 while (
token
)

101 if (
token
->
id
 == 
PIPELINE
)

102 
i
++;

103 if (
token
->
id
 == 
HERE_DOC
)

105 
token
 = token->
next
;

106 
	`write_in_heredoc
(
token
->
content
, 
i
);

108 
token
 = token->
next
;

111 
	}
}

	@parsing/parsing.c

12 #include 
	~"minishell.h
"

92 
t_token
 *
	$parsing
(char *
line
)

94 
t_token
 *
token
;

96 if (!
	`syntax_error_check
(
line
))

97 return (
NULL
);

98 
token
 = 
	`get_tokens
(
line
);

99 if (!
token
)

100 return (
NULL
);

101 
	`here_doc
(&
token
);

102 if (!
	`expansion
(&
token
, token, 0))

103 return (
NULL
);

104 if (!
	`quote_removing
(&
token
, token, 0))

105 return (
NULL
);

106 return (
token
);

107 
	}
}

	@parsing/quote_removing.c

12 #include 
	~"minishell.h
"

14 static int 
copy_string_unquoted
(
t_token
 *
curr
, char *
new_str
, \

15 int 
start
, int 
pos
)

17 int 
	gj
;

18 int 
	gi
;

19 int 
	gsave
;

21 
	gj
 = 0;

22 
	gi
 = 0;

23 
	gsave
 = 0;

24 while (
	gcurr
->
	gcontent
[
i
])

26 if (
	gi
 == 
start
)

27 
i
++;

28 else if (
	gi
 == 
pos
)

30 
i
++;

31 
	gsave
 = 
j
;

35 
	gnew_str
[
j
] = 
curr
->
content
[
i
];

36 
	gi
++;

37 
	gj
++;

40 
	gnew_str
[
j
] = '\0';

41 return (
	gsave
);

44 int 
	$string_replace
(
t_token
 *
curr
, int 
start
, int 
pos
)

46 int 
save
;

47 char *
new_str
;

49 
new_str
 = 
	`malloc
(sizeof(char) * (
	`ft_strlen
(
curr
->
content
) - 2 + 1));

50 if (!
new_str
)

52 
	`malloc_error_print_message
(
	`strerror
(
errno
));

53 return (
ERROR_EXIT
);

55 
save
 = 
	`copy_string_unquoted
(
curr
, 
new_str
, 
start
, 
pos
);

56 
	`free
(
curr
->
content
);

57 
curr
->
content
 = 
NULL
;

58 
curr
->
content
 = 
new_str
;

59 return (
save
);

60 
	}
}

62 int 
	$remove_q
(
t_token
 *
curr
, int 
pos
)

64 int 
start
;

66 
start
 = 
pos
;

67 
pos
 = 
	`loop_through
(
curr
->
content
, pos);

68 
pos
 = 
	`string_replace
(
curr
, 
start
, pos);

69 if (
pos
 == 
ERROR_EXIT
)

70 return (
ERROR_EXIT
);

71 return (
pos
++);

72 
	}
}

74 int 
	$quote_removing
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

76 if (!
head
 || !*head)

78 if (
curr
->
content
[
pos
] == '\0')

80 if (
curr
->
next
)

82 
pos
 = 0;

83 
curr
 = curr->
next
;

84 
	`quote_removing
(
head
, 
curr
, 
pos
);

88 else if (
	`is_quote
(
curr
->
content
[
pos
]))

90 
pos
 = 
	`remove_q
(
curr
, pos);

91 if (
pos
 == 
ERROR_EXIT
)

92 return (
	`free_token
(
head
), 0);

93 
	`quote_removing
(
head
, 
curr
, 
pos
);

97 
pos
++;

98 
	`quote_removing
(
head
, 
curr
, 
pos
);

101 
	}
}

	@parsing/syntax_errors.c

12 #include 
	~"minishell.h
"

14 int 
	$check_multiple_operators_error
(int 
i
, int 
num
, char 
c
)

16 if (
i
 > 
num
)

18 if (
	`is_chevron
(
c
))

19 
	`print_syntax_error_dchar
(
c
);

20 else if (
	`is_pipeline
(
c
))

21 
	`print_syntax_error_char
(
c
);

25 
	}
}

27 int 
	$count_metachar
(char *
s
, char 
c
, int 
num
)

29 int 
i
;

31 
i
 = 1;

32 while (
s
[
i
] && s[i] == 
c
)

33 
i
++;

34 if (!
	`check_multiple_operators_error
(
i
, 
num
, 
c
))

36 while (
s
[
i
] && 
	`is_blank
(s[i]))

37 
i
++;

38 if (
	`is_operator
(
s
[
i
]) && !
	`is_pipeline
(
c
))

40 
c
 = 
s
[
i
];

41 if (
	`is_chevron
(
c
) && is_chevron(
s
[
i
 + 1]))

42 return (
	`print_syntax_error_dchar
(
c
), 0);

44 
	`print_syntax_error_char
(
c
);

47 else if (
s
[
i
] == '\0')

48 return (
	`print_syntax_error_str
("newline"), 0);

50 
	}
}

52 int 
	$check_quotes_errors
(char *
s
, char 
c
, int *
i
)

54 int 
j
;

56 
j
 = *
i
 + 1;

57 while (
s
[
j
] && s[j] != 
c
)

58 
j
++;

59 if (
s
[
j
] != 
c
)

61 
	`print_syntax_error_char
(
c
);

64 (*
i
)++;

65 while (
s
[*
i
] && s[*i] != 
c
)

66 (*
i
)++;

68 
	}
}

70 int 
	$check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
)

72 int 
j
;

74 
j
 = 0;

75 while (
s
[
j
] && 
	`is_blank
(s[j]))

76 
j
++;

77 if (
s
[
j
] == 
c
)

79 
	`print_syntax_error_char
(
c
);

82 if (!
	`count_metachar
(&
s
[
i
], 
c
, 
num
))

85 
	}
}

132 int 
	$syntax_error_check
(char *
s
)

134 int 
i
;

136 
i
 = 0;

137 while (
s
[
i
])

139 if (
	`is_quote
(
s
[
i
]))

141 if (!
	`check_quotes_errors
(
s
, s[
i
], &i))

142 return (
	`free
(
s
), 0);

144 else if ((
	`is_lchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '<', 2)) || \

145 (
	`is_rchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '>', 2)))

146 return (
	`free
(
s
), 0);

147 else if (
	`is_pipeline
(
s
[
i
]) && !
	`check_pipeline_errors
(s, i, '|', 1))

148 return (
	`free
(
s
), 0);

149 
i
++;

152 
	}
}

	@parsing/syntax_errors_print_message.c

12 #include 
	~"minishell.h
"

19 void 
	$print_syntax_error_char
(char 
c
)

21 
	`ft_dprintf
(2, "minishell: ");

22 
	`ft_dprintf
(2, "syntax error near unexpected token ");

23 
	`ft_dprintf
(2, "\'%c\'\n", 
c
);

24 
g_shell
->
exit_status
 = 258;

25 
	}
}

27 void 
	$print_syntax_error_dchar
(char 
c
)

29 
	`ft_dprintf
(2, "minishell: ");

30 
	`ft_dprintf
(2, "syntax error near unexpected token ");

31 
	`ft_dprintf
(2, "\'%c%c\'\n", 
c
, c);

32 
g_shell
->
exit_status
 = 258;

33 
	}
}

35 void 
	$print_syntax_error_str
(char *
s
)

37 
	`ft_dprintf
(2, "minishell: ");

38 
	`ft_dprintf
(2, "syntax error near unexpected token ");

39 
	`ft_dprintf
(2, "\'%s\'\n", 
s
);

40 
g_shell
->
exit_status
 = 258;

41 
	}
}

	@parsing/token_extraction.c

12 #include 
	~"minishell.h
"

21 int 
	$character_extraction
(char *
line
, int 
ind
)

23 if ((
line
[
ind
] == '>' && line[ind + 1] == '>') || \

24 (
line
[
ind
] == '<' && line[ind + 1] == '<'))

27 
	}
}

43 int 
	$word_extraction
(char *
line
, int 
ind
)

45 int 
start
;

46 char 
c
;

48 
start
 = 
ind
;

49 while (
	`is_word
(
line
[
ind
]) && line[ind])

51 if (
	`is_quote
(
line
[
ind
]))

53 
c
 = 
line
[
ind
];

54 
ind
++;

55 while (
line
[
ind
] && line[ind] != 
c
)

56 
ind
++;

58 
ind
++;

60 return (
ind
 - 
start
);

61 
	}
}

64 int 
	$get_tokens_size
(char *
line
, int *
i
)

66 int 
len
;

68 
len
 = 0;

69 while (
	`is_blank
(
line
[*
i
]))

70 (*
i
)++;

71 if (
	`is_word
(
line
[*
i
]))

72 
len
 = 
	`word_extraction
(
line
, *
i
);

73 else if (
	`is_operator
(
line
[*
i
]))

74 
len
 = 
	`character_extraction
(
line
, *
i
);

75 return (
len
);

76 
	}
}

83 
t_token
 *
	$create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
)

85 
t_token
 *
head
;

87 
head
 = 
	`new_token
(
line
, 
i
, 
len
);

88 if (!
head
)

89 return (
NULL
);

90 *
flag
 = 1;

91 
head
->
pos
 = 0;

92 
	`set_id
(&
head
, head);

93 return (
head
);

94 
	}
}

124 
t_token
 *
	$get_tokens
(char *
line
)

126 int 
i
;

127 int 
len
;

128 int 
flag
;

129 
t_token
 *
head
;

131 
i
 = 0;

132 
flag
 = 0;

133 
head
 = 
NULL
;

134 while (
line
[
i
])

136 
len
 = 
	`get_tokens_size
(
line
, &
i
);

137 if (
len
 == 0)

139 if (!
flag
)

141 
head
 = 
	`create_token_head
(
line
, 
i
, 
len
, &
flag
);

142 if (!
head
)

143 return (
	`free
(
line
), 
NULL
);

146 if (!
	`token_linked_list
(&
head
, 
line
, 
i
, 
len
))

147 return (
	`free_token
(&
head
), 
	`free
(
line
), 
NULL
);

148 
i
 += 
len
;

150 return (
	`free
(
line
), 
head
);

151 
	}
}

	@redirections/do_redirections.c

12 #include 
	~"minishell.h
"

14 int 
	$redir_fdin
(
t_cmd
 *
cmd
, char *
redir_op
, char *
file_path
, int 
j
)

16 char *
here_doc_file
;

18 if (
cmd
->
save_fdin
 != -1 || cmd->
ffd_in
 != -1)

19 
	`restaure_fds
(
cmd
, 1);

20 if (
	`ft_strlen
(
redir_op
) == 1 && 
file_path
)

21 
cmd
->
ffd_in
 = 
	`open
(
file_path
, 
O_RDONLY
);

24 
here_doc_file
 = 
	`ft_strjoin
(".here_doc", 
	`ft_itoa
(
j
));

25 if (!
here_doc_file
)

27 
cmd
->
ffd_in
 = 
	`open
(
here_doc_file
, 
O_RDONLY
);

29 
cmd
->
save_fdin
 = 
	`dup
(
STDIN_FILENO
);

30 if (
cmd
->
ffd_in
 < 0)

32 
	`ft_dprintf
(2, "minishell: open: %s\n", 
	`strerror
(
errno
));

33 
g_shell
->
exit_status
 = 1;

36 
	`dup2
(
cmd
->
ffd_in
, 
STDIN_FILENO
);

37 
	`close
(
cmd
->
ffd_in
);

38 
cmd
->
ffd_in
 = -1;

40 
	}
}

42 int 
	$redir_fdout
(
t_cmd
 *
cmd
, char *
redir_op
, char *
file_path
)

44 if (
cmd
->
save_fdout
 != -1 || cmd->
ffd_out
 != -1)

45 
	`restaure_fds
(
cmd
, 1);

46 
cmd
->
save_fdout
 = 
	`dup
(
STDOUT_FILENO
);

47 if (
	`ft_strlen
(
redir_op
) == 1)

48 
cmd
->
ffd_out
 = 
	`open
(
file_path
, 
O_WRONLY
 | 
O_CREAT
 | 
O_TRUNC
, 0644);

50 
cmd
->
ffd_out
 = 
	`open
(
file_path
, 
O_WRONLY
 | 
O_CREAT
 | 
O_APPEND
, 0644);

51 if (
cmd
->
ffd_out
 < 0)

53 
	`ft_dprintf
(2, "minishell: open: %s\n", 
	`strerror
(
errno
));

54 
g_shell
->
exit_status
 = 1;

57 
	`dup2
(
cmd
->
ffd_out
, 
STDOUT_FILENO
);

58 
	`close
(
cmd
->
ffd_out
);

59 
cmd
->
ffd_out
 = -1;

61 
	}
}

	@redirections/loop_redirections.c

12 #include 
	~"minishell.h
"

14 void 
	$restaure_fds_helper
(int 
i
)

16 char *
file
;

17 char *
nb
;

19 
nb
 = 
	`ft_itoa
(
i
);

20 if (!
nb
)

21 
	`ft_dprintf
(2, "minishell: ft_itoa failed\n");

22 
file
 = 
	`ft_strjoin
(".here_doc", 
nb
);

23 if (!
file
)

24 
	`ft_dprintf
(2, "minishell: ft_strjoin failed\n");

25 if (!
file
 || !
nb
)

27 if (
file
)

28 
	`free
(
file
);

29 if (
nb
)

30 
	`free
(
nb
);

33 if (
	`access
(
file
, 
F_OK
) == 0)

34 
	`unlink
(
file
);

35 
	`free
(
file
);

36 
	`free
(
nb
);

37 
	}
}

39 void 
	$restaure_fds
(
t_cmd
 *
cmd
, int 
i
)

41 if (
cmd
->
save_fdout
 != -1)

43 
	`dup2
(
cmd
->
save_fdout
, 
STDOUT_FILENO
);

44 
	`close
(
cmd
->
save_fdout
);

45 
cmd
->
save_fdout
 = -1;

47 if (
cmd
->
save_fdin
 != -1)

49 
	`dup2
(
cmd
->
save_fdin
, 
STDIN_FILENO
);

50 
	`close
(
cmd
->
save_fdin
);

51 
cmd
->
save_fdin
 = -1;

53 
	`restaure_fds_helper
(
i
);

54 
	}
}

56 static int 
	$make_redirections_helper
(
t_cmd
 *
cmd
, int 
j
, int 
i
)

58 if (
	`ft_strncmp
(
cmd
->
redir
[
i
], ">", 2) == 0 || \

59 
	`ft_strncmp
(
cmd
->
redir
[
i
], ">>", 3) == 0)

61 if (!
	`redir_fdout
(
cmd
, cmd->
redir
[
i
], cmd->redir[i + 1]))

63 
i
++;

65 else if (
	`ft_strncmp
(
cmd
->
redir
[
i
], "<", 2) == 0)

67 if (!
	`redir_fdin
(
cmd
, cmd->
redir
[
i
], cmd->redir[i + 1], 
j
))

69 
i
++;

71 else if (
	`ft_strncmp
(
cmd
->
redir
[
i
], "<<", 3) == 0)

73 if (!
	`redir_fdin
(
cmd
, cmd->
redir
[
i
], 
NULL
, 
j
))

75 if (
cmd
->
redir
[
i
 + 1])

76 
i
++;

77 
i
++;

79 return (
i
);

80 
	}
}

82 int 
	$make_redirections
(
t_cmd
 *
cmd
, int 
j
)

84 int 
i
;

86 
i
 = 0;

87 if (!
cmd
->
redir
)

89 while (
cmd
->
redir
[
i
])

91 if (
	`ft_strncmp
(
cmd
->
redir
[
i
], ">", 2) == 0 || \

92 
	`ft_strncmp
(
cmd
->
redir
[
i
], ">>", 3) == 0 || \

93 
	`ft_strncmp
(
cmd
->
redir
[
i
], "<", 2) == 0 || \

94 
	`ft_strncmp
(
cmd
->
redir
[
i
], "<<", 3) == 0)

96 
i
 = 
	`make_redirections_helper
(
cmd
, 
j
, i);

97 if (
i
 == -1)

101 
i
++;

104 
	}
}

	@signal_handler/init_sigset.c

12 #include 
	~"minishell.h
"

14 void 
	$init_sigset
(
sigset_t
 *
set
)

16 
	`sigemptyset
(
set
);

17 
	`sigaddset
(
set
, 
SIGINT
);

18 
	`sigaddset
(
set
, 
SIGQUIT
);

19 
	`sigaddset
(
set
, 
SIGTERM
);

20 
	`sigaddset
(
set
, 
SIGTSTP
);

21 
	`sigaddset
(
set
, 
SIGKILL
);

22 
	}
}

	@signal_handler/pipex_handler.c

12 #include 
	~"minishell.h
"

14 static void 
	$pipex_handler
(int 
sig_code
)

16 (void)
sig_code
;

18 
	}
}

20 void 
	$pipex_signal_handler
(void)

22 struct 
sigaction
 
act
;

24 
	`ft_memset
(&
act
, 0, sizeof(struct 
sigaction
));

25 
	`init_sigset
(&
act
.
sa_mask
);

26 
act
.
sa_handler
 = 
SIG_DFL
;

27 
	`sigaction
(
SIGTERM
, &
act
, 0);

28 
	`sigaction
(
SIGKILL
, &
act
, 0);

29 
act
.
sa_handler
 = 
pipex_handler
;

30 
	`sigaction
(
SIGQUIT
, &
act
, 0);

31 
	`sigaction
(
SIGINT
, &
act
, 0);

32 
	}
}

	@signal_handler/signal_handlers.c

12 #include 
	~"minishell.h
"

24 static void 
	$handler
(int 
sig_code
)

26 if (
sig_code
 == 
SIGINT
)

28 
	`printf
("\n");

29 
g_shell
->
exit_status
 = 1;

30 
	`rl_replace_line
("", 0);

31 
	`rl_on_new_line
();

32 
	`rl_redisplay
();

34 
	}
}

36 void 
	$here_doc_handler
(int 
sig_code
)

38 (void)
sig_code
;

39 
	`ft_printf
("> \n");

40 
	`exit
(1);

41 
	}
}

43 void 
	$here_doc_signal_handler
(void)

45 struct 
sigaction
 
act
;

47 
	`ft_memset
(&
act
, 0, sizeof(struct 
sigaction
));

48 
	`init_sigset
(&
act
.
sa_mask
);

49 
act
.
sa_handler
 = 
SIG_IGN
;

50 
	`sigaction
(
SIGQUIT
, &
act
, 0);

51 
	`sigaction
(
SIGTSTP
, &
act
, 0);

52 
act
.
sa_handler
 = 
here_doc_handler
;

53 
	`sigaction
(
SIGINT
, &
act
, 0);

54 
	}
}

56 void 
	$child_signal_handler
(void)

58 struct 
sigaction
 
act
;

60 
	`ft_memset
(&
act
, 0, sizeof(struct 
sigaction
));

61 
	`init_sigset
(&
act
.
sa_mask
);

62 
act
.
sa_handler
 = 
SIG_DFL
;

63 
	`sigaction
(
SIGQUIT
, &
act
, 0);

64 
	`sigaction
(
SIGINT
, &
act
, 0);

65 
	`sigaction
(
SIGTERM
, &
act
, 0);

66 
	`sigaction
(
SIGKILL
, &
act
, 0);

67 
	}
}

69 void 
	$parent_signal_handler
(void)

71 struct 
sigaction
 
act
;

73 
	`ft_memset
(&
act
, 0, sizeof(struct 
sigaction
));

74 
	`init_sigset
(&
act
.
sa_mask
);

75 
act
.
sa_handler
 = 
SIG_IGN
;

76 
	`sigaction
(
SIGQUIT
, &
act
, 0);

77 
	`sigaction
(
SIGTERM
, &
act
, 0);

78 
	`sigaction
(
SIGTSTP
, &
act
, 0);

79 
act
.
sa_handler
 = 
handler
;

80 
	`sigaction
(
SIGINT
, &
act
, 0);

81 
	}
}

	@tester/test_files/loop.c

13 #include 
	~<fcntl.h
>

14 #include 
	~<stdio.h
>

15 #include 
	~<unistd.h
>

17 int 
	$main
(int 
argc
, char const *
argv
[])

19 int 
pid
;

21 
pid
 = 
	`fork
();

22 
	`open
("infile", 
O_RDONLY
);

25 
	`printf
("Helloo miniHELL %i\n", 
pid
);

26 
	`sleep
(1);

29 
	}
}

	@tokens/token_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_token
(
t_token
 **
head
)

16 
t_token
 *
ptr
;

17 
t_token
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
content
);

27 
	`free
(
tmp
);

29 *
head
 = 
NULL
;

30 
head
 = 
NULL
;

31 
	}
}

46 
t_token
 *
	$new_token
(char *
line
, int 
start
, int 
len
)

48 
t_token
 *
token
;

50 
token
 = 
NULL
;

51 
token
 = 
	`malloc
(sizeof(
t_token
));

52 if (!
token
)

54 
	`malloc_error_print_message
(
	`strerror
(
errno
));

55 return (
NULL
);

57 
token
->
content
 = 
	`ft_substr
(
line
, 
start
, 
len
);

58 if (!
token
->
content
)

60 
	`malloc_error_print_message
(
	`strerror
(
errno
));

61 return (
	`free_token
(&
token
), 
NULL
);

63 
token
->
next
 = 
NULL
;

64 return (
token
);

65 
	}
}

74 int 
	$link_token
(
t_token
 **
head
, t_token *
new
)

76 
t_token
 *
ptr
;

77 int 
pos
;

79 
pos
 = 0;

80 if (!
new
)

82 
ptr
 = *
head
;

83 while (
ptr
)

85 if (!
ptr
->
next
)

87 
ptr
 = ptr->
next
;

88 
pos
++;

90 
ptr
->
next
 = 
new
;

91 
new
->
pos
 = pos;

92 
	`set_id
(
head
, 
new
);

94 
	}
}

117 int 
	$token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
)

119 
t_token
 *
new
;

121 if (!
head
)

123 
new
 = 
	`new_token
(
line
, 
start
, 
len
);

124 if (!
new
)

126 if (!
	`link_token
(
head
, 
new
))

129 
	}
}

	@tokens/token_routine_delete.c

12 #include 
	~"minishell.h
"

14 int 
	$token_list_size
(
t_token
 **
head
)

16 
t_token
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

29 static 
t_token
 *
delete_helper
(t_token **
head
, t_token *
curr
, \

30 
t_token
 *
prev
, int 
i
)

32 int 
	gsize
;

34 
	gsize
 = 
token_list_size
(
head
);

35 if (
	gi
 == 0 && 
size
 == 1)

37 
free
(
curr
->
content
);

38 
free
(
curr
);

39 *
	ghead
 = 
NULL
;

40 return (*
	ghead
);

42 else if (
	gi
 == 0 && 
size
 > 1)

44 *
head
 = 
curr
->
next
;

45 
	gprev
 = *
head
;

47 else if (
	gi
 == 
size
 - 1)

48 
prev
->
next
 = 
NULL
;

50 
	gprev
->
	gnext
 = 
curr
->
next
;

51 
free
(
curr
->
content
);

52 
free
(
curr
);

53 
	gcurr
 = 
NULL
;

54 return (
	gprev
);

57 
t_token
 *
	$delete_token
(
t_token
 **
head
)

59 int 
i
;

60 
t_token
 *
curr
;

61 
t_token
 *
prev
;

63 
i
 = 0;

64 
curr
 = *
head
;

65 
prev
 = 
NULL
;

66 while (
curr
->
id
 != 
DELETE
)

68 
prev
 = 
curr
;

69 
curr
 = curr->
next
;

70 
i
++;

72 return (
	`delete_helper
(
head
, 
curr
, 
prev
, 
i
));

73 
	}
}

	@tokens/token_routine_set_id.c

12 #include 
	~"minishell.h
"

14 int 
	$set_id_expansion
(
t_token
 *
token
)

16 if (
	`ft_strchr
(
token
->
content
, '$'))

17 return (
DOLLAR
);

18 return (
WORD
);

19 
	}
}

21 int 
	$check_for_heredoc
(
t_token
 **
head
, int 
pos
)

23 
t_token
 *
token
;

24 
t_token
 *
prev
;

26 if (!
head
 || !*head || 
pos
 == 0)

28 
token
 = *
head
;

29 
prev
 = 
NULL
;

30 while (
token
)

32 if (
prev
 && prev->
pos
 == pos)

34 if (
token
->
next
 != 
NULL
)

35 
prev
 = 
token
;

36 
token
 = token->
next
;

38 if (
prev
->
id
 == 
HERE_DOC
)

41 
	}
}

43 void 
	$set_id
(
t_token
 **
head
, t_token *
token
)

45 int 
res
;

47 
res
 = 0;

48 
res
 = 
	`check_for_heredoc
(
head
, 
token
->
pos
);

49 if (
	`ft_strncmp
(
token
->
content
, "|", 2) == 0)

50 
token
->
id
 = 
PIPELINE
;

51 else if (
	`ft_strncmp
(
token
->
content
, "<", 2) == 0)

52 
token
->
id
 = 
L_CHEVRON
;

53 else if (
	`ft_strncmp
(
token
->
content
, ">", 2) == 0)

54 
token
->
id
 = 
R_CHEVRON
;

55 else if (
	`ft_strncmp
(
token
->
content
, "<<", 3) == 0)

56 
token
->
id
 = 
HERE_DOC
;

57 else if (
	`ft_strncmp
(
token
->
content
, ">>", 3) == 0)

58 
token
->
id
 = 
APPEND
;

59 else if (
	`ft_strchr
(
token
->
content
, '$'))

60 
token
->
id
 = 
DOLLAR
;

63 if (!
res
)

64 
token
->
id
 = 
WORD
;

66 
token
->
id
 = 
KEY_WORD
;

69 
	}
}

	@utils.c

12 #include 
	~"minishell.h
"

14 void 
	$free_before_exit
(
t_cmd
 **
head
)

16 
	`free_shell
();

17 
	`free_cmd
(
head
);

18 
	}
}

20 int 
	$size_tab2d
(char **
s
)

22 int 
i
;

24 
i
 = 0;

25 while (
s
[
i
])

26 
i
++;

27 return (
i
);

28 
	}
}

30 void 
	$free_and_exit_prog
(
t_cmd
 **
head
, int 
exit_code
)

32 
	`free_cmd
(
head
);

33 
	`free_shell
();

34 
	`exit
 (
exit_code
);

35 
	}
}

	@
1
.
0
132
3447
builtins/cd.c
builtins/echo.c
builtins/env.c
builtins/exit.c
builtins/export.c
builtins/export_unset_helper.c
builtins/int_min_max.c
builtins/pwd.c
builtins/unset.c
command_struct/free_cmd.c
command_struct/init_cmd.c
command_struct/init_cmd_cmd.c
command_struct/init_cmd_redir.c
environnement/envp_routine.c
environnement/get_env.c
environnement/pipex_helper.c
execution/copy_env_tab.c
execution/exec_bin.c
execution/exec_builtins.c
execution/exec_one_cmd.c
execution/execution.c
execution/get_path.c
execution/pipex.c
execution/pipex_helper.c
execution/search_path_in_env_table.c
global_variable/init_global.c
is_smth/is_dollar.c
is_smth/is_numeric.c
is_smth/is_operator.c
is_smth/is_question.c
is_smth/is_quote.c
is_smth/is_token.c
is_smth/is_white_space.c
libft/ft_printf/ft_count_int.c
libft/ft_printf/ft_count_unsigned_int.c
libft/ft_printf/ft_dprintf.c
libft/ft_printf/ft_printf.c
libft/ft_printf/ft_printf_address.c
libft/ft_printf/ft_printf_char.c
libft/ft_printf/ft_printf_hexa.c
libft/ft_printf/ft_printf_int.c
libft/ft_printf/ft_printf_str.c
libft/ft_printf/ft_printf_unsint.c
libft/ft_printf/ft_put_hexanbr_fd.c
libft/ft_printf/ft_put_int.c
libft/ft_printf/ft_put_unsnbr_fd.c
libft/get_next_line/get_next_line.c
libft/get_next_line/get_next_line_bonus.c
libft/get_next_line/get_next_line_utils.c
libft/includes/ft_printf.h
libft/includes/get_next_line.h
libft/includes/libft.h
libft/libft/del.c
libft/libft/ft_atoi.c
libft/libft/ft_atoi_base.c
libft/libft/ft_bzero.c
libft/libft/ft_calloc.c
libft/libft/ft_isalnum.c
libft/libft/ft_isalpha.c
libft/libft/ft_isascii.c
libft/libft/ft_isdigit.c
libft/libft/ft_isprint.c
libft/libft/ft_itoa.c
libft/libft/ft_lstadd_back.c
libft/libft/ft_lstadd_front.c
libft/libft/ft_lstclear.c
libft/libft/ft_lstdel_first_el.c
libft/libft/ft_lstdel_last_el.c
libft/libft/ft_lstdelone.c
libft/libft/ft_lstiter.c
libft/libft/ft_lstlast.c
libft/libft/ft_lstmap.c
libft/libft/ft_lstnew.c
libft/libft/ft_lstsize.c
libft/libft/ft_memchr.c
libft/libft/ft_memcmp.c
libft/libft/ft_memcpy.c
libft/libft/ft_memmove.c
libft/libft/ft_memset.c
libft/libft/ft_putchar_fd.c
libft/libft/ft_putendl_fd.c
libft/libft/ft_putnbr_fd.c
libft/libft/ft_putstr_fd.c
libft/libft/ft_split.c
libft/libft/ft_strchr.c
libft/libft/ft_strcpy.c
libft/libft/ft_strcspn.c
libft/libft/ft_strdup.c
libft/libft/ft_striteri.c
libft/libft/ft_strjoin.c
libft/libft/ft_strlcat.c
libft/libft/ft_strlcpy.c
libft/libft/ft_strlen.c
libft/libft/ft_strmapi.c
libft/libft/ft_strncmp.c
libft/libft/ft_strncpy.c
libft/libft/ft_strnstr.c
libft/libft/ft_strpbrk.c
libft/libft/ft_strrchr.c
libft/libft/ft_strspn.c
libft/libft/ft_strtrim.c
libft/libft/ft_substr.c
libft/libft/ft_tolower.c
libft/libft/ft_toupper.c
libft/libft/power.c
libft/libft/str_lowercase.c
main.c
malloc_error/malloc_error_print_message.c
minishell.h
parsing/expansion.c
parsing/expansion_dollar_conditions.c
parsing/expansion_expand_var_helper.c
parsing/expansion_helper.c
parsing/expansion_join_tokens.c
parsing/expansion_looping.c
parsing/expansion_trim_dollar.c
parsing/here_doc.c
parsing/parsing.c
parsing/quote_removing.c
parsing/syntax_errors.c
parsing/syntax_errors_print_message.c
parsing/token_extraction.c
redirections/do_redirections.c
redirections/loop_redirections.c
signal_handler/init_sigset.c
signal_handler/pipex_handler.c
signal_handler/signal_handlers.c
tester/test_files/loop.c
tokens/token_routine.c
tokens/token_routine_delete.c
tokens/token_routine_set_id.c
utils.c
