cscope 15 $HOME/Documents/GitHub/minishell/rita -c -q 0000000366 0000133979
	@builtins.c

13 #include 
	~"minishell.h
"

15 int 
	$_pwd
(
t_cmd
 *
cmd
)

17 char *
cwd
;

22 
cwd
 = 
	`getcwd
(
NULL
, 0);

23 
	`ft_putstr_fd
(
cwd
, 1);

24 
	`ft_putstr_fd
("\n", 
cmd
->
fdout
);

25 
	`free
(
cwd
);

27 
	}
}

37 int 
	$_env
(
t_env
 *
env
)

39 if (!
env
)

41 while (
env
 != 
NULL
)

43 
	`printf
("%s=", 
env
->
var_name
);

44 
	`printf
("%s\n", 
env
->
var_value
);

45 
env
 = env->
next
;

48 
	}
}

	@cmd_is_bin.c

1 #include 
	~"minishell.h
"

3 int 
	$path_line_index
(
t_env
 *
env
)

5 int 
i
;

7 
i
 = 0;

8 while (
env
->
var_name
 != 
NULL
)

10 if (
	`ft_strncmp
("PATH=", 
env
->
var_name
, 5) == 0)

12 
i
++;

13 
env
->
var_name
 = env->
next
;

15 return (
i
);

16 
	}
}

18 
t_env
 *
	$path_value
(
t_env
 *
env
, int 
nb
)

20 int 
i
;

22 
i
 = 0;

23 while (
env
->
var_value
 && 
i
 != 
nb
)

25 
env
->
var_value
 = env->
next
;

26 
i
++;

28 return (
env
->
var_value
);

29 
	}
}

31 char **
	$split_var_value
(char *
value
)

33 char **
paths
;

34 char *
temp_path
;

35 int 
j
;

37 
paths
 = 
	`ft_split
(
value
, ':');

38 if (!
paths
)

40 
j
 = 0;

41 while (
paths
[
j
])

43 
temp_path
 = 
	`ft_strjoin
(
paths
[
j
], "/");

44 if (!
temp_paths
)

46 
	`free
(
paths
[
j
]);

47 
paths
[
j
] = 
temp_path
;

48 
j
++;

50 return (
paths
);

51 
	}
}

53 int 
	$find_cmd_bin
(char **
paths
, 
t_env
 *
env
, 
t_token
 *
token
)

55 int 
j
;

56 int 
ok
;

57 char *
cmd
;

59 
j
 = 0;

60 while (
paths
[
j
])

62 
cmd
 = 
	`ft_strjoin
(
paths
[
j
], 
token
->
content
);

63 if (!
cmd
)

65 
ok
 = 
	`access
(
cmd
, 
F_OK
 & 
X_OK
);

66 if (
ok
 == 0)

68 
	`free
(
cmd
);

69 
j
++;

71 if (
ok
 == -1)

74 
	}
}

76 int 
	$bin_access
(
t_token
 *
token
)

78 int 
nb
;

79 char *
value
;

80 char **
bins
;

82 if (
token
->
id
 == 
WORD
)

84 
nb
 = 
	`path_line_index
(
g_shell
->
env
);

85 
value
 = 
	`path_value
(
g_shell
->
env
, 
nb
);

86 
bins
 = 
	`split_var_value
(
value
);

87 if (!
	`find_cmd_bin
(
bins
, 
g_shell
->
env
, g_shell->
token
))

91 
	}
}

	@cmd_is_builtin.c

1 #include 
	~"minishell.h
"

3 int 
	$is_built_in
(
t_token
 *
token
)

5 if (
token
->
id
 == 
WORD
)

7 if (
	`ft_strncmp
("echo", 
content
, 4))

9 if (
	`ft_strncmp
("cd", 
content
, 2))

11 if (
	`ft_strncmp
("pwd", 
content
, 3))

13 if (
	`ft_strncmp
("export", 
content
, 5))

15 if (
	`ft_strncmp
("unset", 
content
, 5))

17 if (
	`ft_strncmp
("env", 
content
, 3))

19 if (
	`ft_strncmp
("exit", 
content
, 4))

23 
	}
}

	@complicated_split.c

13 #include 
	~"minishell.h
"

15 static int 
	$ft_n_words
(char *
str
, char 
c
, int 
count
)

17 while (*
str
)

19 if (*
str
 != 
c
)

21 if (*
str
 == '\'' && str++)

23 
count
++;

24 while (*
str
 && *str != '\'')

25 
str
++;

26 
str
++;

30 
count
++;

31 while (*
str
 && *str != 
c
)

32 
str
++;

36 
str
++;

38 return (
count
);

39 
	}
}

41 static int *
	$ft_len_strs
(char *
str
, char 
c
, int 
count
, int 
index
)

43 int *
len_strs
;

44 int 
len
;

46 
len_strs
 = 
	`malloc
(sizeof(int) * 
count
);

47 if (
len_strs
 == 0)

49 while (*
str
)

51 
len
 = 0;

52 if (*
str
 == '\'' && str++)

53 while (*
str
 != '\'' && ++
len
)

54 
str
++;

56 while (*
str
 && *str != 
c
 && ++
len
)

57 
str
++;

58 if (*
str
 == '\'')

59 
str
++;

60 if (*
str
 == 
c
)

61 
str
++;

62 
len_strs
[
index
++] = 
len
 + 1;

64 return (
len_strs
);

65 
	}
}

67 static char **
	$ft_free_split
(char **
dst
, 
size_t
 
i
)

69 
size_t
 
k
;

71 
k
 = 0;

72 while (
k
 < 
i
)

73 
	`free
(
dst
[
k
++]);

74 
	`free
(
dst
);

75 return (
NULL
);

76 
	}
}

78 static char **
	$ft_fill_big_table
(char *
src
, char 
c
, char **
dst
, int *
lens
)

80 int 
j
;

81 int 
count
;

83 
count
 = 0;

84 while (*
src
)

86 
dst
[
count
] = 
	`malloc
(sizeof(char) * 
lens
[count]);

87 if (
dst
[
count
] == 
NULL
)

88 return (
	`ft_free_split
(
dst
, 
count
));

89 
j
 = 0;

90 if (*
src
 == '\'' && src++)

91 while (*
src
 != '\'')

92 
dst
[
count
][
j
++] = *
src
++;

94 while (*
src
 && *src != 
c
)

95 
dst
[
count
][
j
++] = *
src
++;

96 
dst
[
count
++][
j
] = '\0';

97 if (*
src
 == '\'')

98 
src
++;

99 if (*
src
 == 
c
)

100 
src
++;

102 
dst
[
count
] = 
NULL
;

103 
	`free
(
lens
);

104 return (
dst
);

105 
	}
}

107 char **
	$ft_splitpath
(char *
s
, char 
c
)

109 char **
dst
;

110 int *
lens
;

111 int 
count
;

112 int 
index
;

114 
index
 = 0;

115 
count
 = 
	`ft_n_words
(
s
, 
c
, 0);

116 
lens
 = 
	`ft_len_strs
(
s
, 
c
, 
count
, 
index
);

117 
dst
 = 
	`malloc
(sizeof(char *) * (
count
 + 1));

118 if (
dst
 == 
NULL
)

119 return (
NULL
);

120 return (
	`ft_fill_big_table
(
s
, 
c
, 
dst
, 
lens
));

121 
	}
}

	@env_copied.c

12 #include 
	~"minishell.h
"

19 void 
	$free_tab
(char **
table
)

21 int 
i
;

23 
i
 = 0;

24 if (!
table
)

26 while (
table
 && table[
i
])

27 
	`free
(
table
[
i
++]);

28 
	`free
(
table
);

29 
	}
}

31 char *
	$malloc_strcpy
(char *
envp
)

33 
size_t
 
i
;

34 char *
str
;

36 
str
 = 
	`malloc
(sizeof(char) * (
	`ft_strlen
(
envp
) + 1));

37 if (!
str
)

39 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

40 return (
NULL
);

42 
i
 = 0;

43 while (
envp
[
i
])

45 
str
[
i
] = 
envp
[i];

46 
i
++;

48 
str
[
i
] = '\0';

49 return (
str
);

50 
	}
}

52 
size_t
 
	$col_count
(char **
table
)

54 
size_t
 
len
;

56 
len
 = 0;

57 while (
table
[
len
])

58 
len
++;

59 return (
len
);

60 
	}
}

73 char **
	$env_copied
(char **
envp
)

75 
size_t
 
i
;

76 
size_t
 
len
;

77 char **
env_copied
;

79 
i
 = 0;

80 
len
 = 
	`col_count
(
envp
);

81 
env_copied
 = 
	`malloc
(sizeof(char *) * (
len
 + 1));

82 if (!
env_copied
)

84 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

85 return (
	`free_tab
(
env_copied
), 
NULL
);

87 while (
envp
[
i
])

89 
env_copied
[
i
] = 
	`malloc_strcpy
(
envp
[i]);

90 if (!
env_copied
[
i
])

91 return (
	`free_tab
(
env_copied
), 
NULL
);

92 
i
++;

94 
env_copied
[
i
] = 
NULL
;

95 return (
env_copied
);

96 
	}
}

	@envp_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_env
(
t_env
 **
head
)

16 
t_env
 *
ptr
;

17 
t_env
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
var_name
);

27 
	`free
(
tmp
->
var_value
);

28 
	`free
(
tmp
);

30 *
head
 = 
NULL
;

31 
	}
}

40 
t_env
 *
	$new_env
(char *
envp
)

42 
t_env
 *
env
;

43 int 
end
;

44 int 
start
;

46 if (!
envp
)

47 return (
NULL
);

48 
start
 = 0;

49 
end
 = 0;

50 
env
 = 
	`malloc
(sizeof(
t_env
));

51 if (!
env
)

53 
	`malloc_error_print_message
(
	`strerror
(
errno
));

54 return (
NULL
);

56 while (
envp
[
end
] != '=')

57 
end
++;

58 
env
->
var_name
 = 
	`ft_substr
(
envp
, 0, 
end
);

59 if (!
env
->
var_name
)

60 return (
NULL
);

61 
end
++;

62 
start
 = 
end
;

63 while (
envp
[
end
] != '\0')

64 
end
++;

65 
env
->
var_value
 = 
	`ft_substr
(
envp
, 
start
, 
end
 - start);

66 if (!
env
->
var_value
)

67 return (
NULL
);

68 
env
->
next
 = 
NULL
;

69 return (
env
);

70 
	}
}

75 int 
	$link_env
(
t_env
 **
head
, t_env *
last
)

77 
t_env
 *
ptr
;

79 if (!
last
)

81 
ptr
 = *
head
;

82 while (
ptr
)

84 if (!
ptr
->
next
)

86 
ptr
 = ptr->
next
;

88 
ptr
->
next
 = 
last
;

90 
	}
}

103 
t_env
 *
	$get_envp
(char **
envp
)

105 
t_env
 **
head
;

106 
t_env
 *
env
;

107 int 
i
;

109 
i
 = 0;

110 
head
 = 
NULL
;

111 if (!
envp
)

112 return (
NULL
);

113 
env
 = 
	`new_env
(
envp
[
i
]);

114 if (!
env
)

115 return (
NULL
);

116 
head
 = &
env
;

117 
i
++;

118 while (
envp
[
i
])

120 if (
	`link_env
(
head
, 
	`new_env
(
envp
[
i
])) < 0)

121 return (
	`free_env
(
head
), 
NULL
);

122 
i
++;

124 return (*
head
);

125 
	}
}

	@envp_routine_shlvl.c

12 #include 
	~"minishell.h
"

14 void 
	$envp_routine_shlvl
(void)

16 
t_env
 *
tmp
;

18 
tmp
 = *
head
;

21 
	}
}

	@expansion_test/envp_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_env
(
t_env
 **
head
)

16 
t_env
 *
ptr
;

17 
t_env
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
var_name
);

27 
	`free
(
tmp
->
var_value
);

28 
	`free
(
tmp
);

30 *
head
 = 
NULL
;

31 
	}
}

40 
t_env
 *
	$new_env
(char *
envp
)

42 
t_env
 *
env
;

43 int 
end
;

44 int 
start
;

46 if (!
envp
)

47 return (
NULL
);

48 
start
 = 0;

49 
end
 = 0;

50 
env
 = 
	`malloc
(sizeof(
t_env
));

51 if (!
env
)

53 
	`malloc_error_print_message
(
	`strerror
(
errno
));

54 return (
NULL
);

56 while (
envp
[
end
] != '=')

57 
end
++;

58 
env
->
var_name
 = 
	`ft_substr
(
envp
, 0, 
end
);

59 if (!
env
->
var_name
)

60 return (
NULL
);

61 
end
++;

62 
start
 = 
end
;

63 while (
envp
[
end
] != '\0')

64 
end
++;

65 
env
->
var_value
 = 
	`ft_substr
(
envp
, 
start
, 
end
 - start);

66 if (!
env
->
var_value
)

67 return (
NULL
);

68 
env
->
next
 = 
NULL
;

69 return (
env
);

70 
	}
}

75 int 
	$link_env
(
t_env
 **
head
, t_env *
last
)

77 
t_env
 *
ptr
;

79 if (!
last
)

81 
ptr
 = *
head
;

82 while (
ptr
)

84 if (!
ptr
->
next
)

86 
ptr
 = ptr->
next
;

88 
ptr
->
next
 = 
last
;

90 
	}
}

103 
t_env
 *
	$get_envp
(char **
envp
)

105 
t_env
 **
head
;

106 
t_env
 *
env
;

107 int 
i
;

109 
i
 = 0;

110 
head
 = 
NULL
;

111 if (!
envp
)

112 return (
NULL
);

113 
env
 = 
	`new_env
(
envp
[
i
]);

114 if (!
env
)

115 return (
NULL
);

116 
head
 = &
env
;

117 
i
++;

118 while (
envp
[
i
])

120 if (
	`link_env
(
head
, 
	`new_env
(
envp
[
i
])) < 0)

121 return (
	`free_env
(
head
), 
NULL
);

122 
i
++;

124 return (*
head
);

125 
	}
}

	@expansion_test/is_dollar.c

12 #include 
	~"minishell.h
"

16 int 
	$is_dollar
(char 
c
)

18 if (
c
 == '$')

21 
	}
}

	@expansion_test/is_operator.c

12 #include 
	~"minishell.h
"

16 int 
	$is_pipeline
(char 
c
)

18 if (
c
 == '|')

21 
	}
}

25 int 
	$is_lchevron
(char 
c
)

27 if (
c
 == '<')

30 
	}
}

32 int 
	$is_rchevron
(char 
c
)

34 if (
c
 == '>')

37 
	}
}

39 int 
	$is_chevron
(char 
c
)

41 if (
	`is_lchevron
(
c
) || 
	`is_rchevron
(c))

44 
	}
}

48 int 
	$is_operator
(char 
c
)

50 if (
	`is_pipeline
(
c
) || 
	`is_chevron
(c))

53 
	}
}

	@expansion_test/is_question.c

12 #include 
	~"minishell.h
"

14 int 
	$is_question
(char 
c
)

16 if (
c
 == '?')

19 
	}
}

21 int 
	$is_punct
(char 
c
)

23 if ((
c
 >= 33 && c <= 47) || \

24 (
c
 >= 58 && c <= 64) || \

25 (
c
 >= 91 && c <= 96) || \

26 (
c
 >= 123 && c <= 126))

29 
	}
}

	@expansion_test/is_quote.c

12 #include 
	~"minishell.h
"

16 int 
	$is_double_quote
(char 
c
)

18 if (
c
 == '\"')

21 
	}
}

23 int 
	$is_simple_quote
(char 
c
)

25 if (
c
 == '\'')

28 
	}
}

30 int 
	$is_quote
(char 
c
)

32 if (
	`is_double_quote
(
c
) || 
	`is_simple_quote
(c))

35 
	}
}

	@expansion_test/is_token.c

12 #include 
	~"minishell.h
"

16 int 
	$is_metacharacter
(char 
c
)

18 if (
	`is_blank
(
c
) || 
	`is_newline
(c) || 
	`is_operator
(c))

21 
	}
}

25 int 
	$is_delimiter
(char 
c
)

27 if (
	`is_metacharacter
(
c
))

30 
	}
}

34 int 
	$is_word
(char 
c
)

36 if (!
	`is_delimiter
(
c
))

39 
	}
}

	@expansion_test/is_white_space.c

12 #include 
	~"minishell.h
"

14 int 
	$is_blank
(char 
c
)

16 if (
c
 == ' ' || c == '\t')

19 
	}
}

21 int 
	$is_newline
(char 
c
)

23 if (
c
 == '\n')

26 
	}
}

28 int 
	$is_white_space
(char 
c
)

30 if (
	`is_blank
(
c
) || 
	`is_newline
(c))

33 
	}
}

	@expansion_test/libft/ft_printf/ft_count_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_int
(int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

	@expansion_test/libft/ft_printf/ft_count_unsigned_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_unsigned_int
(unsigned int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 else if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 return (
count
);

30 
	}
}

	@expansion_test/libft/ft_printf/ft_dprintf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 
fd
, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 
fd
, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 
fd
, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 
fd
, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 
fd
, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_dprintf
(int 
fd
, const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 
fd
, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 
fd
, &
count
);

50 
	`ft_format_specifier_fd
(
last
[
i
 + 1], 
ap
, &
count
, 
fd
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@expansion_test/libft/ft_printf/ft_printf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier
(char 
format
, 
va_list
 
ap
, int *
count
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 1, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 1, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 1, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 1, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 1, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 1, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 1, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_printf
(const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 1, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 1, &
count
);

50 
	`ft_format_specifier
(
last
[
i
 + 1], 
ap
, &
count
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@expansion_test/libft/ft_printf/ft_printf_address.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
);

16 void 
	$ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
)

18 
	`ft_printf_str
("0x", 
fd
, 
count
);

19 
	`ft_put_uintptr_fd
(
n
, 
fd
, 
count
);

20 
	}
}

22 void 
	$ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
)

24 if (
n
 > 15)

26 
	`ft_put_uintptr_fd
(
n
 / 16, 
fd
, 
count
);

27 
	`ft_put_uintptr_fd
(
n
 % 16, 
fd
, 
count
);

29 if (
n
 < 10)

30 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

31 else if (
n
 > 9 && n < 16)

32 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

33 
	}
}

	@expansion_test/libft/ft_printf/ft_printf_char.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_char
(char 
c
, int 
fd
, int *
count
)

16 
	`ft_putchar_fd
(
c
, 
fd
);

17 *
count
 += 1;

18 
	}
}

	@expansion_test/libft/ft_printf/ft_printf_hexa.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
)

16 if (
n
 > 15)

18 
	`ft_printf_hexa
(
n
 / 16, 
fd
, 
count
, 
c
);

19 
	`ft_printf_hexa
(
n
 % 16, 
fd
, 
count
, 
c
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

25 if (
c
 == 'x')

26 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

27 else if (
c
 == 'X')

28 
	`ft_printf_char
(
n
 + 55, 
fd
, 
count
);

30 
	}
}

	@expansion_test/libft/ft_printf/ft_printf_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_int
(int 
n
, int 
fd
, int *
count
)

16 
	`ft_putnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_int
(
n
);

18 
	}
}

	@expansion_test/libft/ft_printf/ft_printf_str.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_str
(char *
s
, int 
fd
, int *
count
)

16 int 
i
;

18 
i
 = 0;

19 if (
s
 != 
NULL
)

21 while (
s
[
i
] != '\0')

22 
i
++;

23 
	`ft_putstr_fd
(
s
, 
fd
);

27 
	`ft_putstr_fd
("(null)", 1);

28 
i
 = 6;

30 *
count
 += 
i
;

31 
	}
}

	@expansion_test/libft/ft_printf/ft_printf_unsint.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
)

16 
	`ft_put_unsnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_unsigned_int
(
n
);

18 
	}
}

	@expansion_test/libft/ft_printf/ft_put_hexanbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_hexanbr_fd
(unsigned int 
n
, int 
fd
, int *
count
)

16 if (
n
 > 15)

18 
	`ft_put_hexanbr_fd
(
n
 / 16, 
fd
, 
count
);

19 
	`ft_put_hexanbr_fd
(
n
 % 16, 
fd
, 
count
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

24 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

25 
	}
}

	@expansion_test/libft/ft_printf/ft_put_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_put_int
(int 
n
, int 
fd
, int *
count
)

16 int 
a
;

18 
a
 = *
count
;

19 
	`ft_putnbr_fd
(
n
, 
fd
);

20 
a
 += 
	`ft_count_int
(
n
);

21 return (
a
);

22 
	}
}

	@expansion_test/libft/ft_printf/ft_put_unsnbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
)

16 if (
n
 > 9)

18 
	`ft_put_unsnbr_fd
(
n
 / 10, 
fd
);

19 
	`ft_put_unsnbr_fd
((
n
 % 10), 
fd
);

22 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

23 
	}
}

	@expansion_test/libft/get_next_line/get_next_line.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$create_nextline
(char *
result
, char *
line
)

16 int 
start
;

17 int 
size
;

18 char *
nextline
;

20 
start
 = 
	`ft_strlen_int
(
result
);

21 
size
 = 
	`ft_strlen_int
(
line
);

22 
size
 = size - 
start
;

23 if (
size
 == 0)

25 
	`free
 (
line
);

26 return (
NULL
);

28 
nextline
 = 
	`malloc
((
size
 + 1) * sizeof(char));

29 if (!
nextline
)

30 return (
NULL
);

31 
size
 = 0;

32 while (
line
[
start
] != '\0')

34 
nextline
[
size
] = 
line
[
start
];

35 
size
++;

36 
start
++;

38 
nextline
[
size
] = '\0';

39 
	`free
(
line
);

40 return (
nextline
);

41 
	}
}

55 char *
	$create_result
(char *
line
)

57 int 
i
;

58 char *
result
;

60 
i
 = 
	`there_is_n
(
line
);

61 if (
i
 == -1 && *
line
)

62 
i
 = 
	`ft_strlen_int
(
line
);

63 else if (
i
 == -1 && !*
line
)

64 return (
NULL
);

65 
result
 = 
	`malloc
((
i
 + 1) * sizeof(char));

66 if (!
result
)

67 return (
NULL
);

68 
i
 = 0;

69 while (
line
[
i
] != '\0')

71 
result
[
i
] = 
line
[i];

72 if (
line
[
i
] == '\n')

74 
i
++;

77 
i
++;

79 
result
[
i
] = '\0';

80 return (
result
);

81 
	}
}

94 char *
	$read_fd
(char *
line
, int 
fd
, int *
error
)

96 char *
buffer
;

97 int 
ret
;

99 
ret
 = 1;

100 
	`prepare_forstash
(&
line
, &
buffer
);

101 while (
ret
 > 0 && 
	`there_is_n
(
buffer
) == -1 && there_is_n(
line
) == -1)

103 
ret
 = (int)
	`read
(
fd
, 
buffer
, 
BUFFER_SIZE
);

104 if (
ret
 < 0)

106 
	`free
(
buffer
);

107 *
error
 = -1;

108 return (
NULL
);

110 if (
ret
 == 0)

112 *
error
 = 0;

115 
buffer
[
ret
] = '\0';

116 
line
 = 
	`ft_join
(line, 
buffer
);

118 
	`free
(
buffer
);

119 return (
line
);

120 
	}
}

130 int 
	$check_errors
(int 
fd
, char **
line
)

132 if (
fd
 < 0 || 
BUFFER_SIZE
 <= 0 || 
	`read
(fd, 0, 0) < 0)

134 
	`free
(*
line
);

135 *
line
 = 0;

139 
	}
}

150 char *
	$get_next_line
(int 
fd
)

152 static char *
line
;

153 char *
result
;

154 int 
error
;

156 
error
 = 
	`check_errors
(
fd
, &
line
);

157 if (
error
 == 0)

158 return (
NULL
);

159 
line
 = 
	`read_fd
(line, 
fd
, &
error
);

160 if (
error
 == -1 || (error == 0 && !*
line
))

162 
	`free
(
line
);

163 
line
 = 0;

164 return (
NULL
);

166 if (!
line
)

167 return (
NULL
);

168 
result
 = 
	`create_result
(
line
);

169 if (!
result
)

171 
line
 = 0;

172 
	`free
(
line
);

174 
line
 = 
	`create_nextline
(
result
, line);

175 return (
result
);

176 
	}
}

	@expansion_test/libft/get_next_line/get_next_line_bonus.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$get_next_line_maxopen
(int 
fd
)

16 static char *
line
[
OPEN_MAX
];

17 char *
result
;

18 int 
error
;

20 
error
 = 
	`check_errors
(
fd
, &
line
[fd]);

21 if (
error
 == 0)

22 return (
NULL
);

23 
line
[
fd
] = 
	`read_fd
(line[fd], fd, &
error
);

24 if (
error
 == -1 || (error == 0 && !*
line
[
fd
]))

26 
	`free
(
line
[
fd
]);

27 
line
[
fd
] = 0;

28 return (
NULL
);

30 if (!
line
[
fd
])

31 return (
NULL
);

32 
result
 = 
	`create_result
(
line
[
fd
]);

33 if (!
result
)

35 
line
[
fd
] = 0;

36 
	`free
(
line
[
fd
]);

38 
line
[
fd
] = 
	`create_nextline
(
result
, line[fd]);

39 return (
result
);

40 
	}
}

	@expansion_test/libft/get_next_line/get_next_line_utils.c

12 #include 
	~"../includes/get_next_line.h
"

14 void 
	$prepare_forstash
(char **
line
, char **
buffer
)

16 *
buffer
 = 
	`ft_calloc_count
(
BUFFER_SIZE
);

17 if (*
line
 == 
NULL
)

18 *
line
 = 
	`ft_calloc_count
(0);

19 
	}
}

21 char *
	$ft_join
(char *
line
, char *
buffer
)

23 int 
i
;

24 int 
j
;

25 char *
stash
;

27 if (!
line
 || !
buffer
)

28 return (
NULL
);

29 
i
 = 
	`ft_strlen_int
(
line
);

30 
j
 = 
	`ft_strlen_int
(
buffer
);

31 
stash
 = 
	`malloc
((
i
 + 
j
 + 1) * sizeof(char));

32 if (!
stash
)

33 return (
NULL
);

34 
i
 = 0;

35 
j
 = 0;

36 while (
line
[
i
] != '\0')

38 
stash
[
i
] = 
line
[i];

39 
i
++;

41 while (
buffer
[
j
] != '\0')

42 
stash
[
i
++] = 
buffer
[
j
++];

43 
stash
[
i
] = '\0';

44 
	`free
(
line
);

45 return (
stash
);

46 
	}
}

48 char *
	$ft_calloc_count
(int 
count
)

50 char *
string
;

51 int 
i
;

53 
i
 = 0;

54 
string
 = 
	`malloc
((
count
 + 1) * sizeof(char));

55 if (!
string
)

56 return (
NULL
);

57 while (
i
 <= 
count
)

59 
string
[
i
] = '\0';

60 
i
++;

62 return (
string
);

63 
	}
}

65 int 
	$ft_strlen_int
(const char *
string
)

67 int 
i
;

69 
i
 = 0;

70 while (
string
[
i
] != '\0')

71 
i
++;

72 return (
i
);

73 
	}
}

75 int 
	$there_is_n
(char *
line
)

77 int 
i
;

79 
i
 = 0;

80 while (
line
[
i
] != '\0')

82 if (
line
[
i
] == '\n')

83 return (
i
 + 1);

84 
i
++;

87 
	}
}

	@expansion_test/libft/includes/ft_printf.h

12 #ifndef 
FT_PRINTF_H


13 #define 
	#FT_PRINTF_H


	)

15 #include 
	~"libft.h
"

16 #include 
	~<stdarg.h
>

18 int 
ft_printf
(const char *
last
, ...);

19 void 
ft_printf_char
(char 
c
, int 
fd
, int *
count
);

20 void 
ft_printf_str
(char *
s
, int 
fd
, int *
count
);

21 void 
ft_printf_int
(int 
n
, int 
fd
, int *
count
);

22 int 
ft_count_int
(int 
n
);

23 void 
ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
);

24 void 
ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
);

25 int 
ft_count_unsigned_int
(unsigned int 
n
);

26 void 
ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
);

27 void 
ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
);

31 void 
ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
);

32 int 
ft_dprintf
(int 
fd
, const char *
last
, ...);

	@expansion_test/libft/includes/get_next_line.h

12 #ifndef 
GET_NEXT_LINE_H


13 #define 
	#GET_NEXT_LINE_H


	)

15 #include 
	~<unistd.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<limits.h
>

19 #ifndef 
BUFFER_SIZE


20 #define 
	#BUFFER_SIZE
 42

	)

23 char *
ft_calloc_count
(int 
count
);

24 int 
ft_strlen_int
(const char *
string
);

25 char *
ft_join
(char *
nextline
, char *
buffer
);

26 int 
there_is_n
(char *
line
);

27 char *
read_fd
(char *
nextline
, int 
fd
, int *
error
);

28 char *
create_result
(char *
line
);

29 char *
create_nextline
(char *
result
, char *
line
);

30 char *
get_next_line
(int 
fd
);

31 char *
get_next_line_maxopen
(int 
fd
);

32 int 
check_errors
(int 
fd
, char **
line
);

33 void 
prepare_forstash
(char **
line
, char **
buffer
);

	@expansion_test/libft/includes/libft.h

12 #ifndef 
LIBFT_H


13 #define 
	#LIBFT_H


	)

15 #include 
	~<stddef.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<unistd.h
>

18 #include 
	~"ft_printf.h
"

19 #include 
	~"get_next_line.h
"

21 typedef struct 
	ss_list


23 void *
	mcontent
;

24 struct 
s_list
 *
	mnext
;

25 } 
	tt_list
;

27 void *
ft_memset
(void *
b
, int 
c
, 
size_t
 
len
);

28 void 
ft_bzero
(void *
s
, 
size_t
 
n
);

29 void *
ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
);

30 void *
ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
);

31 void *
ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
);

32 int 
ft_isalpha
(int 
c
);

33 int 
ft_isdigit
(int 
c
);

34 int 
ft_isalnum
(int 
c
);

35 int 
ft_isascii
(int 
c
);

36 int 
ft_isprint
(int 
c
);

37 
size_t
 
ft_strlen
(const char *
s
);

38 int 
ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
);

39 char *
ft_strcpy
(char *
dst
, const char *
src
);

40 
size_t
 
ft_strlcpy
(char *
dst
, const char *
src
, size_t 
dstsize
);

41 
size_t
 
ft_strlcat
(char *
dst
, const char *
src
, size_t 
dstsize
);

42 char *
ft_strchr
(const char *
s
, int 
c
);

43 char *
ft_strrchr
(const char *
s
, int 
c
);

44 char *
ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
);

45 int 
ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
);

46 int 
ft_toupper
(int 
c
);

47 int 
ft_tolower
(int 
c
);

48 int 
ft_atoi
(const char *
str
);

49 void *
ft_calloc
(
size_t
 
count
, size_t 
size
);

50 char *
ft_strdup
(const char *
s1
);

51 char *
ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
);

52 char *
ft_strjoin
(char const *
s1
, char const *
s2
);

53 char *
ft_strtrim
(char const *
s1
, char const *
set
);

54 char **
ft_split
(char const *
s
, char 
c
);

55 char *
ft_itoa
(int 
n
);

56 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char));

57 void 
	`ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*));

58 void 
	`ft_putchar_fd
(char 
c
, int 
fd
);

59 void 
	`ft_putstr_fd
(char *
s
, int 
fd
);

60 void 
	`ft_putendl_fd
(char *
s
, int 
fd
);

61 void 
	`ft_putnbr_fd
(int 
n
, int 
fd
);

64 
t_list
 *
	`ft_lstnew
(void *
content
);

65 void 
	`ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
);

66 int 
	`ft_lstsize
(
t_list
 *
lst
);

67 
t_list
 *
	`ft_lstlast
(t_list *
lst
);

68 void 
	`ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
);

69 void 
	`ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*));

70 void 
	`ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*));

71 void 
	`ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *));

72 
t_list
 *
	`ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *));

73 void 
	`delete_first_el
(
t_list
 **
a
);

74 void 
	`delete_last_el
(
t_list
 **
a
);

75 void 
	`del
(void *
content
);

78 int 
	`power
(int 
str_base
, int 
power
);

79 int 
	`ft_atoi_base
(const char *
str
, int 
str_base
);

80 int 
	`transform
(char 
c
);

81 
size_t
 
	`ft_strcspn
(const char *
s
, const char *
reject
);

82 char *
	`ft_strpbrk
(const char *
s1
, const char *
s2
);

83 
size_t
 
	`ft_strspn
(const char *
s
, const char *
accept
);

84 char *
	`str_lowercase
(char *
str
);

	@expansion_test/libft/libft/del.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$del
(void *
content
)

16 if (
content
)

17 
	`free
(
content
);

18 
	}
}

	@expansion_test/libft/libft/ft_atoi.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_atoi
(const char *
str
)

16 int 
i
;

17 int 
result
;

18 int 
sign
;

20 
i
 = 0;

21 
result
 = 0;

22 
sign
 = 1;

23 while (
str
[
i
] == 32 || (str[i] >= 9 && str[i] <= 13))

24 
i
++;

25 if (
str
[
i
] == '-')

27 
sign
 *= (-1);

28 
i
++;

30 else if (
str
[
i
] == '+')

31 
i
++;

32 while (
str
[
i
] >= '0' && str[i] <= '9')

34 
result
 *= 10;

35 
result
 += 
str
[
i
] - 48;

36 
i
++;

38 return (
sign
 * 
result
);

39 
	}
}

	@expansion_test/libft/libft/ft_atoi_base.c

12 #include 
	~"../includes/libft.h
"

13 #include 
	~"../includes/get_next_line.h
"

15 int 
	$transform
(char 
c
)

17 int 
i
;

18 char 
c2
;

20 
i
 = 10;

21 if (
c
 >= 'A' && c <= 'F')

22 
c2
 = 'A';

23 if (
c
 >= 'a' && c <= 'f')

24 
c2
 = 'a';

25 while (
c
 != 
c2
)

27 
c2
++;

28 
i
++;

30 return (
i
);

31 
	}
}

33 int 
	$ft_atoi_base
(const char *
str
, int 
str_base
)

35 int 
i
;

36 int 
count
;

37 int 
result
;

38 int 
sign
;

40 
i
 = 0;

41 
result
 = 0;

42 
count
 = 
	`ft_strlen_int
(
str
) - 1;

43 
sign
 = 1;

44 if (
str
[
i
] == '-')

46 
i
++;

47 
sign
 = -1;

48 
count
--;

50 while (
str
[
i
++] != 0)

52 if (
str
[
i
] >= '0' && str[i] <= '9')

53 
result
 = result + (
str
[
i
] - '0') * 
	`power
(
str_base
, 
count
);

54 if ((
str
[
i
] >= 'A' && str[i] <= 'F') || \

55 (
str
[
i
] >= 'a' && str[i] <= 'f'))

56 
result
 = result + 
	`transform
(
str
[
i
]) * 
	`power
(
str_base
, 
count
);

57 
count
--;

59 return (
result
 * 
sign
);

60 
	}
}

	@expansion_test/libft/libft/ft_bzero.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_bzero
(void *
s
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (
n
 == 0)

21 while (
i
 < 
n
)

23 *(char *)(
s
 + 
i
) = 0;

24 
i
++;

26 
	}
}

	@expansion_test/libft/libft/ft_calloc.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_calloc
(
size_t
 
count
, size_t 
size
)

16 void *
ptr
;

18 
ptr
 = (void *)
	`malloc
(
count
 * 
size
);

19 if (!
ptr
)

20 return (
NULL
);

21 
	`ft_bzero
(
ptr
, (
count
 * 
size
));

22 return (
ptr
);

23 
	}
}

	@expansion_test/libft/libft/ft_isalnum.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalnum
(int 
c
)

16 if (
	`ft_isalpha
(
c
) == 1 || 
	`ft_isdigit
(c) == 1)

20 
	}
}

	@expansion_test/libft/libft/ft_isalpha.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalpha
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

18 else if (
c
 >= 'a' && c <= 'z')

22 
	}
}

	@expansion_test/libft/libft/ft_isascii.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isascii
(int 
c
)

16 if (
c
 >= 0 && c <= 127)

20 
	}
}

	@expansion_test/libft/libft/ft_isdigit.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isdigit
(int 
c
)

16 if (
c
 >= '0' && c <= '9')

20 
	}
}

	@expansion_test/libft/libft/ft_isprint.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isprint
(int 
c
)

16 if (
c
 >= 32 && c <= 126)

20 
	}
}

	@expansion_test/libft/libft/ft_itoa.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbchar
(int 
n
)

16 
size_t
 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

41 char *
	$ft_nb_is_negative
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

43 int 
result
;

45 
result
 = 0;

46 if (
n
 == -2147483648)

48 
n
 = -214748364;

49 
itoa_str
[
nb_char
 - 1] = (char)(8 + 48);

50 
nb_char
--;

52 
n
 *= (-1);

53 while (
n
 > 0)

55 
result
 = (
n
 % 10);

56 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

57 
n
 = n / 10;

58 
nb_char
--;

60 
itoa_str
[--
nb_char
] = '-';

61 return (
itoa_str
);

62 
	}
}

64 char *
	$ft_nb_is_positive
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

66 int 
result
;

68 
result
 = 0;

69 while (
n
 > 0)

71 
result
 = 
n
 % 10;

72 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

73 
n
 = n / 10;

74 
nb_char
--;

76 return (
itoa_str
);

77 
	}
}

79 char *
	$ft_itoa
(int 
n
)

81 
size_t
 
nb_char
;

82 
size_t
 
buff
;

83 char *
itoa_str
;

85 
buff
 = 0;

86 
nb_char
 = 
	`ft_count_nbchar
(
n
);

87 
itoa_str
 = (char *)
	`ft_calloc
((
nb_char
 + 1), sizeof(char));

88 if (!
itoa_str
)

89 return (
NULL
);

90 while (
buff
 < 
nb_char
)

92 
itoa_str
[
buff
] = '0';

93 
buff
++;

95 if (
n
 == 0)

96 
itoa_str
[0] = (char)(0 + 48);

97 else if (
n
 < 0)

98 
itoa_str
 = 
	`ft_nb_is_negative
(
n
, itoa_str, 
nb_char
);

99 else if (
n
 > 0)

100 
itoa_str
 = 
	`ft_nb_is_positive
(
n
, itoa_str, 
nb_char
);

101 return (
itoa_str
);

102 
	}
}

	@expansion_test/libft/libft/ft_lstadd_back.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
)

16 
t_list
 *
lstlast
;

18 if (*
lst
 == 
NULL
)

19 *
lst
 = 
new
;

20 else if (!
lst
 || !
new
)

24 
lstlast
 = 
	`ft_lstlast
(*
lst
);

25 
lstlast
->
next
 = 
new
;

27 
	}
}

	@expansion_test/libft/libft/ft_lstadd_front.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
)

16 if (*
lst
 == 
NULL
)

18 
new
->
next
 = 
NULL
;

19 *
lst
 = 
new
;

21 else if (*
lst
 != 
NULL
)

23 
new
->
next
 = *
lst
;

24 *
lst
 = 
new
;

26 
	}
}

	@expansion_test/libft/libft/ft_lstclear.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*))

16 
t_list
 *
temp
;

17 
t_list
 *
ptr
;

19 
ptr
 = *
lst
;

20 if (!
del
)

22 while (
ptr
 != 
NULL
)

24 
temp
 = 
ptr
->
next
;

25 
	`ft_lstdelone
(
ptr
, 
del
);

26 
ptr
 = 
temp
;

28 *
lst
 = 
NULL
;

29 
	}
}

	@expansion_test/libft/libft/ft_lstdel_first_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_first_el
(
t_list
 **
a
)

16 
t_list
 *
tmp
;

18 
tmp
 = (*
a
)->
next
;

19 
	`free
 (*
a
);

20 *
a
 = 
tmp
;

21 
	}
}

	@expansion_test/libft/libft/ft_lstdel_last_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_last_el
(
t_list
 **
a
)

16 
t_list
 *
end
;

17 
t_list
 *
prev
;

19 
end
 = *
a
;

20 
prev
 = 
NULL
;

21 while (
end
->
next
)

23 
prev
 = 
end
;

24 
end
 = end->
next
;

26 
prev
->
next
 = 
NULL
;

27 
	`free
 (
end
);

28 
	}
}

	@expansion_test/libft/libft/ft_lstdelone.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*))

16 if (!
lst
 || !
del
)

18 
	`del
(
lst
->
content
);

19 
	`free
(
lst
);

20 
	}
}

	@expansion_test/libft/libft/ft_lstiter.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *))

16 
t_list
 *
ptr
;

18 
ptr
 = 
lst
;

19 while (
ptr
 != 
NULL
)

21 
	`f
(
ptr
->
content
);

22 
ptr
 = ptr->
next
;

24 
	}
}

	@expansion_test/libft/libft/ft_lstlast.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstlast
(
t_list
 *
lst
)

16 while (
lst
 != 
NULL
 && lst->
next
 != NULL)

18 
lst
 = lst->
next
;

20 return (
lst
);

21 
	}
}

	@expansion_test/libft/libft/ft_lstmap.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *))

16 
t_list
 *
new_list
;

17 
t_list
 *
head
;

19 if (!
lst
 || !
f
)

20 return (
NULL
);

21 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

22 if (!
new_list
)

23 return (
NULL
);

24 
head
 = 
new_list
;

25 
lst
 = lst->
next
;

26 while (
lst
 != 
NULL
)

28 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

29 if (!
new_list
)

31 
	`ft_lstclear
(&
head
, 
del
);

32 return (
NULL
);

34 
	`ft_lstadd_back
(&
head
, 
new_list
);

35 
lst
 = lst->
next
;

37 return (
head
);

38 
	}
}

	@expansion_test/libft/libft/ft_lstnew.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstnew
(void *
content
)

16 
t_list
 *
lstnew
;

18 
lstnew
 = (
t_list
 *)
	`malloc
(sizeof(t_list));

19 if (!
lstnew
)

20 return (
NULL
);

21 
lstnew
->
next
 = 
NULL
;

22 
lstnew
->
content
 = (void *)content;

23 return (
lstnew
);

24 
	}
}

	@expansion_test/libft/libft/ft_lstsize.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_lstsize
(
t_list
 *
lst
)

16 int 
i
;

17 
t_list
 *
ptr
;

19 
i
 = 0;

20 
ptr
 = 
NULL
;

21 
ptr
 = 
lst
;

22 while (
ptr
 != 
NULL
)

24 
ptr
 = ptr->
next
;

25 
i
++;

27 return (
i
);

28 
	}
}

	@expansion_test/libft/libft/ft_memchr.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s
 + 
i
) == (unsigned char) 
c
)

23 return ((unsigned char *)(
s
 + 
i
));

26 
i
++;

28 return (
NULL
);

29 
	}
}

	@expansion_test/libft/libft/ft_memcmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s1
 + 
i
) != *(unsigned char *)(
s2
 + i))

23 return (*(unsigned char *)(
s1
 + 
i
) - *(unsigned char *)(
s2
 + i));

26 
i
++;

29 
	}
}

	@expansion_test/libft/libft/ft_memcpy.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 while (
i
 < 
n
)

23 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

24 
i
++;

26 return (
dst
);

27 
	}
}

	@expansion_test/libft/libft/ft_memmove.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 if (
dst
 > 
src
)

23 while (
len
--)

25 *(char *)(
dst
 + 
len
) = *(char *)(
src
 + len);

27 return (
dst
);

29 while (
i
 < 
len
)

31 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

32 
i
++;

34 return (
dst
);

35 
	}
}

	@expansion_test/libft/libft/ft_memset.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memset
(void *
b
, int 
c
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
len
)

21 *(unsigned char *)(
b
 + 
i
) = (unsigned char)
c
;

22 
i
++;

24 return (
b
);

25 
	}
}

	@expansion_test/libft/libft/ft_putchar_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putchar_fd
(char 
c
, int 
fd
)

16 
	`write
(
fd
, &
c
, 1);

17 
	}
}

	@expansion_test/libft/libft/ft_putendl_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putendl_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

26 
	`write
(
fd
, "\n", 1);

28 
	}
}

	@expansion_test/libft/libft/ft_putnbr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putnbr_fd
(int 
n
, int 
fd
)

16 if (
n
 == -2147483648)

18 
	`ft_putstr_fd
("-2147483648", 
fd
);

20 else if (
n
 < 0)

22 
	`ft_putchar_fd
('-', 
fd
);

23 
n
 = n * (-1);

24 
	`ft_putnbr_fd
(
n
, 
fd
);

26 else if (
n
 > 9)

28 
	`ft_putnbr_fd
(
n
 / 10, 
fd
);

29 
	`ft_putnbr_fd
((
n
 % 10), 
fd
);

32 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

33 
	}
}

	@expansion_test/libft/libft/ft_putstr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putstr_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

27 
	}
}

	@expansion_test/libft/libft/ft_split.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbsubstr
(const char *
s
, char 
c
)

16 unsigned int 
i
;

17 
size_t
 
count
;

19 
i
 = 0;

20 
count
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] != 
c
)

25 while (
s
[
i
] != 
c
 && s[i] != '\0')

26 
i
++;

27 
count
++;

29 while (
s
[
i
] == 
c
)

30 
i
++;

32 return (
count
);

33 
	}
}

35 unsigned int 
	$ft_start_index_substr
(char const *
s
, char 
c
, unsigned int 
start
)

37 while (
s
[
start
] == 
c
 && s[start] != '\0')

38 
start
++;

39 return (
start
);

40 
	}
}

42 unsigned int 
	$ft_nb_char_substr
(char const *
s
, char 
c
, unsigned int 
start
)

44 unsigned int 
nb_char_substr
;

46 
nb_char_substr
 = 0;

47 while (
s
[
start
] != 
c
 && s[start] != '\0')

49 
start
++;

50 
nb_char_substr
++;

52 return (
nb_char_substr
);

53 
	}
}

55 char *
ft_create_substr
(\

56 char const *
s
, char 
c
, unsigned int 
start
, unsigned int 
nb_char_substr
)

58 unsigned int 
	gi
;

59 char *
	gsubstr
;

61 
	gi
 = 0;

62 
	gsubstr
 = (char *)
ft_calloc
((
nb_char_substr
 + 1), sizeof(char));

63 if (!
	gsubstr
)

64 return (
	gNULL
);

65 while (
	gs
[
start
] != 
c
 && 
s
[start] != '\0' && 
i
 < 
nb_char_substr
)

66 
substr
[
i
++] = 
s
[
start
++];

67 return (
	gsubstr
);

70 char **
	$ft_split
(char const *
s
, char 
c
)

72 
size_t
 
nb_substr
;

73 
size_t
 
i
;

74 char **
tab2d
;

75 unsigned int 
start
;

76 unsigned int 
nb_char_substr
;

78 
i
 = 0;

79 
start
 = 0;

80 
nb_substr
 = 
	`ft_count_nbsubstr
(
s
, 
c
);

81 
tab2d
 = (char **)
	`ft_calloc
((
nb_substr
 + 1), sizeof(char *));

82 if (!
tab2d
)

83 return (
NULL
);

84 while (
s
[
start
] != '\0' && 
i
 < 
nb_substr
)

86 
start
 = 
	`ft_start_index_substr
(
s
, 
c
, start);

87 
nb_char_substr
 = 
	`ft_nb_char_substr
(
s
, 
c
, 
start
);

88 
tab2d
[
i
] = 
	`ft_create_substr
(
s
, 
c
, 
start
, 
nb_char_substr
);

89 
start
 = start + 
nb_char_substr
;

90 
i
++;

92 return (
tab2d
);

93 
	}
}

	@expansion_test/libft/libft/ft_strchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strchr
(const char *
s
, int 
c
)

16 int 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 if ((char)
c
 == 
s
[
i
])

22 return ((char *)(
s
 + 
i
));

23 
i
++;

25 if ((char)
c
 == '\0')

26 return ((char *)(
s
 + 
i
));

28 return (
NULL
);

29 
	}
}

	@expansion_test/libft/libft/ft_strcpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strcpy
(char *
dst
, const char *
src
)

16 int 
i
;

18 
i
 = 0;

19 while (
src
[
i
])

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 
dst
[
i
] = '\0';

25 return (
dst
);

26 
	}
}

	@expansion_test/libft/libft/ft_strcspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strcspn
(const char *
s
, const char *
reject
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
])

21 if (
	`ft_strchr
(
reject
, 
s
[
i
]) != 
NULL
)

22 return (
i
);

23 
i
++;

25 return (
i
);

26 
	}
}

	@expansion_test/libft/libft/ft_strdup.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strdup
(const char *
s1
)

16 int 
size
;

17 char *
s1_copie
;

19 
size
 = 
	`ft_strlen
(
s1
) + 1;

20 
s1_copie
 = (char *)
	`malloc
(
size
 * sizeof(char));

21 if (!
s1_copie
)

22 return (
NULL
);

23 
	`ft_strlcpy
(
s1_copie
, 
s1
, 
size
);

24 return (
s1_copie
);

25 
	}
}

	@expansion_test/libft/libft/ft_striteri.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*))

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`f
(
i
, &
s
[i]);

24 
i
++;

27 
	}
}

	@expansion_test/libft/libft/ft_strjoin.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strjoin
(char const *
s1
, char const *
s2
)

16 
size_t
 
size_s1
;

17 
size_t
 
size_s2
;

18 char *
strjoin
;

20 
size_s1
 = 
	`ft_strlen
(
s1
);

21 
size_s2
 = 
	`ft_strlen
(
s2
);

22 
strjoin
 = (char *)
	`malloc
((
size_s1
 + 
size_s2
 + 1) * sizeof(char));

23 if (!
strjoin
)

24 return (
NULL
);

25 
	`ft_memcpy
(
strjoin
, 
s1
, 
size_s1
);

26 
	`ft_memcpy
((
strjoin
 + 
size_s1
), 
s2
, 
size_s2
);

27 
	`ft_memset
((
strjoin
 + 
size_s1
 + 
size_s2
), 0, 1);

28 return (
strjoin
);

29 
	}
}

	@expansion_test/libft/libft/ft_strlcat.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcat
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
strlen_src
;

18 
size_t
 
strlen_dst
;

19 
size_t
 
temp
;

21 
i
 = 0;

22 
strlen_src
 = 
	`ft_strlen
(
src
);

23 
strlen_dst
 = 
	`ft_strlen
(
dst
);

24 
temp
 = 
strlen_dst
;

25 if (
dstsize
 < 
strlen_dst
)

26 return (
dstsize
 + 
strlen_src
);

27 if (
dstsize
 > 
strlen_dst
 + 1)

29 while (
src
[
i
] && 
strlen_dst
 != (
dstsize
 - 1))

31 
dst
[
strlen_dst
++] = 
src
[
i
++];

33 
dst
[
strlen_dst
] = '\0';

35 return (
temp
 + 
strlen_src
);

36 
	}
}

	@expansion_test/libft/libft/ft_strlcpy.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcpy
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
j
;

19 
i
 = 0;

20 
j
 = 0;

21 while (
src
[
i
] != '\0')

23 
i
++;

25 if (
dstsize
 > 0)

27 while (
j
 < (
dstsize
 - 1) && 
src
[j] != '\0')

29 
dst
[
j
] = 
src
[j];

30 
j
++;

32 
dst
[
j
] = '\0';

34 return (
i
);

35 
	}
}

	@expansion_test/libft/libft/ft_strlen.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlen
(const char *
s
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 
i
++;

23 return (
i
);

24 
	}
}

	@expansion_test/libft/libft/ft_strmapi.c

12 #include 
	~"../includes/libft.h
"

14 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char))

16 unsigned int 
i
;

17 
size_t
 
size
;

18 char *
strmapi
;

20 
i
 = 0;

21 
size
 = 
	`ft_strlen
(
s
);

22 
strmapi
 = (char *)
	`malloc
((
size
 + 1) * sizeof(char));

23 if (!
strmapi
)

24 return (
NULL
);

25 while (
s
[
i
] != '\0')

27 
strmapi
[
i
] = 
	`f
(i, 
s
[i]);

28 
i
++;

30 
strmapi
[
i
] = '\0';

31 return (
strmapi
);

32 
	}
}

	@expansion_test/libft/libft/ft_strncmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (((unsigned char)
s1
[
i
] || (unsigned char)
s2
[i]) && i < 
n
)

21 if (
s1
[
i
] != 
s2
[i])

22 return ((unsigned char)
s1
[
i
] - (unsigned char)
s2
[i]);

23 
i
++;

26 
	}
}

	@expansion_test/libft/libft/ft_strncpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strncpy
(char *
dst
, const char *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
src
[
i
] && i < 
len
)

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 while (
i
 < 
len
)

26 
dst
[
i
] = '\0';

27 
i
++;

29 return (
dst
);

30 
	}
}

	@expansion_test/libft/libft/ft_strnstr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
)

16 
size_t
 
len_needle
;

17 
size_t
 
len_haystack
;

19 
len_needle
 = 
	`ft_strlen
(
needle
);

20 
len_haystack
 = 
	`ft_strlen
(
haystack
);

21 if (
needle
[0] == '\0')

22 return ((char *)(
haystack
));

23 if (
len_needle
 > 
len_haystack
 || 
len
 < len_needle)

24 return (
NULL
);

25 if (
len
 > 
len_haystack
)

26 
len
 = 
len_haystack
;

27 while (
len
 >= 
len_needle
 && 
haystack
)

29 if (
	`ft_memcmp
(
haystack
, 
needle
, 
len_needle
) == 0)

30 return ((char *)(
haystack
));

33 
haystack
++;

34 
len
--;

37 return (
NULL
);

38 
	}
}

	@expansion_test/libft/libft/ft_strpbrk.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strpbrk
(const char *
s1
, const char *
s2
)

16 int 
i
;

18 
i
 = 0;

19 while (
s1
[
i
] != '\0')

21 if (
	`ft_strchr
(
s2
, 
s1
[
i
]) != 0)

23 return ((char *) &
s1
[
i
]);

25 ++
i
;

28 
	}
}

	@expansion_test/libft/libft/ft_strrchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strrchr
(const char *
s
, int 
c
)

16 int 
i
;

17 int 
k
;

19 
i
 = 0;

20 
k
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] == (char)
c
)

24 
k
 = 
i
;

25 
i
++;

27 if (
s
[
k
] == (char)
c
)

28 return ((char *)(
s
 + 
k
));

29 else if ((char)
c
 == 
s
[
i
])

30 return ((char *)(
s
 + 
i
));

32 return (
NULL
);

33 
	}
}

	@expansion_test/libft/libft/ft_strspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strspn
(const char *
s
, const char *
accept
)

16 
size_t
 
count
;

17 
size_t
 
i
;

19 
count
 = 0;

20 
i
 = 0;

21 while (
s
[
i
] && 
	`ft_strchr
(
accept
, s[i]) != 0)

23 
count
++;

24 
i
++;

26 return (
count
);

27 
	}
}

	@expansion_test/libft/libft/ft_strtrim.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strtrim
(char const *
s1
, char const *
set
)

16 unsigned int 
front
;

17 unsigned int 
end
;

18 unsigned int 
i
;

19 char *
strtrim
;

21 
front
 = 0;

22 
i
 = 0;

23 
end
 = (unsigned int)(
	`ft_strlen
(
s1
));

24 while (
s1
[
front
] != '\0' && 
	`ft_strchr
(
set
, *(s1 + front)) != 
NULL
)

25 
front
++;

26 while (
front
 < 
end
 && 
	`ft_strrchr
(
set
, *(
s1
 + end - 1)) != 
NULL
)

27 
end
--;

28 
strtrim
 = (char *)
	`malloc
((
end
 - 
front
 + 1) * sizeof(char));

29 if (!
strtrim
)

30 return (
NULL
);

31 
i
 = 0;

32 while (
front
 < 
end
)

33 
strtrim
[
i
++] = 
s1
[
front
++];

34 
strtrim
[
i
] = 0;

35 return (
strtrim
);

36 
	}
}

	@expansion_test/libft/libft/ft_substr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
)

16 char *
substr
;

17 unsigned int 
i
;

18 
size_t
 
size
;

20 
i
 = 0;

21 if (!
s
)

22 return (
NULL
);

23 
size
 = 
	`ft_strlen
(
s
);

24 if (
len
 > 
size
)

25 
len
 = 
size
;

26 if (
start
 >= (unsigned int)
size
)

28 
substr
 = (char *)
	`malloc
(1 * sizeof(char));

29 if (!
substr
)

30 return (
NULL
);

31 
substr
[0] = '\0';

32 return (
substr
);

34 
substr
 = (char *)
	`malloc
((
len
 + 1) * sizeof(char));

35 if (!
substr
)

36 return (
NULL
);

37 while (
i
 < (unsigned int)
len
 && 
s
[
start
] != '\0' )

38 
substr
[
i
++] = 
s
[
start
++];

39 
substr
[
i
] = '\0';

40 return (
substr
);

41 
	}
}

	@expansion_test/libft/libft/ft_tolower.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_tolower
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

17 return (
c
 + 32);

19 return (
c
);

20 
	}
}

	@expansion_test/libft/libft/ft_toupper.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_toupper
(int 
c
)

16 if (
c
 >= 'a' && c <= 'z')

17 return (
c
 - 32);

19 return (
c
);

20 
	}
}

	@expansion_test/libft/libft/power.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$power
(int 
str_base
, int 
power
)

16 int 
result
;

18 
result
 = 1;

19 if (
power
 < 0 || 
str_base
 == 0)

23 while (
power
 > 0)

25 
result
 = result * 
str_base
;

26 
power
--;

28 return (
result
);

29 
	}
}

	@expansion_test/libft/libft/str_lowercase.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$str_lowercase
(char *
str
)

16 int 
i
;

18 
i
 = 0;

19 while (
str
[
i
])

21 if (
str
[
i
] >= 'A' && str[i] <= 'Z')

22 
str
[
i
] += 32;

23 
i
++;

25 return (
str
);

26 
	}
}

	@expansion_test/main.c

2 #include 
	~"minishell.h
"

4 
t_shell
 *
	gg_shell
;

10 void 
	$print_env
(
t_env
 **
head
)

12 
t_env
 *
ptr
;

14 
ptr
 = *
head
;

15 if (!
head
 || !*head)

17 while (
ptr
)

19 
	`ft_printf
("print_env function: %s\n", 
ptr
->
var_name
);

20 
	`ft_printf
("print_env function: %s\n", 
ptr
->
var_value
);

21 
ptr
 = ptr->
next
;

23 
	}
}

26 void 
	$free_shell
(void)

28 
	`free_env
(&
g_shell
->
env
);

30 if (
g_shell
)

31 
	`free
(
g_shell
);

32 
	}
}

34 int 
	$init_shell
(char **
envp
)

36 
g_shell
 = 
	`ft_calloc
(1, sizeof(
t_shell
));

37 if (!
g_shell
)

39 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

42 if (!*
envp
)

47 
g_shell
->
env
 = 
	`get_envp
(
envp
);

48 if (!
g_shell
->
env
)

50 
	`free_shell
();

51 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

54 
g_shell
->
exit_status
 = 0;

57 
	}
}

60 int 
	$main
(int 
ac
, char **
av
, char **
envp
)

62 (void)
av
;

63 (void)
ac
;

64 char *
line
;

65 
t_token
 *
token
;

67 if (!
	`init_shell
(
envp
))

69 
line
 = 
NULL
;

70 
line
 = 
	`ft_strdup
("$SHELL $fdsds");

71 
	`printf
("LINE = %s\n", 
line
);

72 
token
 = 
	`parsing
(
line
);

74 
g_shell
->
exit_status
 = 0;

75 if (
token
)

76 
	`free_token
(&
token
);

77 
	`free_shell
();

79 
	}
}

	@expansion_test/malloc_error_print_message.c

12 #include 
	~"minishell.h
"

14 void 
	$malloc_error_print_message
(char *
s
)

16 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
s
);

17 
g_shell
->
exit_status
 = 1;

18 
	}
}

	@expansion_test/minishell.h

1 #ifndef 
MINISHELL_H


2 #define 
	#MINISHELL_H


	)

4 #include 
	~<stdio.h
>

5 #include 
	~<string.h
>

6 #include 
	~<stdlib.h
>

7 #include 
	~<errno.h
>

8 #include 
	~<curses.h
>

9 #include 
	~<term.h
>

10 #include 
	~<signal.h
>

11 #include 
	~<unistd.h
>

12 #include 
	~<fcntl.h
>

13 #include 
	~<stdarg.h
>

14 #include 
	~<sys/wait.h
>

15 #include 
	~<sys/stat.h
>

16 #include 
	~<sys/types.h
>

17 #include 
	~<readline/readline.h
>

18 #include 
	~<readline/history.h
>

19 #include 
	~"libft/includes/libft.h
"

22 #define 
	#RED
 "\x1b[31m"

	)

23 #define 
	#BLU
 "\x1B[34m"

	)

24 #define 
	#BLU_2
 "\e[1;34m"

	)

25 #define 
	#GRN
 "\x1B[32m"

	)

26 #define 
	#YEL
 "\x1B[33m"

	)

27 #define 
	#MAG
 "\x1B[35m"

	)

28 #define 
	#CYN
 "\x1B[36m"

	)

29 #define 
	#WHT
 "\x1B[37m"

	)

30 #define 
	#RESET
 "\x1B[0m"

	)

32 #define 
	#WORD
 1

	)

33 #define 
	#PIPELINE
 2

	)

34 #define 
	#L_CHEVRON
 3

	)

35 #define 
	#R_CHEVRON
 4

	)

36 #define 
	#APPEND
 5

	)

37 #define 
	#HERE_DOC
 6

	)

38 #define 
	#DOLLAR
 7

	)

39 #define 
	#QUESTION
 8

	)

40 #define 
	#EXPAND
 9

	)

41 #define 
	#DELETE
 10

	)

46 typedef struct 
	ss_env


48 char *
	mvar_name
;

49 char *
	mvar_value
;

50 struct 
s_env
 *
	mnext
;

51 } 
	tt_env
;

53 typedef struct 
	ss_token


55 char *
	mcontent
;

56 int 
	mid
;

58 struct 
s_token
 *
	mnext
;

59 } 
	tt_token
;

62 typedef struct 
	ss_cmd


65 char **
	mcmd
;

66 char **
	mredir
;

67 char **
	mpath
;

71 int 
	mfdout
;

72 int 
	mfdin
;

73 int 
	mfd
[2];

74 } 
	tt_cmd
;

76 typedef struct 
	ss_shell


78 
t_env
 *
	menv
;

79 int 
	mexit_status
;

81 } 
	tt_shell
;

84 extern 
t_shell
 *
g_shell
;

86 void 
expansion
(
t_token
 **
token
, int 
pos
);

87 int 
join_tokens
(
t_token
 **
new
, t_token *
tmp
);

88 void 
delete_token
(
t_token
 **
head
);

89 int 
token_list_size
(
t_token
 **
head
);

90 int 
expand_var
(
t_token
 **
head
);

91 int 
prepare_expand
(
t_token
 *
tmp
, int 
i
);

92 void 
set_id_expansion
(
t_token
 *
token
);

94 int 
_pwd
(
t_cmd
 *
cmd
);

95 int 
_env
(
t_env
 *
env
);

98 char **
env_copied
(char **
envp
);

99 void 
free_tab
(char **
table
);

102 
t_env
 *
get_envp
(char **
envp
);

103 void 
free_env
(
t_env
 **
head
);

107 
t_token
 *
parsing
(char *
line
);

108 int 
syntax_error_check
(char *
s
);

109 int 
check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
);

110 int 
check_quotes_errors
(char *
s
, char 
c
, int *
i
);

111 int 
count_metachar
(char *
s
, char 
c
, int 
num
);

112 int 
check_multiple_operators_error
(int 
i
, int 
num
, char 
c
);

113 void 
print_syntax_error_char
(char 
c
);

114 void 
print_syntax_error_dchar
(char 
c
);

115 void 
print_syntax_error_str
(char *
s
);

118 int 
character_extraction
(char *
line
, int 
ind
);

119 int 
token_extraction
(char *
line
, int 
ind
);

120 
t_token
 *
get_tokens
(char *
line
);

121 int 
get_tokens_size
(char *
line
, int *
i
);

122 
t_token
 *
create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
);

125 void 
malloc_error_print_message
(char *
s
);

128 
t_token
 *
new_token
(char *
line
, int 
start
, int 
len
);

129 void 
set_id
(
t_token
 *
token
);

130 int 
token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
);

131 int 
link_token
(
t_token
 **
head
, t_token *
new
);

132 void 
free_token
(
t_token
 **
head
);

135 int 
is_dollar
(char 
c
);

136 int 
is_pipeline
(char 
c
);

137 int 
is_chevron
(char 
c
);

138 int 
is_lchevron
(char 
c
);

139 int 
is_rchevron
(char 
c
);

140 int 
is_operator
(char 
c
);

141 int 
is_newline
(char 
c
);

142 int 
is_white_space
(char 
c
);

143 int 
is_blank
(char 
c
);

144 int 
is_metacharacter
(char 
c
);

145 int 
is_delimiter
(char 
c
);

146 int 
is_word
(char 
c
);

147 int 
is_double_quote
(char 
c
);

148 int 
is_simple_quote
(char 
c
);

149 int 
is_quote
(char 
c
);

150 int 
is_question
(char 
c
);

151 int 
is_punct
(char 
c
);

154 int 
sig_handler
(void);

157 void 
handler_ctr_c
(int 
code
);

160 char **
ft_splitpath
(char *
s
, char 
c
);

	@expansion_test/parsing.c

12 #include 
	~"minishell.h
"

16 void 
	$print_token
(
t_token
 **
head
)

18 
t_token
 *
tmp
;

20 if (!*
head
 || !head)

22 
tmp
 = *
head
;

23 while (
tmp
)

25 if (
tmp
->
id
 == 
L_CHEVRON
)

26 
	`printf
("L_CHEVRON: ");

27 else if (
tmp
->
id
 == 
R_CHEVRON
)

28 
	`printf
("R_CHEVRON: ");

29 else if (
tmp
->
id
 == 
PIPELINE
)

30 
	`printf
("PIPELINE: ");

31 else if (
tmp
->
id
 == 
WORD
)

32 
	`printf
("WORD: ");

33 else if (
tmp
->
id
 == 
APPEND
)

34 
	`printf
("APPEND: ");

35 else if (
tmp
->
id
 == 
HERE_DOC
)

36 
	`printf
("HERE_DOC: ");

37 else if (
tmp
->
id
 == 
DOLLAR
)

38 
	`printf
("DOLLAR:");

39 
	`printf
("%s\n", 
tmp
->
content
);

40 
tmp
 = tmp->
next
;

42 
	}
}

44 
t_token
 *
	$parsing
(char *
line
)

46 
t_token
 *
token
;

48 if (!
	`syntax_error_check
(
line
))

49 return (
NULL
);

50 
token
 = 
	`get_tokens
(
line
);

51 if (!
token
)

52 return (
NULL
);

53 
	`expansion
(&
token
, 0);

54 
	`print_token
(&
token
);

56 return (
token
);

57 
	}
}

	@expansion_test/parsing_expansion.c

12 #include 
	~"minishell.h
"

14 int 
	$loop_dollars
(char *
s
, int 
i
)

16 while (
	`is_dollar
(
s
[
i
]) && s[i])

17 
i
++;

18 if (
s
[
i
] != '\0')

19 
i
--;

20 return (
i
);

21 
	}
}

23 int 
	$loop_simple_quotes
(char *
s
, int 
i
)

25 
i
++;

26 while (!
	`is_simple_quote
(
s
[
i
]))

27 
i
++;

28 return (
i
);

30 
	}
}

32 int 
	$check_dollar
(
t_token
 *
tmp
, int 
pos
)

34 int 
i
;

36 
i
 = 
pos
;

37 while (
tmp
->
content
[
i
])

39 if (
	`is_simple_quote
(
tmp
->
content
[
i
]))

40 
i
 = 
	`loop_simple_quotes
(
tmp
->
content
, i);

41 if (
	`is_dollar
(
tmp
->
content
[
i
]))

43 if (
	`is_question
(
tmp
->
content
[
i
 + 1]) || \

44 (!
	`is_quote
(
tmp
->
content
[
i
 + 1]) && \

45 !
	`is_dollar
(
tmp
->
content
[
i
 + 1]) && \

46 !
	`is_punct
(
tmp
->
content
[
i
 + 1]) && \

47 
tmp
->
content
[
i
 + 1] != '\0'))

50 
i
 = 
	`prepare_expand
(
tmp
, i);

51 return (
i
);

53 else if (
	`is_dollar
(
tmp
->
content
[
i
 + 1]))

54 
i
 = 
	`loop_dollars
(
tmp
->
content
, i);

55 else if (
tmp
->
content
[
i
 + 1] == '\0')

59 
i
++;

61 
tmp
->
id
 = 
WORD
;

62 return (
i
);

63 
	}
}

65 void 
	$expansion
(
t_token
 **
head
, int 
pos
)

67 
t_token
 *
tmp
;

68 
t_token
 *
next
;

70 
tmp
 = *
head
;

71 
next
 = 
NULL
;

72 if (!*
head
)

74 if (
tmp
)

76 if (
tmp
->
id
 == 
DOLLAR
)

78 
pos
 = 
	`check_dollar
(
tmp
, pos);

79 if (
tmp
->
id
 == 
DELETE
)

81 
	`delete_token
(
head
);

82 if (*
head
 && 
tmp
->
next
)

84 
next
 = 
tmp
->next;

85 
	`expansion
(&
next
, 
pos
);

89 
head
 = 
NULL
;

93 
	`expansion
(&
tmp
, 
pos
);

97 
pos
 = 0;

98 if (
tmp
->
next
)

100 
tmp
 = tmp->
next
;

101 
	`expansion
(&
tmp
, 
pos
);

106 
	}
}

	@expansion_test/parsing_expansion_helper.c

12 #include 
	~"minishell.h
"

14 void 
	$print_test_expansion
(
t_token
 **
head
)

16 
t_token
 *
tmp
;

18 
tmp
 = *
head
;

19 
	`printf
("---------test expansion---------\n");

20 while (
tmp
)

22 
	`printf
("%s|", 
tmp
->
content
);

23 
tmp
 = tmp->
next
;

25 
	`printf
("\n");

26 
	`printf
("---------end test expansion---------\n");

27 
	}
}

29 int 
	$get_new_size
(
t_token
 **
new
)

31 
t_token
 *
ptr
;

32 int 
size
;

33 int 
i
;

35 
size
 = 0;

36 
i
 = 0;

37 
ptr
 = *
new
;

38 while (
ptr
)

40 if (
ptr
->
id
 != 
DELETE
)

42 while (
ptr
->
content
[
i
])

44 
size
++;

45 
i
++;

47 
i
 = 0;

49 
ptr
 = ptr->
next
;

51 return (
size
);

52 
	}
}

55 int 
	$join_tokens
(
t_token
 **
new
, t_token *
curr
)

57 int 
size
;

58 
t_token
 *
ptr
;

59 int 
i
;

60 int 
j
;

62 
i
 = 0;

63 
j
 = 0;

64 
size
 = 
	`get_new_size
(
new
);

65 
	`free
(
curr
->
content
);

66 
curr
->
content
 = 
NULL
;

67 if (
size
 == 0)

69 
	`free_token
(
new
);

70 
curr
->
id
 = 
DELETE
;

73 
curr
->
content
 = 
	`malloc
((
size
 + 1) * sizeof(char));

74 if (!
curr
->
content
)

76 
ptr
 = *
new
;

77 while (
ptr
)

79 if (
ptr
->
id
 == 
DELETE
)

80 
ptr
 = ptr->
next
;

83 while (
ptr
->
content
[
j
])

85 
curr
->
content
[
i
] = 
ptr
->content[
j
];

86 
i
++;

87 
j
++;

89 
ptr
 = ptr->
next
;

90 
j
 = 0;

93 
curr
->
content
[
i
] = '\0';

94 
	`free_token
(
new
);

96 
	}
}

99 int 
	$check_var_exist
(
t_token
 *
tmp
)

101 if (
	`ft_strncmp
(&
tmp
->
content
[1], "?", 1) == 0)

103 
	`free
(
tmp
->
content
);

104 
tmp
->
content
 = 
NULL
;

105 
tmp
->
content
 = 
	`ft_strdup
(
	`ft_itoa
(
g_shell
->
exit_status
));

106 if (!
tmp
->
content
)

108 
	`malloc_error_print_message
("ft_strdup failed");

114 else if (
	`ft_strncmp
(
g_shell
->
env
->
var_name
, &
tmp
->
content
[1], \

115 
	`ft_strlen
(
tmp
->
content
)) == 0)

117 
	`free
(
tmp
->
content
);

118 
tmp
->
content
 = 
NULL
;

119 
tmp
->
content
 = 
	`ft_strdup
(
g_shell
->
env
->
var_value
);

120 if (!
tmp
->
content
)

122 
	`malloc_error_print_message
("ft_strdup failed");

128 
	}
}

131 int 
	$expand_var
(
t_token
 **
new
)

133 
t_token
 *
tmp
;

134 
t_env
 *
save
;

136 
tmp
 = *
new
;

137 
save
 = 
g_shell
->
env
;

138 while (
tmp
->
id
 != 
EXPAND
)

139 
tmp
 = tmp->
next
;

140 while (
g_shell
->
env
)

142 if (
	`check_var_exist
(
tmp
))

144 
tmp
->
id
 = 
WORD
;

145 
g_shell
->
env
 = 
save
;

146 return (
	`ft_strlen
(
tmp
->
content
));

148 
g_shell
->
env
 = g_shell->env->
next
;

150 
tmp
->
id
 = 
DELETE
;

151 
g_shell
->
env
 = 
save
;

153 
	}
}

156 
t_token
 *
	$split_tokens
(char *
s
, int 
start
, int 
len
)

158 
t_token
 *
new
;

160 
new
 = 
NULL
;

161 if (
start
 != 0)

163 
new
 = 
	`new_token
(
s
, 0, 
start
);

164 
	`token_linked_list
(&
new
, 
s
, 
start
, 
len
);

165 
new
->
next
->
id
 = 
EXPAND
;

169 
new
 = 
	`new_token
(
s
, 
start
, 
len
);

170 
	`printf
("%p\n", 
new
);

171 
new
->
id
 = 
EXPAND
;

173 
len
 = 
start
 + len;

174 
start
 = 
len
;

175 while (
s
[
len
])

176 
len
++;

177 if (
len
 != 
start
)

178 
	`token_linked_list
(&
new
, 
s
,
start
, 
len
);

179 return (
new
);

180 
	}
}

182 int 
	$var_len
(char *
s
, int 
i
)

184 int 
len
;

186 
len
 = 0;

187 
i
++;

188 if (
	`is_question
(
s
[
i
]))

192 while (
s
[
i
] && \

193 !
	`is_white_space
(
s
[
i
]) && \

194 !
	`is_quote
(
s
[
i
]) && \

195 !
	`is_question
(
s
[
i
]) && \

196 !
	`is_dollar
(
s
[
i
]) && \

197 !
	`is_punct
(
s
[
i
]))

199 
i
++;

200 
len
++;

203 return (
len
);

204 
	}
}

206 int 
	$prepare_expand
(
t_token
 *
curr
, int 
i
)

208 
t_token
 *
new
;

209 int 
len
;

211 
new
 = 
NULL
;

212 
len
 = 
	`var_len
(
curr
->
content
, 
i
);

213 
new
 = 
	`split_tokens
(
curr
->
content
, 
i
, 
len
 + 1);

214 
len
 = 
	`expand_var
(&
new
);

215 
	`join_tokens
(&
new
, 
curr
);

216 if (
curr
->
id
 == 
DELETE
)

218 
	`set_id_expansion
(
curr
);

219 if (
len
 == -1)

221 return(
len
 + 
i
);

222 
	}
}

	@expansion_test/parsing_syntax_errors.c

12 #include 
	~"minishell.h
"

14 int 
	$check_multiple_operators_error
(int 
i
, int 
num
, char 
c
)

16 if (
i
 > 
num
)

18 if (
	`is_chevron
(
c
))

19 
	`print_syntax_error_dchar
(
c
);

20 else if (
	`is_pipeline
(
c
))

21 
	`print_syntax_error_char
(
c
);

25 
	}
}

27 int 
	$count_metachar
(char *
s
, char 
c
, int 
num
)

29 int 
i
;

31 
i
 = 1;

32 while (
s
[
i
] && s[i] == 
c
)

33 
i
++;

34 if (!
	`check_multiple_operators_error
(
i
, 
num
, 
c
))

36 while (
s
[
i
] && 
	`is_blank
(s[i]))

37 
i
++;

38 if (
	`is_operator
(
s
[
i
]) && !
	`is_pipeline
(
c
))

40 
c
 = 
s
[
i
];

41 if (
	`is_chevron
(
c
) && is_chevron(
s
[
i
 + 1]))

43 
	`print_syntax_error_dchar
(
c
);

47 
	`print_syntax_error_char
(
c
);

50 else if (
s
[
i
] == '\0')

52 
	`print_syntax_error_str
("newline");

56 
	}
}

58 int 
	$check_quotes_errors
(char *
s
, char 
c
, int *
i
)

60 int 
j
;

62 
j
 = *
i
 + 1;

63 while (
s
[
j
] && s[j] != 
c
)

64 
j
++;

65 if (
s
[
j
] != 
c
)

67 
	`print_syntax_error_char
(
c
);

70 (*
i
)++;

71 while (
s
[*
i
] && s[*i] != 
c
)

72 (*
i
)++;

74 
	}
}

76 int 
	$check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
)

78 int 
j
;

80 
j
 = 0;

81 while (
s
[
j
] && 
	`is_blank
(s[j]))

82 
j
++;

83 if (
s
[
j
] == 
c
)

85 
	`print_syntax_error_char
(
c
);

88 if (!
	`count_metachar
(&
s
[
i
], 
c
, 
num
))

91 
	}
}

138 int 
	$syntax_error_check
(char *
s
)

140 int 
i
;

142 
i
 = 0;

143 while (
s
[
i
])

145 if (
	`is_quote
(
s
[
i
]))

147 if (!
	`check_quotes_errors
(
s
, s[
i
], &i))

148 return (
	`free
(
s
), 0);

150 else if ((
	`is_lchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '<', 2)) || \

151 (
	`is_rchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '>', 2)))

152 return (
	`free
(
s
), 0);

153 else if (
	`is_pipeline
(
s
[
i
]) && !
	`check_pipeline_errors
(s, i, '|', 1))

154 return (
	`free
(
s
), 0);

155 
i
++;

158 
	}
}

	@expansion_test/parsing_syntax_errors_print_message.c

12 #include 
	~"minishell.h
"

19 void 
	$print_syntax_error_char
(char 
c
)

21 
	`ft_dprintf
(2, "minishell: ");

22 
	`ft_dprintf
(2, "syntax error near unexpected token ");

23 
	`ft_dprintf
(2, "\'%c\'\n", 
c
);

24 
g_shell
->
exit_status
 = 258;

25 
	}
}

27 void 
	$print_syntax_error_dchar
(char 
c
)

29 
	`ft_dprintf
(2, "minishell: ");

30 
	`ft_dprintf
(2, "syntax error near unexpected token ");

31 
	`ft_dprintf
(2, "\'%c%c\'\n", 
c
, c);

32 
g_shell
->
exit_status
 = 258;

33 
	}
}

35 void 
	$print_syntax_error_str
(char *
s
)

37 
	`ft_dprintf
(2, "minishell: ");

38 
	`ft_dprintf
(2, "syntax error near unexpected token ");

39 
	`ft_dprintf
(2, "\'%s\'\n", 
s
);

40 
g_shell
->
exit_status
 = 258;

41 
	}
}

	@expansion_test/parsing_token_extraction.c

12 #include 
	~"minishell.h
"

21 int 
	$character_extraction
(char *
line
, int 
ind
)

23 if ((
line
[
ind
] == '>' && line[ind + 1] == '>') || \

24 (
line
[
ind
] == '<' && line[ind + 1] == '<'))

27 
	}
}

43 int 
	$word_extraction
(char *
line
, int 
ind
)

45 int 
start
;

46 char 
c
;

48 
start
 = 
ind
;

49 while (
	`is_word
(
line
[
ind
]) && line[ind])

51 if (
	`is_quote
(
line
[
ind
]))

53 
c
 = 
line
[
ind
];

54 
ind
++;

55 while (
line
[
ind
] && line[ind] != 
c
)

56 
ind
++;

58 
ind
++;

60 return (
ind
 - 
start
);

61 
	}
}

64 int 
	$get_tokens_size
(char *
line
, int *
i
)

66 int 
len
;

68 
len
 = 0;

69 while (
	`is_blank
(
line
[*
i
]))

70 (*
i
)++;

71 if (
	`is_word
(
line
[*
i
]))

72 
len
 = 
	`word_extraction
(
line
, *
i
);

73 else if (
	`is_operator
(
line
[*
i
]))

74 
len
 = 
	`character_extraction
(
line
, *
i
);

75 return (
len
);

76 
	}
}

83 
t_token
 *
	$create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
)

85 
t_token
 *
head
;

87 
head
 = 
	`new_token
(
line
, 
i
, 
len
);

88 if (!
head
)

89 return (
NULL
);

90 *
flag
 = 1;

91 return (
head
);

92 
	}
}

122 
t_token
 *
	$get_tokens
(char *
line
)

124 int 
i
;

125 int 
len
;

126 int 
flag
;

127 
t_token
 *
head
;

129 
i
 = 0;

130 
flag
 = 0;

131 
head
 = 
NULL
;

132 while (
line
[
i
])

134 
len
 = 
	`get_tokens_size
(
line
, &
i
);

135 if (
len
 == 0)

137 if (!
flag
)

139 
head
 = 
	`create_token_head
(
line
, 
i
, 
len
, &
flag
);

140 if (!
head
)

141 return (
	`free
(
line
), 
NULL
);

144 if (!
	`token_linked_list
(&
head
, 
line
, 
i
, 
len
))

145 return (
	`free_token
(&
head
), 
	`free
(
line
), 
NULL
);

146 
i
 += 
len
;

148 return (
	`free
(
line
), 
head
);

149 
	}
}

	@expansion_test/token_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_token
(
t_token
 **
head
)

16 
t_token
 *
ptr
;

17 
t_token
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
content
);

27 
	`free
(
tmp
);

29 *
head
 = 
NULL
;

30 
	}
}

45 
t_token
 *
	$new_token
(char *
line
, int 
start
, int 
len
)

47 
t_token
 *
token
;

49 
token
 = 
NULL
;

50 
token
 = 
	`malloc
(sizeof(
t_token
));

51 if (!
token
)

53 
	`malloc_error_print_message
(
	`strerror
(
errno
));

54 return (
NULL
);

56 
token
->
content
 = 
	`ft_substr
(
line
, 
start
, 
len
);

57 if (!
token
->
content
)

59 
	`malloc_error_print_message
(
	`strerror
(
errno
));

60 return (
	`free_token
(&
token
), 
NULL
);

62 
	`set_id
(
token
);

64 
token
->
next
 = 
NULL
;

65 return (
token
);

66 
	}
}

75 int 
	$link_token
(
t_token
 **
head
, t_token *
new
)

77 
t_token
 *
ptr
;

79 if (!
new
)

81 
ptr
 = *
head
;

82 while (
ptr
)

84 if (!
ptr
->
next
)

86 
ptr
 = ptr->
next
;

88 
ptr
->
next
 = 
new
;

90 
	}
}

113 int 
	$token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
)

115 
t_token
 *
new
;

117 if (!
head
)

119 
new
 = 
	`new_token
(
line
, 
start
, 
len
);

120 if (!
new
)

122 if (!
	`link_token
(
head
, 
new
))

125 
	}
}

	@expansion_test/token_routine_delete.c

12 #include 
	~"minishell.h
"

14 int 
	$token_list_size
(
t_token
 **
head
)

16 
t_token
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

28 void 
	$delete_token
(
t_token
 **
head
)

30 int 
i
;

31 int 
size
;

32 
t_token
 *
curr
;

33 
t_token
 *
prev
;

35 
i
 = 0;

36 
size
 = 
	`token_list_size
(
head
);

37 
curr
 = *
head
;

38 
prev
 = *
head
;

39 while (
curr
->
id
 != 
DELETE
)

41 
prev
 = 
curr
;

42 
curr
 = curr->
next
;

43 
i
++;

45 if (
i
 == 0 && 
size
 == 1)

47 
	`free
((*
head
)->
content
);

48 
	`free
 (*
head
);

49 *
head
 = 
NULL
;

52 else if (
i
 == 0 && 
size
 > 1)

53 (*
head
) = (*head)->
next
;

54 else if (
i
 == 
size
 - 1)

55 
prev
->
next
 = 
NULL
;

57 
prev
->
next
 = 
curr
->next;

58 
	`free
(
curr
->
content
);

59 
	`free
(
curr
);

60 
	}
}

	@expansion_test/token_routine_set_id.c

12 #include 
	~"minishell.h
"

14 void 
	$set_id_expansion
(
t_token
 *
token
)

16 if (
	`ft_strchr
(
token
->
content
, '$'))

17 
token
->
id
 = 
DOLLAR
;

19 
token
->
id
 = 
WORD
;

21 
	}
}

23 void 
	$set_id
(
t_token
 *
token
)

25 if (
	`ft_strncmp
(
token
->
content
, "|", 2) == 0)

26 
token
->
id
 = 
PIPELINE
;

27 else if (
	`ft_strncmp
(
token
->
content
, "<", 2) == 0)

28 
token
->
id
 = 
L_CHEVRON
;

29 else if (
	`ft_strncmp
(
token
->
content
, ">", 2) == 0)

30 
token
->
id
 = 
R_CHEVRON
;

31 else if (
	`ft_strncmp
(
token
->
content
, "<<", 3) == 0)

32 
token
->
id
 = 
HERE_DOC
;

33 else if (
	`ft_strncmp
(
token
->
content
, ">>", 3) == 0)

34 
token
->
id
 = 
APPEND
;

35 else if (
	`ft_strchr
(
token
->
content
, '$'))

36 
token
->
id
 = 
DOLLAR
;

38 
token
->
id
 = 
WORD
;

40 
	}
}

	@handler_ctr_c.c

12 #include 
	~"minishell.h
"

14 void 
	$handler_ctr_c
(int 
code
)

17 (void)
code
;

18 
	`printf
("\n");

19 
	`rl_replace_line
("", 0);

20 
	`rl_on_new_line
();

21 
	`rl_redisplay
();

23 
	}
}

	@is_dollar.c

12 #include 
	~"minishell.h
"

16 int 
	$is_dollar
(char 
c
)

18 if (
c
 == '$')

21 
	}
}

	@is_operator.c

12 #include 
	~"minishell.h
"

16 int 
	$is_pipeline
(char 
c
)

18 if (
c
 == '|')

21 
	}
}

25 int 
	$is_lchevron
(char 
c
)

27 if (
c
 == '<')

30 
	}
}

32 int 
	$is_rchevron
(char 
c
)

34 if (
c
 == '>')

37 
	}
}

39 int 
	$is_chevron
(char 
c
)

41 if (
	`is_lchevron
(
c
) || 
	`is_rchevron
(c))

44 
	}
}

48 int 
	$is_operator
(char 
c
)

50 if (
	`is_pipeline
(
c
) || 
	`is_chevron
(c))

53 
	}
}

	@is_question.c

12 #include 
	~"minishell.h
"

14 int 
	$is_question
(char 
c
)

16 if (
c
 == '?')

19 
	}
}

21 int 
	$is_punct
(char 
c
)

23 if ((
c
 >= 33 && c <= 47) || \

24 (
c
 >= 58 && c <= 64) || \

25 (
c
 >= 91 && c <= 96) || \

26 (
c
 >= 123 && c <= 126))

29 
	}
}

	@is_quote.c

12 #include 
	~"minishell.h
"

16 int 
	$is_double_quote
(char 
c
)

18 if (
c
 == '\"')

21 
	}
}

23 int 
	$is_simple_quote
(char 
c
)

25 if (
c
 == '\'')

28 
	}
}

30 int 
	$is_quote
(char 
c
)

32 if (
	`is_double_quote
(
c
) || 
	`is_simple_quote
(c))

35 
	}
}

	@is_token.c

12 #include 
	~"minishell.h
"

16 int 
	$is_metacharacter
(char 
c
)

18 if (
	`is_blank
(
c
) || 
	`is_newline
(c) || 
	`is_operator
(c))

21 
	}
}

25 int 
	$is_delimiter
(char 
c
)

27 if (
	`is_metacharacter
(
c
))

30 
	}
}

34 int 
	$is_word
(char 
c
)

36 if (!
	`is_delimiter
(
c
))

39 
	}
}

	@is_white_space.c

12 #include 
	~"minishell.h
"

14 int 
	$is_blank
(char 
c
)

16 if (
c
 == ' ' || c == '\t')

19 
	}
}

21 int 
	$is_newline
(char 
c
)

23 if (
c
 == '\n')

26 
	}
}

28 int 
	$is_white_space
(char 
c
)

30 if (
	`is_blank
(
c
) || 
	`is_newline
(c))

33 
	}
}

	@launch_setup.c

2 #include 
	~"minishell.h
"

11 int 
	$sig_handler
(void)

13 
	`signal
(
SIGINT
, 
handler_ctr_c
);

14 
	`signal
(
SIGQUIT
, 
SIG_IGN
);

16 
	}
}

	@libft/ft_printf/ft_count_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_int
(int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

	@libft/ft_printf/ft_count_unsigned_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_unsigned_int
(unsigned int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 else if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 return (
count
);

30 
	}
}

	@libft/ft_printf/ft_dprintf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 
fd
, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 
fd
, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 
fd
, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 
fd
, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 
fd
, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_dprintf
(int 
fd
, const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 
fd
, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 
fd
, &
count
);

50 
	`ft_format_specifier_fd
(
last
[
i
 + 1], 
ap
, &
count
, 
fd
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@libft/ft_printf/ft_printf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier
(char 
format
, 
va_list
 
ap
, int *
count
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 1, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 1, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 1, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 1, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 1, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 1, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 1, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_printf
(const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 1, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 1, &
count
);

50 
	`ft_format_specifier
(
last
[
i
 + 1], 
ap
, &
count
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@libft/ft_printf/ft_printf_address.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
);

16 void 
	$ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
)

18 
	`ft_printf_str
("0x", 
fd
, 
count
);

19 
	`ft_put_uintptr_fd
(
n
, 
fd
, 
count
);

20 
	}
}

22 void 
	$ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
)

24 if (
n
 > 15)

26 
	`ft_put_uintptr_fd
(
n
 / 16, 
fd
, 
count
);

27 
	`ft_put_uintptr_fd
(
n
 % 16, 
fd
, 
count
);

29 if (
n
 < 10)

30 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

31 else if (
n
 > 9 && n < 16)

32 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

33 
	}
}

	@libft/ft_printf/ft_printf_char.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_char
(char 
c
, int 
fd
, int *
count
)

16 
	`ft_putchar_fd
(
c
, 
fd
);

17 *
count
 += 1;

18 
	}
}

	@libft/ft_printf/ft_printf_hexa.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
)

16 if (
n
 > 15)

18 
	`ft_printf_hexa
(
n
 / 16, 
fd
, 
count
, 
c
);

19 
	`ft_printf_hexa
(
n
 % 16, 
fd
, 
count
, 
c
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

25 if (
c
 == 'x')

26 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

27 else if (
c
 == 'X')

28 
	`ft_printf_char
(
n
 + 55, 
fd
, 
count
);

30 
	}
}

	@libft/ft_printf/ft_printf_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_int
(int 
n
, int 
fd
, int *
count
)

16 
	`ft_putnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_int
(
n
);

18 
	}
}

	@libft/ft_printf/ft_printf_str.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_str
(char *
s
, int 
fd
, int *
count
)

16 int 
i
;

18 
i
 = 0;

19 if (
s
 != 
NULL
)

21 while (
s
[
i
] != '\0')

22 
i
++;

23 
	`ft_putstr_fd
(
s
, 
fd
);

27 
	`ft_putstr_fd
("(null)", 1);

28 
i
 = 6;

30 *
count
 += 
i
;

31 
	}
}

	@libft/ft_printf/ft_printf_unsint.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
)

16 
	`ft_put_unsnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_unsigned_int
(
n
);

18 
	}
}

	@libft/ft_printf/ft_put_hexanbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_hexanbr_fd
(unsigned int 
n
, int 
fd
, int *
count
)

16 if (
n
 > 15)

18 
	`ft_put_hexanbr_fd
(
n
 / 16, 
fd
, 
count
);

19 
	`ft_put_hexanbr_fd
(
n
 % 16, 
fd
, 
count
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

24 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

25 
	}
}

	@libft/ft_printf/ft_put_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_put_int
(int 
n
, int 
fd
, int *
count
)

16 int 
a
;

18 
a
 = *
count
;

19 
	`ft_putnbr_fd
(
n
, 
fd
);

20 
a
 += 
	`ft_count_int
(
n
);

21 return (
a
);

22 
	}
}

	@libft/ft_printf/ft_put_unsnbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
)

16 if (
n
 > 9)

18 
	`ft_put_unsnbr_fd
(
n
 / 10, 
fd
);

19 
	`ft_put_unsnbr_fd
((
n
 % 10), 
fd
);

22 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

23 
	}
}

	@libft/get_next_line/get_next_line.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$create_nextline
(char *
result
, char *
line
)

16 int 
start
;

17 int 
size
;

18 char *
nextline
;

20 
start
 = 
	`ft_strlen_int
(
result
);

21 
size
 = 
	`ft_strlen_int
(
line
);

22 
size
 = size - 
start
;

23 if (
size
 == 0)

25 
	`free
 (
line
);

26 return (
NULL
);

28 
nextline
 = 
	`malloc
((
size
 + 1) * sizeof(char));

29 if (!
nextline
)

30 return (
NULL
);

31 
size
 = 0;

32 while (
line
[
start
] != '\0')

34 
nextline
[
size
] = 
line
[
start
];

35 
size
++;

36 
start
++;

38 
nextline
[
size
] = '\0';

39 
	`free
(
line
);

40 return (
nextline
);

41 
	}
}

55 char *
	$create_result
(char *
line
)

57 int 
i
;

58 char *
result
;

60 
i
 = 
	`there_is_n
(
line
);

61 if (
i
 == -1 && *
line
)

62 
i
 = 
	`ft_strlen_int
(
line
);

63 else if (
i
 == -1 && !*
line
)

64 return (
NULL
);

65 
result
 = 
	`malloc
((
i
 + 1) * sizeof(char));

66 if (!
result
)

67 return (
NULL
);

68 
i
 = 0;

69 while (
line
[
i
] != '\0')

71 
result
[
i
] = 
line
[i];

72 if (
line
[
i
] == '\n')

74 
i
++;

77 
i
++;

79 
result
[
i
] = '\0';

80 return (
result
);

81 
	}
}

94 char *
	$read_fd
(char *
line
, int 
fd
, int *
error
)

96 char *
buffer
;

97 int 
ret
;

99 
ret
 = 1;

100 
	`prepare_forstash
(&
line
, &
buffer
);

101 while (
ret
 > 0 && 
	`there_is_n
(
buffer
) == -1 && there_is_n(
line
) == -1)

103 
ret
 = (int)
	`read
(
fd
, 
buffer
, 
BUFFER_SIZE
);

104 if (
ret
 < 0)

106 
	`free
(
buffer
);

107 *
error
 = -1;

108 return (
NULL
);

110 if (
ret
 == 0)

112 *
error
 = 0;

115 
buffer
[
ret
] = '\0';

116 
line
 = 
	`ft_join
(line, 
buffer
);

118 
	`free
(
buffer
);

119 return (
line
);

120 
	}
}

130 int 
	$check_errors
(int 
fd
, char **
line
)

132 if (
fd
 < 0 || 
BUFFER_SIZE
 <= 0 || 
	`read
(fd, 0, 0) < 0)

134 
	`free
(*
line
);

135 *
line
 = 0;

139 
	}
}

150 char *
	$get_next_line
(int 
fd
)

152 static char *
line
;

153 char *
result
;

154 int 
error
;

156 
error
 = 
	`check_errors
(
fd
, &
line
);

157 if (
error
 == 0)

158 return (
NULL
);

159 
line
 = 
	`read_fd
(line, 
fd
, &
error
);

160 if (
error
 == -1 || (error == 0 && !*
line
))

162 
	`free
(
line
);

163 
line
 = 0;

164 return (
NULL
);

166 if (!
line
)

167 return (
NULL
);

168 
result
 = 
	`create_result
(
line
);

169 if (!
result
)

171 
line
 = 0;

172 
	`free
(
line
);

174 
line
 = 
	`create_nextline
(
result
, line);

175 return (
result
);

176 
	}
}

	@libft/get_next_line/get_next_line_bonus.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$get_next_line_maxopen
(int 
fd
)

16 static char *
line
[
OPEN_MAX
];

17 char *
result
;

18 int 
error
;

20 
error
 = 
	`check_errors
(
fd
, &
line
[fd]);

21 if (
error
 == 0)

22 return (
NULL
);

23 
line
[
fd
] = 
	`read_fd
(line[fd], fd, &
error
);

24 if (
error
 == -1 || (error == 0 && !*
line
[
fd
]))

26 
	`free
(
line
[
fd
]);

27 
line
[
fd
] = 0;

28 return (
NULL
);

30 if (!
line
[
fd
])

31 return (
NULL
);

32 
result
 = 
	`create_result
(
line
[
fd
]);

33 if (!
result
)

35 
line
[
fd
] = 0;

36 
	`free
(
line
[
fd
]);

38 
line
[
fd
] = 
	`create_nextline
(
result
, line[fd]);

39 return (
result
);

40 
	}
}

	@libft/get_next_line/get_next_line_utils.c

12 #include 
	~"../includes/get_next_line.h
"

14 void 
	$prepare_forstash
(char **
line
, char **
buffer
)

16 *
buffer
 = 
	`ft_calloc_count
(
BUFFER_SIZE
);

17 if (*
line
 == 
NULL
)

18 *
line
 = 
	`ft_calloc_count
(0);

19 
	}
}

21 char *
	$ft_join
(char *
line
, char *
buffer
)

23 int 
i
;

24 int 
j
;

25 char *
stash
;

27 if (!
line
 || !
buffer
)

28 return (
NULL
);

29 
i
 = 
	`ft_strlen_int
(
line
);

30 
j
 = 
	`ft_strlen_int
(
buffer
);

31 
stash
 = 
	`malloc
((
i
 + 
j
 + 1) * sizeof(char));

32 if (!
stash
)

33 return (
NULL
);

34 
i
 = 0;

35 
j
 = 0;

36 while (
line
[
i
] != '\0')

38 
stash
[
i
] = 
line
[i];

39 
i
++;

41 while (
buffer
[
j
] != '\0')

42 
stash
[
i
++] = 
buffer
[
j
++];

43 
stash
[
i
] = '\0';

44 
	`free
(
line
);

45 return (
stash
);

46 
	}
}

48 char *
	$ft_calloc_count
(int 
count
)

50 char *
string
;

51 int 
i
;

53 
i
 = 0;

54 
string
 = 
	`malloc
((
count
 + 1) * sizeof(char));

55 if (!
string
)

56 return (
NULL
);

57 while (
i
 <= 
count
)

59 
string
[
i
] = '\0';

60 
i
++;

62 return (
string
);

63 
	}
}

65 int 
	$ft_strlen_int
(const char *
string
)

67 int 
i
;

69 
i
 = 0;

70 while (
string
[
i
] != '\0')

71 
i
++;

72 return (
i
);

73 
	}
}

75 int 
	$there_is_n
(char *
line
)

77 int 
i
;

79 
i
 = 0;

80 while (
line
[
i
] != '\0')

82 if (
line
[
i
] == '\n')

83 return (
i
 + 1);

84 
i
++;

87 
	}
}

	@libft/includes/ft_printf.h

12 #ifndef 
FT_PRINTF_H


13 #define 
	#FT_PRINTF_H


	)

15 #include 
	~"libft.h
"

16 #include 
	~<stdarg.h
>

18 int 
ft_printf
(const char *
last
, ...);

19 void 
ft_printf_char
(char 
c
, int 
fd
, int *
count
);

20 void 
ft_printf_str
(char *
s
, int 
fd
, int *
count
);

21 void 
ft_printf_int
(int 
n
, int 
fd
, int *
count
);

22 int 
ft_count_int
(int 
n
);

23 void 
ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
);

24 void 
ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
);

25 int 
ft_count_unsigned_int
(unsigned int 
n
);

26 void 
ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
);

27 void 
ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
);

31 void 
ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
);

32 int 
ft_dprintf
(int 
fd
, const char *
last
, ...);

	@libft/includes/get_next_line.h

12 #ifndef 
GET_NEXT_LINE_H


13 #define 
	#GET_NEXT_LINE_H


	)

15 #include 
	~<unistd.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<limits.h
>

19 #ifndef 
BUFFER_SIZE


20 #define 
	#BUFFER_SIZE
 42

	)

23 char *
ft_calloc_count
(int 
count
);

24 int 
ft_strlen_int
(const char *
string
);

25 char *
ft_join
(char *
nextline
, char *
buffer
);

26 int 
there_is_n
(char *
line
);

27 char *
read_fd
(char *
nextline
, int 
fd
, int *
error
);

28 char *
create_result
(char *
line
);

29 char *
create_nextline
(char *
result
, char *
line
);

30 char *
get_next_line
(int 
fd
);

31 char *
get_next_line_maxopen
(int 
fd
);

32 int 
check_errors
(int 
fd
, char **
line
);

33 void 
prepare_forstash
(char **
line
, char **
buffer
);

	@libft/includes/libft.h

12 #ifndef 
LIBFT_H


13 #define 
	#LIBFT_H


	)

15 #include 
	~<stddef.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<unistd.h
>

18 #include 
	~"ft_printf.h
"

19 #include 
	~"get_next_line.h
"

21 typedef struct 
	ss_list


23 void *
	mcontent
;

24 struct 
s_list
 *
	mnext
;

25 } 
	tt_list
;

27 void *
ft_memset
(void *
b
, int 
c
, 
size_t
 
len
);

28 void 
ft_bzero
(void *
s
, 
size_t
 
n
);

29 void *
ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
);

30 void *
ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
);

31 void *
ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
);

32 int 
ft_isalpha
(int 
c
);

33 int 
ft_isdigit
(int 
c
);

34 int 
ft_isalnum
(int 
c
);

35 int 
ft_isascii
(int 
c
);

36 int 
ft_isprint
(int 
c
);

37 
size_t
 
ft_strlen
(const char *
s
);

38 int 
ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
);

39 char *
ft_strcpy
(char *
dst
, const char *
src
);

40 
size_t
 
ft_strlcpy
(char *
dst
, const char *
src
, size_t 
dstsize
);

41 
size_t
 
ft_strlcat
(char *
dst
, const char *
src
, size_t 
dstsize
);

42 char *
ft_strchr
(const char *
s
, int 
c
);

43 char *
ft_strrchr
(const char *
s
, int 
c
);

44 char *
ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
);

45 int 
ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
);

46 int 
ft_toupper
(int 
c
);

47 int 
ft_tolower
(int 
c
);

48 int 
ft_atoi
(const char *
str
);

49 void *
ft_calloc
(
size_t
 
count
, size_t 
size
);

50 char *
ft_strdup
(const char *
s1
);

51 char *
ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
);

52 char *
ft_strjoin
(char const *
s1
, char const *
s2
);

53 char *
ft_strtrim
(char const *
s1
, char const *
set
);

54 char **
ft_split
(char const *
s
, char 
c
);

55 char *
ft_itoa
(int 
n
);

56 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char));

57 void 
	`ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*));

58 void 
	`ft_putchar_fd
(char 
c
, int 
fd
);

59 void 
	`ft_putstr_fd
(char *
s
, int 
fd
);

60 void 
	`ft_putendl_fd
(char *
s
, int 
fd
);

61 void 
	`ft_putnbr_fd
(int 
n
, int 
fd
);

64 
t_list
 *
	`ft_lstnew
(void *
content
);

65 void 
	`ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
);

66 int 
	`ft_lstsize
(
t_list
 *
lst
);

67 
t_list
 *
	`ft_lstlast
(t_list *
lst
);

68 void 
	`ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
);

69 void 
	`ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*));

70 void 
	`ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*));

71 void 
	`ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *));

72 
t_list
 *
	`ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *));

73 void 
	`delete_first_el
(
t_list
 **
a
);

74 void 
	`delete_last_el
(
t_list
 **
a
);

75 void 
	`del
(void *
content
);

78 int 
	`power
(int 
str_base
, int 
power
);

79 int 
	`ft_atoi_base
(const char *
str
, int 
str_base
);

80 int 
	`transform
(char 
c
);

81 
size_t
 
	`ft_strcspn
(const char *
s
, const char *
reject
);

82 char *
	`ft_strpbrk
(const char *
s1
, const char *
s2
);

83 
size_t
 
	`ft_strspn
(const char *
s
, const char *
accept
);

84 char *
	`str_lowercase
(char *
str
);

	@libft/libft/del.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$del
(void *
content
)

16 if (
content
)

17 
	`free
(
content
);

18 
	}
}

	@libft/libft/ft_atoi.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_atoi
(const char *
str
)

16 int 
i
;

17 int 
result
;

18 int 
sign
;

20 
i
 = 0;

21 
result
 = 0;

22 
sign
 = 1;

23 while (
str
[
i
] == 32 || (str[i] >= 9 && str[i] <= 13))

24 
i
++;

25 if (
str
[
i
] == '-')

27 
sign
 *= (-1);

28 
i
++;

30 else if (
str
[
i
] == '+')

31 
i
++;

32 while (
str
[
i
] >= '0' && str[i] <= '9')

34 
result
 *= 10;

35 
result
 += 
str
[
i
] - 48;

36 
i
++;

38 return (
sign
 * 
result
);

39 
	}
}

	@libft/libft/ft_atoi_base.c

12 #include 
	~"../includes/libft.h
"

13 #include 
	~"../includes/get_next_line.h
"

15 int 
	$transform
(char 
c
)

17 int 
i
;

18 char 
c2
;

20 
i
 = 10;

21 if (
c
 >= 'A' && c <= 'F')

22 
c2
 = 'A';

23 if (
c
 >= 'a' && c <= 'f')

24 
c2
 = 'a';

25 while (
c
 != 
c2
)

27 
c2
++;

28 
i
++;

30 return (
i
);

31 
	}
}

33 int 
	$ft_atoi_base
(const char *
str
, int 
str_base
)

35 int 
i
;

36 int 
count
;

37 int 
result
;

38 int 
sign
;

40 
i
 = 0;

41 
result
 = 0;

42 
count
 = 
	`ft_strlen_int
(
str
) - 1;

43 
sign
 = 1;

44 if (
str
[
i
] == '-')

46 
i
++;

47 
sign
 = -1;

48 
count
--;

50 while (
str
[
i
++] != 0)

52 if (
str
[
i
] >= '0' && str[i] <= '9')

53 
result
 = result + (
str
[
i
] - '0') * 
	`power
(
str_base
, 
count
);

54 if ((
str
[
i
] >= 'A' && str[i] <= 'F') || \

55 (
str
[
i
] >= 'a' && str[i] <= 'f'))

56 
result
 = result + 
	`transform
(
str
[
i
]) * 
	`power
(
str_base
, 
count
);

57 
count
--;

59 return (
result
 * 
sign
);

60 
	}
}

	@libft/libft/ft_bzero.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_bzero
(void *
s
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (
n
 == 0)

21 while (
i
 < 
n
)

23 *(char *)(
s
 + 
i
) = 0;

24 
i
++;

26 
	}
}

	@libft/libft/ft_calloc.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_calloc
(
size_t
 
count
, size_t 
size
)

16 void *
ptr
;

18 
ptr
 = (void *)
	`malloc
(
count
 * 
size
);

19 if (!
ptr
)

20 return (
NULL
);

21 
	`ft_bzero
(
ptr
, (
count
 * 
size
));

22 return (
ptr
);

23 
	}
}

	@libft/libft/ft_isalnum.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalnum
(int 
c
)

16 if (
	`ft_isalpha
(
c
) == 1 || 
	`ft_isdigit
(c) == 1)

20 
	}
}

	@libft/libft/ft_isalpha.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalpha
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

18 else if (
c
 >= 'a' && c <= 'z')

22 
	}
}

	@libft/libft/ft_isascii.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isascii
(int 
c
)

16 if (
c
 >= 0 && c <= 127)

20 
	}
}

	@libft/libft/ft_isdigit.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isdigit
(int 
c
)

16 if (
c
 >= '0' && c <= '9')

20 
	}
}

	@libft/libft/ft_isprint.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isprint
(int 
c
)

16 if (
c
 >= 32 && c <= 126)

20 
	}
}

	@libft/libft/ft_itoa.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbchar
(int 
n
)

16 
size_t
 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

41 char *
	$ft_nb_is_negative
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

43 int 
result
;

45 
result
 = 0;

46 if (
n
 == -2147483648)

48 
n
 = -214748364;

49 
itoa_str
[
nb_char
 - 1] = (char)(8 + 48);

50 
nb_char
--;

52 
n
 *= (-1);

53 while (
n
 > 0)

55 
result
 = (
n
 % 10);

56 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

57 
n
 = n / 10;

58 
nb_char
--;

60 
itoa_str
[--
nb_char
] = '-';

61 return (
itoa_str
);

62 
	}
}

64 char *
	$ft_nb_is_positive
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

66 int 
result
;

68 
result
 = 0;

69 while (
n
 > 0)

71 
result
 = 
n
 % 10;

72 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

73 
n
 = n / 10;

74 
nb_char
--;

76 return (
itoa_str
);

77 
	}
}

79 char *
	$ft_itoa
(int 
n
)

81 
size_t
 
nb_char
;

82 
size_t
 
buff
;

83 char *
itoa_str
;

85 
buff
 = 0;

86 
nb_char
 = 
	`ft_count_nbchar
(
n
);

87 
itoa_str
 = (char *)
	`ft_calloc
((
nb_char
 + 1), sizeof(char));

88 if (!
itoa_str
)

89 return (
NULL
);

90 while (
buff
 < 
nb_char
)

92 
itoa_str
[
buff
] = '0';

93 
buff
++;

95 if (
n
 == 0)

96 
itoa_str
[0] = (char)(0 + 48);

97 else if (
n
 < 0)

98 
itoa_str
 = 
	`ft_nb_is_negative
(
n
, itoa_str, 
nb_char
);

99 else if (
n
 > 0)

100 
itoa_str
 = 
	`ft_nb_is_positive
(
n
, itoa_str, 
nb_char
);

101 return (
itoa_str
);

102 
	}
}

	@libft/libft/ft_lstadd_back.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
)

16 
t_list
 *
lstlast
;

18 if (*
lst
 == 
NULL
)

19 *
lst
 = 
new
;

20 else if (!
lst
 || !
new
)

24 
lstlast
 = 
	`ft_lstlast
(*
lst
);

25 
lstlast
->
next
 = 
new
;

27 
	}
}

	@libft/libft/ft_lstadd_front.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
)

16 if (*
lst
 == 
NULL
)

18 
new
->
next
 = 
NULL
;

19 *
lst
 = 
new
;

21 else if (*
lst
 != 
NULL
)

23 
new
->
next
 = *
lst
;

24 *
lst
 = 
new
;

26 
	}
}

	@libft/libft/ft_lstclear.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*))

16 
t_list
 *
temp
;

17 
t_list
 *
ptr
;

19 
ptr
 = *
lst
;

20 if (!
del
)

22 while (
ptr
 != 
NULL
)

24 
temp
 = 
ptr
->
next
;

25 
	`ft_lstdelone
(
ptr
, 
del
);

26 
ptr
 = 
temp
;

28 *
lst
 = 
NULL
;

29 
	}
}

	@libft/libft/ft_lstdel_first_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_first_el
(
t_list
 **
a
)

16 
t_list
 *
tmp
;

18 
tmp
 = (*
a
)->
next
;

19 
	`free
 (*
a
);

20 *
a
 = 
tmp
;

21 
	}
}

	@libft/libft/ft_lstdel_last_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_last_el
(
t_list
 **
a
)

16 
t_list
 *
end
;

17 
t_list
 *
prev
;

19 
end
 = *
a
;

20 
prev
 = 
NULL
;

21 while (
end
->
next
)

23 
prev
 = 
end
;

24 
end
 = end->
next
;

26 
prev
->
next
 = 
NULL
;

27 
	`free
 (
end
);

28 
	}
}

	@libft/libft/ft_lstdelone.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*))

16 if (!
lst
 || !
del
)

18 
	`del
(
lst
->
content
);

19 
	`free
(
lst
);

20 
	}
}

	@libft/libft/ft_lstiter.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *))

16 
t_list
 *
ptr
;

18 
ptr
 = 
lst
;

19 while (
ptr
 != 
NULL
)

21 
	`f
(
ptr
->
content
);

22 
ptr
 = ptr->
next
;

24 
	}
}

	@libft/libft/ft_lstlast.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstlast
(
t_list
 *
lst
)

16 while (
lst
 != 
NULL
 && lst->
next
 != NULL)

18 
lst
 = lst->
next
;

20 return (
lst
);

21 
	}
}

	@libft/libft/ft_lstmap.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *))

16 
t_list
 *
new_list
;

17 
t_list
 *
head
;

19 if (!
lst
 || !
f
)

20 return (
NULL
);

21 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

22 if (!
new_list
)

23 return (
NULL
);

24 
head
 = 
new_list
;

25 
lst
 = lst->
next
;

26 while (
lst
 != 
NULL
)

28 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

29 if (!
new_list
)

31 
	`ft_lstclear
(&
head
, 
del
);

32 return (
NULL
);

34 
	`ft_lstadd_back
(&
head
, 
new_list
);

35 
lst
 = lst->
next
;

37 return (
head
);

38 
	}
}

	@libft/libft/ft_lstnew.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstnew
(void *
content
)

16 
t_list
 *
lstnew
;

18 
lstnew
 = (
t_list
 *)
	`malloc
(sizeof(t_list));

19 if (!
lstnew
)

20 return (
NULL
);

21 
lstnew
->
next
 = 
NULL
;

22 
lstnew
->
content
 = (void *)content;

23 return (
lstnew
);

24 
	}
}

	@libft/libft/ft_lstsize.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_lstsize
(
t_list
 *
lst
)

16 int 
i
;

17 
t_list
 *
ptr
;

19 
i
 = 0;

20 
ptr
 = 
NULL
;

21 
ptr
 = 
lst
;

22 while (
ptr
 != 
NULL
)

24 
ptr
 = ptr->
next
;

25 
i
++;

27 return (
i
);

28 
	}
}

	@libft/libft/ft_memchr.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s
 + 
i
) == (unsigned char) 
c
)

23 return ((unsigned char *)(
s
 + 
i
));

26 
i
++;

28 return (
NULL
);

29 
	}
}

	@libft/libft/ft_memcmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s1
 + 
i
) != *(unsigned char *)(
s2
 + i))

23 return (*(unsigned char *)(
s1
 + 
i
) - *(unsigned char *)(
s2
 + i));

26 
i
++;

29 
	}
}

	@libft/libft/ft_memcpy.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 while (
i
 < 
n
)

23 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

24 
i
++;

26 return (
dst
);

27 
	}
}

	@libft/libft/ft_memmove.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 if (
dst
 > 
src
)

23 while (
len
--)

25 *(char *)(
dst
 + 
len
) = *(char *)(
src
 + len);

27 return (
dst
);

29 while (
i
 < 
len
)

31 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

32 
i
++;

34 return (
dst
);

35 
	}
}

	@libft/libft/ft_memset.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memset
(void *
b
, int 
c
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
len
)

21 *(unsigned char *)(
b
 + 
i
) = (unsigned char)
c
;

22 
i
++;

24 return (
b
);

25 
	}
}

	@libft/libft/ft_putchar_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putchar_fd
(char 
c
, int 
fd
)

16 
	`write
(
fd
, &
c
, 1);

17 
	}
}

	@libft/libft/ft_putendl_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putendl_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

26 
	`write
(
fd
, "\n", 1);

28 
	}
}

	@libft/libft/ft_putnbr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putnbr_fd
(int 
n
, int 
fd
)

16 if (
n
 == -2147483648)

18 
	`ft_putstr_fd
("-2147483648", 
fd
);

20 else if (
n
 < 0)

22 
	`ft_putchar_fd
('-', 
fd
);

23 
n
 = n * (-1);

24 
	`ft_putnbr_fd
(
n
, 
fd
);

26 else if (
n
 > 9)

28 
	`ft_putnbr_fd
(
n
 / 10, 
fd
);

29 
	`ft_putnbr_fd
((
n
 % 10), 
fd
);

32 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

33 
	}
}

	@libft/libft/ft_putstr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putstr_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

27 
	}
}

	@libft/libft/ft_split.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbsubstr
(const char *
s
, char 
c
)

16 unsigned int 
i
;

17 
size_t
 
count
;

19 
i
 = 0;

20 
count
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] != 
c
)

25 while (
s
[
i
] != 
c
 && s[i] != '\0')

26 
i
++;

27 
count
++;

29 while (
s
[
i
] == 
c
)

30 
i
++;

32 return (
count
);

33 
	}
}

35 unsigned int 
	$ft_start_index_substr
(char const *
s
, char 
c
, unsigned int 
start
)

37 while (
s
[
start
] == 
c
 && s[start] != '\0')

38 
start
++;

39 return (
start
);

40 
	}
}

42 unsigned int 
	$ft_nb_char_substr
(char const *
s
, char 
c
, unsigned int 
start
)

44 unsigned int 
nb_char_substr
;

46 
nb_char_substr
 = 0;

47 while (
s
[
start
] != 
c
 && s[start] != '\0')

49 
start
++;

50 
nb_char_substr
++;

52 return (
nb_char_substr
);

53 
	}
}

55 char *
ft_create_substr
(\

56 char const *
s
, char 
c
, unsigned int 
start
, unsigned int 
nb_char_substr
)

58 unsigned int 
	gi
;

59 char *
	gsubstr
;

61 
	gi
 = 0;

62 
	gsubstr
 = (char *)
ft_calloc
((
nb_char_substr
 + 1), sizeof(char));

63 if (!
	gsubstr
)

64 return (
	gNULL
);

65 while (
	gs
[
start
] != 
c
 && 
s
[start] != '\0' && 
i
 < 
nb_char_substr
)

66 
substr
[
i
++] = 
s
[
start
++];

67 return (
	gsubstr
);

70 char **
	$ft_split
(char const *
s
, char 
c
)

72 
size_t
 
nb_substr
;

73 
size_t
 
i
;

74 char **
tab2d
;

75 unsigned int 
start
;

76 unsigned int 
nb_char_substr
;

78 
i
 = 0;

79 
start
 = 0;

80 
nb_substr
 = 
	`ft_count_nbsubstr
(
s
, 
c
);

81 
tab2d
 = (char **)
	`ft_calloc
((
nb_substr
 + 1), sizeof(char *));

82 if (!
tab2d
)

83 return (
NULL
);

84 while (
s
[
start
] != '\0' && 
i
 < 
nb_substr
)

86 
start
 = 
	`ft_start_index_substr
(
s
, 
c
, start);

87 
nb_char_substr
 = 
	`ft_nb_char_substr
(
s
, 
c
, 
start
);

88 
tab2d
[
i
] = 
	`ft_create_substr
(
s
, 
c
, 
start
, 
nb_char_substr
);

89 
start
 = start + 
nb_char_substr
;

90 
i
++;

92 return (
tab2d
);

93 
	}
}

	@libft/libft/ft_strchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strchr
(const char *
s
, int 
c
)

16 int 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 if ((char)
c
 == 
s
[
i
])

22 return ((char *)(
s
 + 
i
));

23 
i
++;

25 if ((char)
c
 == '\0')

26 return ((char *)(
s
 + 
i
));

28 return (
NULL
);

29 
	}
}

	@libft/libft/ft_strcpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strcpy
(char *
dst
, const char *
src
)

16 int 
i
;

18 
i
 = 0;

19 while (
src
[
i
])

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 
dst
[
i
] = '\0';

25 return (
dst
);

26 
	}
}

	@libft/libft/ft_strcspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strcspn
(const char *
s
, const char *
reject
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
])

21 if (
	`ft_strchr
(
reject
, 
s
[
i
]) != 
NULL
)

22 return (
i
);

23 
i
++;

25 return (
i
);

26 
	}
}

	@libft/libft/ft_strdup.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strdup
(const char *
s1
)

16 int 
size
;

17 char *
s1_copie
;

19 
size
 = 
	`ft_strlen
(
s1
) + 1;

20 
s1_copie
 = (char *)
	`malloc
(
size
 * sizeof(char));

21 if (!
s1_copie
)

22 return (
NULL
);

23 
	`ft_strlcpy
(
s1_copie
, 
s1
, 
size
);

24 return (
s1_copie
);

25 
	}
}

	@libft/libft/ft_striteri.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*))

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`f
(
i
, &
s
[i]);

24 
i
++;

27 
	}
}

	@libft/libft/ft_strjoin.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strjoin
(char const *
s1
, char const *
s2
)

16 
size_t
 
size_s1
;

17 
size_t
 
size_s2
;

18 char *
strjoin
;

20 
size_s1
 = 
	`ft_strlen
(
s1
);

21 
size_s2
 = 
	`ft_strlen
(
s2
);

22 
strjoin
 = (char *)
	`malloc
((
size_s1
 + 
size_s2
 + 1) * sizeof(char));

23 if (!
strjoin
)

24 return (
NULL
);

25 
	`ft_memcpy
(
strjoin
, 
s1
, 
size_s1
);

26 
	`ft_memcpy
((
strjoin
 + 
size_s1
), 
s2
, 
size_s2
);

27 
	`ft_memset
((
strjoin
 + 
size_s1
 + 
size_s2
), 0, 1);

28 return (
strjoin
);

29 
	}
}

	@libft/libft/ft_strlcat.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcat
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
strlen_src
;

18 
size_t
 
strlen_dst
;

19 
size_t
 
temp
;

21 
i
 = 0;

22 
strlen_src
 = 
	`ft_strlen
(
src
);

23 
strlen_dst
 = 
	`ft_strlen
(
dst
);

24 
temp
 = 
strlen_dst
;

25 if (
dstsize
 < 
strlen_dst
)

26 return (
dstsize
 + 
strlen_src
);

27 if (
dstsize
 > 
strlen_dst
 + 1)

29 while (
src
[
i
] && 
strlen_dst
 != (
dstsize
 - 1))

31 
dst
[
strlen_dst
++] = 
src
[
i
++];

33 
dst
[
strlen_dst
] = '\0';

35 return (
temp
 + 
strlen_src
);

36 
	}
}

	@libft/libft/ft_strlcpy.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcpy
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
j
;

19 
i
 = 0;

20 
j
 = 0;

21 while (
src
[
i
] != '\0')

23 
i
++;

25 if (
dstsize
 > 0)

27 while (
j
 < (
dstsize
 - 1) && 
src
[j] != '\0')

29 
dst
[
j
] = 
src
[j];

30 
j
++;

32 
dst
[
j
] = '\0';

34 return (
i
);

35 
	}
}

	@libft/libft/ft_strlen.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlen
(const char *
s
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 
i
++;

23 return (
i
);

24 
	}
}

	@libft/libft/ft_strmapi.c

12 #include 
	~"../includes/libft.h
"

14 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char))

16 unsigned int 
i
;

17 
size_t
 
size
;

18 char *
strmapi
;

20 
i
 = 0;

21 
size
 = 
	`ft_strlen
(
s
);

22 
strmapi
 = (char *)
	`malloc
((
size
 + 1) * sizeof(char));

23 if (!
strmapi
)

24 return (
NULL
);

25 while (
s
[
i
] != '\0')

27 
strmapi
[
i
] = 
	`f
(i, 
s
[i]);

28 
i
++;

30 
strmapi
[
i
] = '\0';

31 return (
strmapi
);

32 
	}
}

	@libft/libft/ft_strncmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (((unsigned char)
s1
[
i
] || (unsigned char)
s2
[i]) && i < 
n
)

21 if (
s1
[
i
] != 
s2
[i])

22 return ((unsigned char)
s1
[
i
] - (unsigned char)
s2
[i]);

23 
i
++;

26 
	}
}

	@libft/libft/ft_strncpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strncpy
(char *
dst
, const char *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
src
[
i
] && i < 
len
)

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 while (
i
 < 
len
)

26 
dst
[
i
] = '\0';

27 
i
++;

29 return (
dst
);

30 
	}
}

	@libft/libft/ft_strnstr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
)

16 
size_t
 
len_needle
;

17 
size_t
 
len_haystack
;

19 
len_needle
 = 
	`ft_strlen
(
needle
);

20 
len_haystack
 = 
	`ft_strlen
(
haystack
);

21 if (
needle
[0] == '\0')

22 return ((char *)(
haystack
));

23 if (
len_needle
 > 
len_haystack
 || 
len
 < len_needle)

24 return (
NULL
);

25 if (
len
 > 
len_haystack
)

26 
len
 = 
len_haystack
;

27 while (
len
 >= 
len_needle
 && 
haystack
)

29 if (
	`ft_memcmp
(
haystack
, 
needle
, 
len_needle
) == 0)

30 return ((char *)(
haystack
));

33 
haystack
++;

34 
len
--;

37 return (
NULL
);

38 
	}
}

	@libft/libft/ft_strpbrk.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strpbrk
(const char *
s1
, const char *
s2
)

16 int 
i
;

18 
i
 = 0;

19 while (
s1
[
i
] != '\0')

21 if (
	`ft_strchr
(
s2
, 
s1
[
i
]) != 0)

23 return ((char *) &
s1
[
i
]);

25 ++
i
;

28 
	}
}

	@libft/libft/ft_strrchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strrchr
(const char *
s
, int 
c
)

16 int 
i
;

17 int 
k
;

19 
i
 = 0;

20 
k
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] == (char)
c
)

24 
k
 = 
i
;

25 
i
++;

27 if (
s
[
k
] == (char)
c
)

28 return ((char *)(
s
 + 
k
));

29 else if ((char)
c
 == 
s
[
i
])

30 return ((char *)(
s
 + 
i
));

32 return (
NULL
);

33 
	}
}

	@libft/libft/ft_strspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strspn
(const char *
s
, const char *
accept
)

16 
size_t
 
count
;

17 
size_t
 
i
;

19 
count
 = 0;

20 
i
 = 0;

21 while (
s
[
i
] && 
	`ft_strchr
(
accept
, s[i]) != 0)

23 
count
++;

24 
i
++;

26 return (
count
);

27 
	}
}

	@libft/libft/ft_strtrim.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strtrim
(char const *
s1
, char const *
set
)

16 unsigned int 
front
;

17 unsigned int 
end
;

18 unsigned int 
i
;

19 char *
strtrim
;

21 
front
 = 0;

22 
i
 = 0;

23 
end
 = (unsigned int)(
	`ft_strlen
(
s1
));

24 while (
s1
[
front
] != '\0' && 
	`ft_strchr
(
set
, *(s1 + front)) != 
NULL
)

25 
front
++;

26 while (
front
 < 
end
 && 
	`ft_strrchr
(
set
, *(
s1
 + end - 1)) != 
NULL
)

27 
end
--;

28 
strtrim
 = (char *)
	`malloc
((
end
 - 
front
 + 1) * sizeof(char));

29 if (!
strtrim
)

30 return (
NULL
);

31 
i
 = 0;

32 while (
front
 < 
end
)

33 
strtrim
[
i
++] = 
s1
[
front
++];

34 
strtrim
[
i
] = 0;

35 return (
strtrim
);

36 
	}
}

	@libft/libft/ft_substr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
)

16 char *
substr
;

17 unsigned int 
i
;

18 
size_t
 
size
;

20 
i
 = 0;

21 if (!
s
)

22 return (
NULL
);

23 
size
 = 
	`ft_strlen
(
s
);

24 if (
len
 > 
size
)

25 
len
 = 
size
;

26 if (
start
 >= (unsigned int)
size
)

28 
substr
 = (char *)
	`malloc
(1 * sizeof(char));

29 if (!
substr
)

30 return (
NULL
);

31 
substr
[0] = '\0';

32 return (
substr
);

34 
substr
 = (char *)
	`malloc
((
len
 + 1) * sizeof(char));

35 if (!
substr
)

36 return (
NULL
);

37 while (
i
 < (unsigned int)
len
 && 
s
[
start
] != '\0' )

38 
substr
[
i
++] = 
s
[
start
++];

39 
substr
[
i
] = '\0';

40 return (
substr
);

41 
	}
}

	@libft/libft/ft_tolower.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_tolower
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

17 return (
c
 + 32);

19 return (
c
);

20 
	}
}

	@libft/libft/ft_toupper.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_toupper
(int 
c
)

16 if (
c
 >= 'a' && c <= 'z')

17 return (
c
 - 32);

19 return (
c
);

20 
	}
}

	@libft/libft/power.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$power
(int 
str_base
, int 
power
)

16 int 
result
;

18 
result
 = 1;

19 if (
power
 < 0 || 
str_base
 == 0)

23 while (
power
 > 0)

25 
result
 = result * 
str_base
;

26 
power
--;

28 return (
result
);

29 
	}
}

	@libft/libft/str_lowercase.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$str_lowercase
(char *
str
)

16 int 
i
;

18 
i
 = 0;

19 while (
str
[
i
])

21 if (
str
[
i
] >= 'A' && str[i] <= 'Z')

22 
str
[
i
] += 32;

23 
i
++;

25 return (
str
);

26 
	}
}

	@main.c

2 #include 
	~"minishell.h
"

4 
t_shell
 *
	gg_shell
;

10 void 
	$print_env
(
t_env
 **
head
)

12 
t_env
 *
ptr
;

14 
ptr
 = *
head
;

15 if (!
head
 || !*head)

17 while (
ptr
)

19 
	`ft_printf
("print_env function: %s\n", 
ptr
->
var_name
);

20 
	`ft_printf
("print_env function: %s\n", 
ptr
->
var_value
);

21 
ptr
 = ptr->
next
;

23 
	}
}

26 void 
	$free_shell
(void)

28 
	`free_env
(&
g_shell
->
env
);

30 if (
g_shell
)

31 
	`free
(
g_shell
);

32 
	}
}

34 int 
	$init_shell
(char **
envp
)

36 
g_shell
 = 
	`ft_calloc
(1, sizeof(
t_shell
));

37 if (!
g_shell
)

39 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

42 if (!*
envp
)

47 
g_shell
->
env
 = 
	`get_envp
(
envp
);

48 if (!
g_shell
->
env
)

50 
	`free_shell
();

51 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

54 
g_shell
->
exit_status
 = 0;

55 
	`print_env
(&
g_shell
->
env
);

57 
	}
}

60 int 
	$main
(int 
ac
, char **
av
, char **
envp
)

62 (void)
av
;

63 (void)
ac
;

64 char *
line
;

65 
t_token
 *
token
;

67 if (!
	`init_shell
(
envp
))

69 if (
	`sig_handler
() == -1)

73 
line
 = 
NULL
;

74 
line
 = 
	`readline
(
BLU_2
"minishell$ "
RESET
);

75 if (!
line
)

77 
	`rl_clear_history
();

80 if (
line
[0])

81 
	`add_history
(
line
);

84 
t_cmd
 *
cmd
;

85 if (
	`ft_strncmp
(
line
, "pwd", 3) == 0)

87 
cmd
 = 
	`malloc
(sizeof(
t_cmd
));

88 if (!
cmd
)

90 
	`_pwd
(
cmd
);

93 
token
 = 
	`parsing
(
line
);

95 
g_shell
->
exit_status
 = 0;

96 
	`free_token
(&
token
);

98 
	`free_shell
();

100 
	}
}

	@main_parsing_syntax_errors.c

12 #include 
	~"minishell.h
"

14 int 
	gg_exit_status
 = 0;

18 int 
	$main
(int 
ac
, char **
av
)

20 (void)
ac
;

21 char *
line
;

22 
line
 = 
	`ft_strdup
(
av
[1]);

23 
	`syntax_error_check
(
line
);

24 
	`printf
("exit_status = %d\n", 
exit_status
);

25 return (
exit_status
);

26 
	}
}

	@main_parsing_token_extraction.c

12 #include 
	~"minishell.h
"

14 int 
	gexit_status
 = 0;

26 int 
	$main
(int 
ac
, char **
av
)

28 (void)
ac
;

29 
t_token
 *
head
;

30 
t_token
 *
ptr
;

31 char *
line
;

33 
line
 = 
NULL
;

34 
head
 = 
NULL
;

35 
line
 = 
	`ft_strdup
(
av
[1]);

36 
head
 = 
	`get_words
(
line
);

37 if (!
head
)

39 
	`printf
(" exit from main\n");

40 return (
exit_status
);

42 
ptr
 = 
head
;

43 while (
ptr
)

45 
	`printf
("from main: %s\n", 
ptr
->
content
);

46 
ptr
 = ptr->
next
;

48 
	`free_token
(&
head
);

49 return (
exit_status
);

50 
	}
}

	@main_token_routine.c

12 #include 
	~"minishell.h
"

14 int 
	gg_exit_status
 = 0;

18 int 
	$main
(int 
ac
, char **
av
)

20 (void)
ac
;

21 
t_token
 *
head
;

22 
t_token
 *
ptr
;

23 int 
i
;

24 int 
j
;

25 char **
line
;

27 
i
 = 0;

28 
j
 = 1;

29 
line
 = 
	`malloc
(sizeof(char *) * 
ac
);

30 while (
av
[
j
])

32 
line
[
i
] = 
	`ft_strdup
(
av
[
j
]);

33 
i
++;

34 
j
++;

36 
line
[
i
] = 
NULL
;

37 
head
 = 
NULL
;

38 
head
 = 
	`new_token
(
line
[0], 0, 
	`ft_strlen
(line[0]));

39 if (!
head
)

41 
	`printf
("malloc: %s\n", 
	`strerror
(
errno
));

44 
i
 = 1;

45 while (
line
[
i
])

47 
	`token_linked_list
(&
head
, 
line
[
i
], 0, 
	`ft_strlen
(line[i]));

48 
i
++;

50 
i
 = 0;

51 
ptr
 = 
head
;

52 while (
ptr
)

54 
	`printf
("%s\n", 
ptr
->
content
);

55 
ptr
 = ptr->
next
;

56 
i
++;

58 
	`free_token
(&
head
);

59 return (
exit_status
);

60 
	}
}

	@malloc_error_print_message.c

12 #include 
	~"minishell.h
"

14 void 
	$malloc_error_print_message
(char *
s
)

16 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
s
);

17 
g_shell
->
exit_status
 = 1;

18 
	}
}

	@minishell.h

1 #ifndef 
MINISHELL_H


2 #define 
	#MINISHELL_H


	)

4 #include 
	~<stdio.h
>

5 #include 
	~<string.h
>

6 #include 
	~<stdlib.h
>

7 #include 
	~<errno.h
>

8 #include 
	~<curses.h
>

9 #include 
	~<term.h
>

10 #include 
	~<signal.h
>

11 #include 
	~<unistd.h
>

12 #include 
	~<fcntl.h
>

13 #include 
	~<stdarg.h
>

14 #include 
	~<sys/wait.h
>

15 #include 
	~<sys/stat.h
>

16 #include 
	~<sys/types.h
>

17 #include 
	~<readline/readline.h
>

18 #include 
	~<readline/history.h
>

19 #include 
	~"libft/includes/libft.h
"

22 #define 
	#RED
 "\x1b[31m"

	)

23 #define 
	#BLU
 "\x1B[34m"

	)

24 #define 
	#BLU_2
 "\e[1;34m"

	)

25 #define 
	#GRN
 "\x1B[32m"

	)

26 #define 
	#YEL
 "\x1B[33m"

	)

27 #define 
	#MAG
 "\x1B[35m"

	)

28 #define 
	#CYN
 "\x1B[36m"

	)

29 #define 
	#WHT
 "\x1B[37m"

	)

30 #define 
	#RESET
 "\x1B[0m"

	)

32 #define 
	#WORD
 1

	)

33 #define 
	#PIPELINE
 2

	)

34 #define 
	#L_CHEVRON
 3

	)

35 #define 
	#R_CHEVRON
 4

	)

36 #define 
	#APPEND
 5

	)

37 #define 
	#HERE_DOC
 6

	)

38 #define 
	#DOLLAR
 7

	)

39 #define 
	#QUESTION
 8

	)

40 #define 
	#EXPAND
 9

	)

41 #define 
	#DELETE
 10

	)

46 typedef struct 
	ss_env


48 char *
	mvar_name
;

49 char *
	mvar_value
;

50 struct 
s_env
 *
	mnext
;

51 } 
	tt_env
;

53 typedef struct 
	ss_token


55 char *
	mcontent
;

56 int 
	mid
;

58 struct 
s_token
 *
	mnext
;

59 } 
	tt_token
;

62 typedef struct 
	ss_cmd


65 char **
	mcmd
;

66 char **
	mredir
;

67 char **
	mpath
;

71 int 
	mfdout
;

72 int 
	mfdin
;

73 int 
	mfd
[2];

74 } 
	tt_cmd
;

76 typedef struct 
	ss_shell


78 
t_env
 *
	menv
;

79 int 
	mexit_status
;

81 } 
	tt_shell
;

84 extern 
t_shell
 *
g_shell
;

86 void 
expansion
(
t_token
 **
token
, int 
pos
);

87 int 
join_tokens
(
t_token
 **
new
, t_token *
tmp
);

88 void 
delete_token
(
t_token
 **
head
);

89 int 
token_list_size
(
t_token
 **
head
);

90 int 
expand_var
(
t_token
 **
head
);

91 
t_token
 *
split_and_join_var
(t_token *
tmp
, int 
start
, int 
len
);

92 int 
prepare_expand
(
t_token
 *
tmp
, int 
i
);

93 void 
set_id_expansion
(
t_token
 *
token
);

95 int 
_pwd
(
t_cmd
 *
cmd
);

96 int 
_env
(
t_env
 *
env
);

99 char **
env_copied
(char **
envp
);

100 void 
free_tab
(char **
table
);

103 
t_env
 *
get_envp
(char **
envp
);

104 void 
free_env
(
t_env
 **
head
);

108 
t_token
 *
parsing
(char *
line
);

109 int 
syntax_error_check
(char *
s
);

110 int 
check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
);

111 int 
check_quotes_errors
(char *
s
, char 
c
, int *
i
);

112 int 
count_metachar
(char *
s
, char 
c
, int 
num
);

113 int 
check_multiple_operators_error
(int 
i
, int 
num
, char 
c
);

114 void 
print_syntax_error_char
(char 
c
);

115 void 
print_syntax_error_dchar
(char 
c
);

116 void 
print_syntax_error_str
(char *
s
);

119 int 
character_extraction
(char *
line
, int 
ind
);

120 int 
token_extraction
(char *
line
, int 
ind
);

121 
t_token
 *
get_tokens
(char *
line
);

122 int 
get_tokens_size
(char *
line
, int *
i
);

123 
t_token
 *
create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
);

126 void 
malloc_error_print_message
(char *
s
);

129 
t_token
 *
new_token
(char *
line
, int 
start
, int 
len
);

130 void 
set_id
(
t_token
 *
token
);

131 int 
token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
);

132 int 
link_token
(
t_token
 **
head
, t_token *
new
);

133 void 
free_token
(
t_token
 **
head
);

136 int 
is_dollar
(char 
c
);

137 int 
is_pipeline
(char 
c
);

138 int 
is_chevron
(char 
c
);

139 int 
is_lchevron
(char 
c
);

140 int 
is_rchevron
(char 
c
);

141 int 
is_operator
(char 
c
);

142 int 
is_newline
(char 
c
);

143 int 
is_white_space
(char 
c
);

144 int 
is_blank
(char 
c
);

145 int 
is_metacharacter
(char 
c
);

146 int 
is_delimiter
(char 
c
);

147 int 
is_word
(char 
c
);

148 int 
is_double_quote
(char 
c
);

149 int 
is_simple_quote
(char 
c
);

150 int 
is_quote
(char 
c
);

151 int 
is_question
(char 
c
);

152 int 
is_punct
(char 
c
);

155 int 
sig_handler
(void);

158 void 
handler_ctr_c
(int 
code
);

161 char **
ft_splitpath
(char *
s
, char 
c
);

	@parsing.c

12 #include 
	~"minishell.h
"

16 void 
	$print_token
(
t_token
 **
head
)

18 
t_token
 *
tmp
;

20 if (!*
head
 || !head)

22 
tmp
 = *
head
;

23 while (
tmp
)

25 if (
tmp
->
id
 == 
L_CHEVRON
)

26 
	`printf
("L_CHEVRON: ");

27 else if (
tmp
->
id
 == 
R_CHEVRON
)

28 
	`printf
("R_CHEVRON: ");

29 else if (
tmp
->
id
 == 
PIPELINE
)

30 
	`printf
("PIPELINE: ");

31 else if (
tmp
->
id
 == 
WORD
)

32 
	`printf
("WORD: ");

33 else if (
tmp
->
id
 == 
APPEND
)

34 
	`printf
("APPEND: ");

35 else if (
tmp
->
id
 == 
HERE_DOC
)

36 
	`printf
("HERE_DOC: ");

37 else if (
tmp
->
id
 == 
DOLLAR
)

38 
	`printf
("DOLLAR:");

39 
	`printf
("|%-s|\n", 
tmp
->
content
);

40 
tmp
 = tmp->
next
;

42 
	}
}

44 
t_token
 *
	$parsing
(char *
line
)

46 
t_token
 *
token
;

48 if (!
	`syntax_error_check
(
line
))

49 return (
NULL
);

50 
token
 = 
	`get_tokens
(
line
);

51 if (!
token
)

52 return (
NULL
);

53 
	`expansion
(&
token
, 0);

54 
	`print_token
(&
token
);

56 return (
token
);

57 
	}
}

	@parsing_expansion.c

12 #include 
	~"minishell.h
"

14 int 
	$loop_dollars
(char *
s
, int 
i
)

16 while (
	`is_dollar
(
s
[
i
]) && s[i])

17 
i
++;

18 if (
s
[
i
] != '\0')

19 
i
--;

20 return (
i
);

21 
	}
}

23 int 
	$loop_simple_quotes
(char *
s
, int 
i
)

25 
i
++;

26 while (!
	`is_simple_quote
(
s
[
i
]))

27 
i
++;

28 return (
i
);

30 
	}
}

32 int 
	$check_dollar
(
t_token
 *
tmp
, int 
pos
)

34 int 
i
;

36 
i
 = 
pos
;

37 while (
tmp
->
content
[
i
])

39 if (
	`is_simple_quote
(
tmp
->
content
[
i
]))

40 
i
 = 
	`loop_simple_quotes
(
tmp
->
content
, i);

41 if (
	`is_dollar
(
tmp
->
content
[
i
]))

43 if (
	`is_question
(
tmp
->
content
[
i
 + 1]) || \

44 (!
	`is_quote
(
tmp
->
content
[
i
 + 1]) && \

45 !
	`is_dollar
(
tmp
->
content
[
i
 + 1]) && \

46 !
	`is_punct
(
tmp
->
content
[
i
 + 1]) && \

47 
tmp
->
content
[
i
 + 1] != '\0'))

50 
i
 = 
	`prepare_expand
(
tmp
, i);

51 return (
i
);

53 else if (
	`is_dollar
(
tmp
->
content
[
i
 + 1]))

54 
i
 = 
	`loop_dollars
(
tmp
->
content
, i);

55 else if (
tmp
->
content
[
i
 + 1] == '\0')

59 
i
++;

61 
tmp
->
id
 = 
WORD
;

62 return (
i
);

63 
	}
}

65 void 
	$expansion
(
t_token
 **
head
, int 
pos
)

67 
t_token
 *
tmp
;

68 
t_token
 *
next
;

70 
tmp
 = *
head
;

71 
next
 = 
NULL
;

72 if (!*
head
)

74 if (
tmp
)

76 if (
tmp
->
id
 == 
DOLLAR
)

78 
pos
 = 
	`check_dollar
(
tmp
, pos);

79 if (
tmp
->
id
 == 
DELETE
)

81 
	`delete_token
(
head
);

82 if (*
head
 && 
tmp
->
next
)

84 
next
 = 
tmp
->next;

85 
	`expansion
(&
next
, 
pos
);

89 
head
 = 
NULL
;

93 
	`expansion
(&
tmp
, 
pos
);

97 
pos
 = 0;

98 if (
tmp
->
next
)

100 
tmp
 = tmp->
next
;

101 
	`expansion
(&
tmp
, 
pos
);

106 
	}
}

	@parsing_expansion_helper.c

12 #include 
	~"minishell.h
"

14 void 
	$print_test_expansion
(
t_token
 **
head
)

16 
t_token
 *
tmp
;

18 
tmp
 = *
head
;

19 
	`printf
("---------test expansion---------\n");

20 while (
tmp
)

22 
	`printf
("%s|", 
tmp
->
content
);

23 
tmp
 = tmp->
next
;

25 
	`printf
("\n");

26 
	`printf
("---------end test expansion---------\n");

27 
	}
}

29 int 
	$get_new_size
(
t_token
 **
new
)

31 
t_token
 *
ptr
;

32 int 
size
;

33 int 
i
;

35 
size
 = 0;

36 
i
 = 0;

37 
ptr
 = *
new
;

38 while (
ptr
)

40 if (
ptr
->
id
 != 
DELETE
)

42 while (
ptr
->
content
[
i
])

44 
size
++;

45 
i
++;

47 
i
 = 0;

49 
ptr
 = ptr->
next
;

51 return (
size
);

52 
	}
}

55 int 
	$join_tokens
(
t_token
 **
new
, t_token *
curr
)

57 int 
size
;

58 
t_token
 *
ptr
;

59 int 
i
;

60 int 
j
;

62 
i
 = 0;

63 
j
 = 0;

64 
size
 = 
	`get_new_size
(
new
);

65 
	`free
(
curr
->
content
);

66 
curr
->
content
 = 
NULL
;

67 if (
size
 == 0)

69 
	`free_token
(
new
);

70 
curr
->
id
 = 
DELETE
;

73 
curr
->
content
 = 
	`malloc
((
size
 + 1) * sizeof(char));

74 if (!
curr
->
content
)

76 
ptr
 = *
new
;

77 while (
ptr
)

79 if (
ptr
->
id
 == 
DELETE
)

80 
ptr
 = ptr->
next
;

83 while (
ptr
->
content
[
j
])

85 
curr
->
content
[
i
] = 
ptr
->content[
j
];

86 
i
++;

87 
j
++;

89 
ptr
 = ptr->
next
;

90 
j
 = 0;

93 
curr
->
content
[
i
] = '\0';

94 
	`free_token
(
new
);

96 
	}
}

99 int 
	$check_var_exist
(
t_token
 *
tmp
)

101 if (
	`ft_strncmp
(&
tmp
->
content
[1], "?", 1) == 0)

103 
	`free
(
tmp
->
content
);

104 
tmp
->
content
 = 
NULL
;

105 
tmp
->
content
 = 
	`ft_strdup
(
	`ft_itoa
(
g_shell
->
exit_status
));

106 if (!
tmp
->
content
)

108 
	`malloc_error_print_message
("ft_strdup failed");

114 else if (
	`ft_strncmp
(
g_shell
->
env
->
var_name
, &
tmp
->
content
[1], \

115 
	`ft_strlen
(
tmp
->
content
)) == 0)

117 
	`free
(
tmp
->
content
);

118 
tmp
->
content
 = 
NULL
;

119 
tmp
->
content
 = 
	`ft_strdup
(
g_shell
->
env
->
var_value
);

120 if (!
tmp
->
content
)

122 
	`malloc_error_print_message
("ft_strdup failed");

128 
	}
}

131 int 
	$expand_var
(
t_token
 **
new
)

133 
t_token
 *
tmp
;

134 
t_env
 *
save
;

136 
tmp
 = *
new
;

137 
save
 = 
g_shell
->
env
;

138 while (
tmp
->
id
 != 
EXPAND
)

139 
tmp
 = tmp->
next
;

140 while (
g_shell
->
env
)

142 if (
	`check_var_exist
(
tmp
))

144 
tmp
->
id
 = 
WORD
;

145 
g_shell
->
env
 = 
save
;

146 return (
	`ft_strlen
(
tmp
->
content
));

148 
g_shell
->
env
 = g_shell->env->
next
;

150 
tmp
->
id
 = 
DELETE
;

151 
g_shell
->
env
 = 
save
;

153 
	}
}

156 
t_token
 *
	$split_tokens
(char *
s
, int 
start
, int 
len
)

158 
t_token
 *
new
;

160 
new
 = 
NULL
;

161 if (
start
 != 0)

163 
new
 = 
	`new_token
(
s
, 0, 
start
);

164 
	`token_linked_list
(&
new
, 
s
, 
start
, 
len
);

165 
new
->
next
->
id
 = 
EXPAND
;

169 
new
 = 
	`new_token
(
s
, 
start
, 
len
);

170 
new
->
id
 = 
EXPAND
;

172 
len
 = 
start
 + len;

173 
start
 = 
len
;

174 while (
s
[
len
])

175 
len
++;

176 if (
len
 != 
start
)

177 
	`token_linked_list
(&
new
, 
s
,
start
, 
len
);

178 return (
new
);

179 
	}
}

181 int 
	$var_len
(char *
s
, int 
i
)

183 int 
len
;

185 
len
 = 0;

186 
i
++;

187 if (
	`is_question
(
s
[
i
]))

191 while (
s
[
i
] && \

192 !
	`is_white_space
(
s
[
i
]) && \

193 !
	`is_quote
(
s
[
i
]) && \

194 !
	`is_question
(
s
[
i
]) && \

195 !
	`is_dollar
(
s
[
i
]) && \

196 !
	`is_punct
(
s
[
i
]))

198 
i
++;

199 
len
++;

202 return (
len
);

203 
	}
}

205 int 
	$prepare_expand
(
t_token
 *
curr
, int 
i
)

207 
t_token
 *
new
;

208 int 
len
;

210 
new
 = 
NULL
;

211 
len
 = 
	`var_len
(
curr
->
content
, 
i
);

212 
new
 = 
	`split_tokens
(
curr
->
content
, 
i
, 
len
 + 1);

213 
len
 = 
	`expand_var
(&
new
);

214 
	`join_tokens
(&
new
, 
curr
);

215 if (
curr
->
id
 == 
DELETE
)

217 
	`set_id_expansion
(
curr
);

218 if (
len
 == -1)

220 return(
len
 + 
i
);

221 
	}
}

	@parsing_syntax_errors.c

12 #include 
	~"minishell.h
"

14 int 
	$check_multiple_operators_error
(int 
i
, int 
num
, char 
c
)

16 if (
i
 > 
num
)

18 if (
	`is_chevron
(
c
))

19 
	`print_syntax_error_dchar
(
c
);

20 else if (
	`is_pipeline
(
c
))

21 
	`print_syntax_error_char
(
c
);

25 
	}
}

27 int 
	$count_metachar
(char *
s
, char 
c
, int 
num
)

29 int 
i
;

31 
i
 = 1;

32 while (
s
[
i
] && s[i] == 
c
)

33 
i
++;

34 if (!
	`check_multiple_operators_error
(
i
, 
num
, 
c
))

36 while (
s
[
i
] && 
	`is_blank
(s[i]))

37 
i
++;

38 if (
	`is_operator
(
s
[
i
]) && !
	`is_pipeline
(
c
))

40 
c
 = 
s
[
i
];

41 if (
	`is_chevron
(
c
) && is_chevron(
s
[
i
 + 1]))

43 
	`print_syntax_error_dchar
(
c
);

47 
	`print_syntax_error_char
(
c
);

50 else if (
s
[
i
] == '\0')

52 
	`print_syntax_error_str
("newline");

56 
	}
}

58 int 
	$check_quotes_errors
(char *
s
, char 
c
, int *
i
)

60 int 
j
;

62 
j
 = *
i
 + 1;

63 while (
s
[
j
] && s[j] != 
c
)

64 
j
++;

65 if (
s
[
j
] != 
c
)

67 
	`print_syntax_error_char
(
c
);

70 (*
i
)++;

71 while (
s
[*
i
] && s[*i] != 
c
)

72 (*
i
)++;

74 
	}
}

76 int 
	$check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
)

78 int 
j
;

80 
j
 = 0;

81 while (
s
[
j
] && 
	`is_blank
(s[j]))

82 
j
++;

83 if (
s
[
j
] == 
c
)

85 
	`print_syntax_error_char
(
c
);

88 if (!
	`count_metachar
(&
s
[
i
], 
c
, 
num
))

91 
	}
}

138 int 
	$syntax_error_check
(char *
s
)

140 int 
i
;

142 
i
 = 0;

143 while (
s
[
i
])

145 if (
	`is_quote
(
s
[
i
]))

147 if (!
	`check_quotes_errors
(
s
, s[
i
], &i))

148 return (
	`free
(
s
), 0);

150 else if ((
	`is_lchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '<', 2)) || \

151 (
	`is_rchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '>', 2)))

152 return (
	`free
(
s
), 0);

153 else if (
	`is_pipeline
(
s
[
i
]) && !
	`check_pipeline_errors
(s, i, '|', 1))

154 return (
	`free
(
s
), 0);

155 
i
++;

158 
	}
}

	@parsing_syntax_errors_print_message.c

12 #include 
	~"minishell.h
"

19 void 
	$print_syntax_error_char
(char 
c
)

21 
	`ft_dprintf
(2, "minishell: ");

22 
	`ft_dprintf
(2, "syntax error near unexpected token ");

23 
	`ft_dprintf
(2, "\'%c\'\n", 
c
);

24 
g_shell
->
exit_status
 = 258;

25 
	}
}

27 void 
	$print_syntax_error_dchar
(char 
c
)

29 
	`ft_dprintf
(2, "minishell: ");

30 
	`ft_dprintf
(2, "syntax error near unexpected token ");

31 
	`ft_dprintf
(2, "\'%c%c\'\n", 
c
, c);

32 
g_shell
->
exit_status
 = 258;

33 
	}
}

35 void 
	$print_syntax_error_str
(char *
s
)

37 
	`ft_dprintf
(2, "minishell: ");

38 
	`ft_dprintf
(2, "syntax error near unexpected token ");

39 
	`ft_dprintf
(2, "\'%s\'\n", 
s
);

40 
g_shell
->
exit_status
 = 258;

41 
	}
}

	@parsing_token_extraction.c

12 #include 
	~"minishell.h
"

21 int 
	$character_extraction
(char *
line
, int 
ind
)

23 if ((
line
[
ind
] == '>' && line[ind + 1] == '>') || \

24 (
line
[
ind
] == '<' && line[ind + 1] == '<'))

27 
	}
}

43 int 
	$word_extraction
(char *
line
, int 
ind
)

45 int 
start
;

46 char 
c
;

48 
start
 = 
ind
;

49 while (
	`is_word
(
line
[
ind
]) && line[ind])

51 if (
	`is_quote
(
line
[
ind
]))

53 
c
 = 
line
[
ind
];

54 
ind
++;

55 while (
line
[
ind
] && line[ind] != 
c
)

56 
ind
++;

58 
ind
++;

60 return (
ind
 - 
start
);

61 
	}
}

64 int 
	$get_tokens_size
(char *
line
, int *
i
)

66 int 
len
;

68 
len
 = 0;

69 while (
	`is_blank
(
line
[*
i
]))

70 (*
i
)++;

71 if (
	`is_word
(
line
[*
i
]))

72 
len
 = 
	`word_extraction
(
line
, *
i
);

73 else if (
	`is_operator
(
line
[*
i
]))

74 
len
 = 
	`character_extraction
(
line
, *
i
);

75 return (
len
);

76 
	}
}

83 
t_token
 *
	$create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
)

85 
t_token
 *
head
;

87 
head
 = 
	`new_token
(
line
, 
i
, 
len
);

88 if (!
head
)

89 return (
NULL
);

90 *
flag
 = 1;

91 return (
head
);

92 
	}
}

122 
t_token
 *
	$get_tokens
(char *
line
)

124 int 
i
;

125 int 
len
;

126 int 
flag
;

127 
t_token
 *
head
;

129 
i
 = 0;

130 
flag
 = 0;

131 
head
 = 
NULL
;

132 while (
line
[
i
])

134 
len
 = 
	`get_tokens_size
(
line
, &
i
);

135 if (
len
 == 0)

137 if (!
flag
)

139 
head
 = 
	`create_token_head
(
line
, 
i
, 
len
, &
flag
);

140 if (!
head
)

141 return (
	`free
(
line
), 
NULL
);

144 if (!
	`token_linked_list
(&
head
, 
line
, 
i
, 
len
))

145 return (
	`free_token
(&
head
), 
	`free
(
line
), 
NULL
);

146 
i
 += 
len
;

148 return (
	`free
(
line
), 
head
);

149 
	}
}

	@test_getenv.c

1 #include 
	~"minishell.h
"

6 int 
	$main
(int 
ac
, char **
av
, char **
envp
)

8 (void)
ac
;

9 (void)
av
;

11 
t_env
 **
env
;

12 
t_env
 *
ptr
;

13 
env
 = 
	`get_envp
(
envp
);

14 if (!
env
)

16 
ptr
 = *
env
;

17 while (
ptr
 != 
NULL
)

19 
	`printf
("%s", 
ptr
->
var_name
);

20 
	`printf
("%s\n", 
ptr
->
var_value
);

21 
ptr
 = ptr->
next
;

24 
	}
}

	@token_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_token
(
t_token
 **
head
)

16 
t_token
 *
ptr
;

17 
t_token
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
content
);

27 
	`free
(
tmp
);

29 *
head
 = 
NULL
;

30 
	}
}

45 
t_token
 *
	$new_token
(char *
line
, int 
start
, int 
len
)

47 
t_token
 *
token
;

49 
token
 = 
	`malloc
(sizeof(
t_token
));

50 if (!
token
)

52 
	`malloc_error_print_message
(
	`strerror
(
errno
));

53 return (
NULL
);

55 
token
->
content
 = 
	`ft_substr
(
line
, 
start
, 
len
);

56 if (!
token
->
content
)

58 
	`malloc_error_print_message
(
	`strerror
(
errno
));

59 return (
	`free_token
(&
token
), 
NULL
);

61 
	`set_id
(
token
);

63 
token
->
next
 = 
NULL
;

64 return (
token
);

65 
	}
}

74 int 
	$link_token
(
t_token
 **
head
, t_token *
new
)

76 
t_token
 *
ptr
;

78 if (!
new
)

80 
ptr
 = *
head
;

81 while (
ptr
)

83 if (!
ptr
->
next
)

85 
ptr
 = ptr->
next
;

87 
ptr
->
next
 = 
new
;

89 
	}
}

112 int 
	$token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
)

114 
t_token
 *
new
;

116 if (!
head
)

118 
new
 = 
	`new_token
(
line
, 
start
, 
len
);

119 if (!
new
)

121 if (!
	`link_token
(
head
, 
new
))

124 
	}
}

	@token_routine_delete.c

12 #include 
	~"minishell.h
"

14 int 
	$token_list_size
(
t_token
 **
head
)

16 
t_token
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

28 void 
	$delete_token
(
t_token
 **
head
)

30 int 
i
;

31 int 
size
;

32 
t_token
 *
curr
;

33 
t_token
 *
prev
;

35 
i
 = 0;

36 
size
 = 
	`token_list_size
(
head
);

37 
curr
 = *
head
;

38 
prev
 = *
head
;

39 while (
curr
->
id
 != 
DELETE
)

41 
prev
 = 
curr
;

42 
curr
 = curr->
next
;

43 
i
++;

45 if (
i
 == 0 && 
size
 == 1)

47 
	`free
((*
head
)->
content
);

48 
	`free
 (*
head
);

49 *
head
 = 
NULL
;

52 else if (
i
 == 0 && 
size
 > 1)

53 (*
head
) = (*head)->
next
;

54 else if (
i
 == 
size
 - 1)

55 
prev
->
next
 = 
NULL
;

57 
prev
->
next
 = 
curr
->next;

58 
	`free
(
curr
->
content
);

59 
	`free
(
curr
);

60 
	}
}

	@token_routine_set_id.c

12 #include 
	~"minishell.h
"

14 void 
	$set_id_expansion
(
t_token
 *
token
)

16 if (
	`ft_strchr
(
token
->
content
, '$'))

17 
token
->
id
 = 
DOLLAR
;

19 
token
->
id
 = 
WORD
;

21 
	}
}

23 void 
	$set_id
(
t_token
 *
token
)

25 if (
	`ft_strncmp
(
token
->
content
, "|", 2) == 0)

26 
token
->
id
 = 
PIPELINE
;

27 else if (
	`ft_strncmp
(
token
->
content
, "<", 2) == 0)

28 
token
->
id
 = 
L_CHEVRON
;

29 else if (
	`ft_strncmp
(
token
->
content
, ">", 2) == 0)

30 
token
->
id
 = 
R_CHEVRON
;

31 else if (
	`ft_strncmp
(
token
->
content
, "<<", 3) == 0)

32 
token
->
id
 = 
HERE_DOC
;

33 else if (
	`ft_strncmp
(
token
->
content
, ">>", 3) == 0)

34 
token
->
id
 = 
APPEND
;

35 else if (
	`ft_strchr
(
token
->
content
, '$'))

36 
token
->
id
 = 
DOLLAR
;

38 
token
->
id
 = 
WORD
;

40 
	}
}

	@
1
.
0
196
6278
builtins.c
cmd_is_bin.c
cmd_is_builtin.c
complicated_split.c
env_copied.c
envp_routine.c
envp_routine_shlvl.c
expansion_test/envp_routine.c
expansion_test/is_dollar.c
expansion_test/is_operator.c
expansion_test/is_question.c
expansion_test/is_quote.c
expansion_test/is_token.c
expansion_test/is_white_space.c
expansion_test/libft/ft_printf/ft_count_int.c
expansion_test/libft/ft_printf/ft_count_unsigned_int.c
expansion_test/libft/ft_printf/ft_dprintf.c
expansion_test/libft/ft_printf/ft_printf.c
expansion_test/libft/ft_printf/ft_printf_address.c
expansion_test/libft/ft_printf/ft_printf_char.c
expansion_test/libft/ft_printf/ft_printf_hexa.c
expansion_test/libft/ft_printf/ft_printf_int.c
expansion_test/libft/ft_printf/ft_printf_str.c
expansion_test/libft/ft_printf/ft_printf_unsint.c
expansion_test/libft/ft_printf/ft_put_hexanbr_fd.c
expansion_test/libft/ft_printf/ft_put_int.c
expansion_test/libft/ft_printf/ft_put_unsnbr_fd.c
expansion_test/libft/get_next_line/get_next_line.c
expansion_test/libft/get_next_line/get_next_line_bonus.c
expansion_test/libft/get_next_line/get_next_line_utils.c
expansion_test/libft/includes/ft_printf.h
expansion_test/libft/includes/get_next_line.h
expansion_test/libft/includes/libft.h
expansion_test/libft/libft/del.c
expansion_test/libft/libft/ft_atoi.c
expansion_test/libft/libft/ft_atoi_base.c
expansion_test/libft/libft/ft_bzero.c
expansion_test/libft/libft/ft_calloc.c
expansion_test/libft/libft/ft_isalnum.c
expansion_test/libft/libft/ft_isalpha.c
expansion_test/libft/libft/ft_isascii.c
expansion_test/libft/libft/ft_isdigit.c
expansion_test/libft/libft/ft_isprint.c
expansion_test/libft/libft/ft_itoa.c
expansion_test/libft/libft/ft_lstadd_back.c
expansion_test/libft/libft/ft_lstadd_front.c
expansion_test/libft/libft/ft_lstclear.c
expansion_test/libft/libft/ft_lstdel_first_el.c
expansion_test/libft/libft/ft_lstdel_last_el.c
expansion_test/libft/libft/ft_lstdelone.c
expansion_test/libft/libft/ft_lstiter.c
expansion_test/libft/libft/ft_lstlast.c
expansion_test/libft/libft/ft_lstmap.c
expansion_test/libft/libft/ft_lstnew.c
expansion_test/libft/libft/ft_lstsize.c
expansion_test/libft/libft/ft_memchr.c
expansion_test/libft/libft/ft_memcmp.c
expansion_test/libft/libft/ft_memcpy.c
expansion_test/libft/libft/ft_memmove.c
expansion_test/libft/libft/ft_memset.c
expansion_test/libft/libft/ft_putchar_fd.c
expansion_test/libft/libft/ft_putendl_fd.c
expansion_test/libft/libft/ft_putnbr_fd.c
expansion_test/libft/libft/ft_putstr_fd.c
expansion_test/libft/libft/ft_split.c
expansion_test/libft/libft/ft_strchr.c
expansion_test/libft/libft/ft_strcpy.c
expansion_test/libft/libft/ft_strcspn.c
expansion_test/libft/libft/ft_strdup.c
expansion_test/libft/libft/ft_striteri.c
expansion_test/libft/libft/ft_strjoin.c
expansion_test/libft/libft/ft_strlcat.c
expansion_test/libft/libft/ft_strlcpy.c
expansion_test/libft/libft/ft_strlen.c
expansion_test/libft/libft/ft_strmapi.c
expansion_test/libft/libft/ft_strncmp.c
expansion_test/libft/libft/ft_strncpy.c
expansion_test/libft/libft/ft_strnstr.c
expansion_test/libft/libft/ft_strpbrk.c
expansion_test/libft/libft/ft_strrchr.c
expansion_test/libft/libft/ft_strspn.c
expansion_test/libft/libft/ft_strtrim.c
expansion_test/libft/libft/ft_substr.c
expansion_test/libft/libft/ft_tolower.c
expansion_test/libft/libft/ft_toupper.c
expansion_test/libft/libft/power.c
expansion_test/libft/libft/str_lowercase.c
expansion_test/main.c
expansion_test/malloc_error_print_message.c
expansion_test/minishell.h
expansion_test/parsing.c
expansion_test/parsing_expansion.c
expansion_test/parsing_expansion_helper.c
expansion_test/parsing_syntax_errors.c
expansion_test/parsing_syntax_errors_print_message.c
expansion_test/parsing_token_extraction.c
expansion_test/token_routine.c
expansion_test/token_routine_delete.c
expansion_test/token_routine_set_id.c
handler_ctr_c.c
is_dollar.c
is_operator.c
is_question.c
is_quote.c
is_token.c
is_white_space.c
launch_setup.c
libft/ft_printf/ft_count_int.c
libft/ft_printf/ft_count_unsigned_int.c
libft/ft_printf/ft_dprintf.c
libft/ft_printf/ft_printf.c
libft/ft_printf/ft_printf_address.c
libft/ft_printf/ft_printf_char.c
libft/ft_printf/ft_printf_hexa.c
libft/ft_printf/ft_printf_int.c
libft/ft_printf/ft_printf_str.c
libft/ft_printf/ft_printf_unsint.c
libft/ft_printf/ft_put_hexanbr_fd.c
libft/ft_printf/ft_put_int.c
libft/ft_printf/ft_put_unsnbr_fd.c
libft/get_next_line/get_next_line.c
libft/get_next_line/get_next_line_bonus.c
libft/get_next_line/get_next_line_utils.c
libft/includes/ft_printf.h
libft/includes/get_next_line.h
libft/includes/libft.h
libft/libft/del.c
libft/libft/ft_atoi.c
libft/libft/ft_atoi_base.c
libft/libft/ft_bzero.c
libft/libft/ft_calloc.c
libft/libft/ft_isalnum.c
libft/libft/ft_isalpha.c
libft/libft/ft_isascii.c
libft/libft/ft_isdigit.c
libft/libft/ft_isprint.c
libft/libft/ft_itoa.c
libft/libft/ft_lstadd_back.c
libft/libft/ft_lstadd_front.c
libft/libft/ft_lstclear.c
libft/libft/ft_lstdel_first_el.c
libft/libft/ft_lstdel_last_el.c
libft/libft/ft_lstdelone.c
libft/libft/ft_lstiter.c
libft/libft/ft_lstlast.c
libft/libft/ft_lstmap.c
libft/libft/ft_lstnew.c
libft/libft/ft_lstsize.c
libft/libft/ft_memchr.c
libft/libft/ft_memcmp.c
libft/libft/ft_memcpy.c
libft/libft/ft_memmove.c
libft/libft/ft_memset.c
libft/libft/ft_putchar_fd.c
libft/libft/ft_putendl_fd.c
libft/libft/ft_putnbr_fd.c
libft/libft/ft_putstr_fd.c
libft/libft/ft_split.c
libft/libft/ft_strchr.c
libft/libft/ft_strcpy.c
libft/libft/ft_strcspn.c
libft/libft/ft_strdup.c
libft/libft/ft_striteri.c
libft/libft/ft_strjoin.c
libft/libft/ft_strlcat.c
libft/libft/ft_strlcpy.c
libft/libft/ft_strlen.c
libft/libft/ft_strmapi.c
libft/libft/ft_strncmp.c
libft/libft/ft_strncpy.c
libft/libft/ft_strnstr.c
libft/libft/ft_strpbrk.c
libft/libft/ft_strrchr.c
libft/libft/ft_strspn.c
libft/libft/ft_strtrim.c
libft/libft/ft_substr.c
libft/libft/ft_tolower.c
libft/libft/ft_toupper.c
libft/libft/power.c
libft/libft/str_lowercase.c
main.c
main_parsing_syntax_errors.c
main_parsing_token_extraction.c
main_token_routine.c
malloc_error_print_message.c
minishell.h
parsing.c
parsing_expansion.c
parsing_expansion_helper.c
parsing_syntax_errors.c
parsing_syntax_errors_print_message.c
parsing_token_extraction.c
test_getenv.c
token_routine.c
token_routine_delete.c
token_routine_set_id.c
