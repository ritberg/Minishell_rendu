cscope 15 $HOME/Documents/GitHub/minishell/rita -c -q 0000000577 0000503738
	@TESTS/execution_test/cmd_is_bin.c

1 #include 
	~"minishell.h
"

4 void 
	$free_tab
(char **
table
)

6 int 
i
;

8 
i
 = 0;

9 while (
table
 && table[
i
])

10 
	`free
(
table
[
i
++]);

11 
	`free
(
table
);

12 
	}
}

14 int 
	$path_index
(
t_bin
 *
bin
, char **
table
)

16 int 
i
;

18 
i
 = 0;

19 
bin
->
path
 = 
NULL
;

20 while (
table
[
i
] != 0)

22 if (
	`ft_strncmp
("PATH=", 
table
[
i
], 5) == 0)

24 
bin
->
path
 = 
table
[
i
] + 5;

27 
i
++;

29 if (!
bin
->
path
)

32 
	}
}

35 int 
	$split_path
(
t_bin
 *
bin
)

37 char *
tmp
;

38 int 
j
;

40 
bin
->
splitted_path
 = 
	`ft_split
(bin->
path
, ':');

41 if (!
bin
->
splitted_path
)

43 
j
 = 0;

44 while (
bin
->
splitted_path
[
j
])

46 
tmp
 = 
	`ft_strjoin
(
bin
->
splitted_path
[
j
], "/");

47 if (!
bin
->
splitted_path
)

49 
	`free
(
bin
->
splitted_path
[
j
]);

50 
bin
->
splitted_path
[
j
] = 
tmp
;

51 
j
++;

54 
	}
}

57 int 
	$find_cmd_in_path
(
t_bin
 *
bin
, char *
token
)

59 int 
j
;

61 
j
 = 0;

62 while (
bin
->
splitted_path
[
j
])

64 
bin
->
cmd
 = 
	`ft_strjoin
(bin->
splitted_path
[
j
], 
token
);

65 if (!
bin
->
cmd
)

67 
bin
->
ok
 = 
	`access
(bin->
cmd
, 
F_OK
 & 
X_OK
);

68 if (
bin
->
ok
 == 0)

71 
j
++;

73 
	`free_tab
(
bin
->
splitted_path
);

74 if (
bin
->
ok
 == -1)

77 
	}
}

79 int 
	$cmd_is_bin
(
t_token
 *
token
, 
t_bin
 *
bin
)

81 if (!
	`path_index
(
bin
, 
g_shell
->
save_env
))

83 if (!
	`split_path
(
bin
))

85 if (!
	`find_cmd_in_path
(
bin
, 
token
->
content
))

88 
	}
}

	@TESTS/execution_test/copy_env_tab.c

12 #include 
	~"minishell.h
"

14 int 
	$column_size
(
t_env
 **
head
)

16 
t_env
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

29 char *
	$name_plus_value
(char *
name
, char *
value
)

31 char *
joined
;

32 int 
len_name
;

33 int 
len_value
;

34 int 
i
;

35 int 
j
;

37 
i
 = 0;

38 
j
 = 0;

39 
len_name
 = 
	`ft_strlen
(
name
);

40 
len_value
 = 
	`ft_strlen
(
value
);

41 
joined
 = 
	`malloc
(sizeof(char) * (
len_name
 + 
len_value
 + 2));

42 if (!
joined
)

43 return (
NULL
);

44 while (
i
 < 
len_name
)

45 
joined
[
i
++] = 
name
[
j
++];

46 
joined
[
i
] = '=';

47 
j
 = 0;

48 
i
++;

49 while (
j
 < 
len_value
)

50 
joined
[
i
++] = 
value
[
j
++];

51 
joined
[
i
] = '\0';

52 return (
joined
);

53 
	}
}

55 char **
	$copy_env_tab
(
t_env
 *
env
)

57 char **
res
;

58 int 
column
;

59 int 
i
;

61 
i
 = 0;

62 
column
 = 
	`column_size
(&
env
);

63 
res
 = 
	`malloc
(sizeof(char *) * (
column
 + 1));

64 if (!
res
)

65 return (
NULL
);

66 while (
env
)

68 
res
[
i
] = 
	`name_plus_value
(
env
->
var_name
, env->
var_value
);

69 if (!
res
[
i
])

70 return (
NULL
);

71 
i
++;

72 
env
 = env->
next
;

74 
res
[
i
] = 
NULL
;

76 return (
res
);

77 
	}
}

	@TESTS/execution_test/envp_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_env
(
t_env
 **
head
)

16 
t_env
 *
ptr
;

17 
t_env
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
var_name
);

27 
	`free
(
tmp
->
var_value
);

28 
	`free
(
tmp
);

30 *
head
 = 
NULL
;

31 
	}
}

40 
t_env
 *
	$new_env
(char *
envp
)

42 
t_env
 *
env
;

43 int 
end
;

44 int 
start
;

46 if (!
envp
)

47 return (
NULL
);

48 
start
 = 0;

49 
end
 = 0;

50 
env
 = 
	`malloc
(sizeof(
t_env
));

51 if (!
env
)

52 return (
	`malloc_error_print_message
(
	`strerror
(
errno
)), 
NULL
);

53 while (
envp
[
end
] != '=')

54 
end
++;

55 
env
->
var_name
 = 
	`ft_substr
(
envp
, 0, 
end
);

56 if (!
env
->
var_name
)

57 return (
NULL
);

58 
end
++;

59 
start
 = 
end
;

60 while (
envp
[
end
] != '\0')

61 
end
++;

62 
env
->
var_value
 = 
	`ft_substr
(
envp
, 
start
, 
end
 - start);

63 if (!
env
->
var_value
)

64 return (
	`malloc_error_print_message
("ft stubstr failed"), 
NULL
);

65 
env
->
next
 = 
NULL
;

66 return (
env
);

67 
	}
}

72 int 
	$link_env
(
t_env
 **
head
, t_env *
last
)

74 
t_env
 *
ptr
;

76 if (!
last
)

78 
ptr
 = *
head
;

79 while (
ptr
)

81 if (!
ptr
->
next
)

83 
ptr
 = ptr->
next
;

85 
ptr
->
next
 = 
last
;

87 
	}
}

100 
t_env
 *
	$get_envp
(char **
envp
)

102 
t_env
 **
head
;

103 
t_env
 *
env
;

104 int 
i
;

106 
i
 = 0;

107 
head
 = 
NULL
;

108 if (!
envp
)

109 return (
NULL
);

110 
env
 = 
	`new_env
(
envp
[
i
]);

111 if (!
env
)

112 return (
NULL
);

113 
head
 = &
env
;

114 
i
++;

115 while (
envp
[
i
])

117 if (
	`link_env
(
head
, 
	`new_env
(
envp
[
i
])) < 0)

118 return (
	`free_env
(
head
), 
NULL
);

119 
i
++;

121 return (*
head
);

122 
	}
}

	@TESTS/execution_test/execution.c

1 #include 
	~"minishell.h
"

3 void 
	$exec_bin
(
t_token
 *
token
, 
t_bin
 *
bin
)

5 int 
status
;

7 char **
test
;

8 (void)
token
;

9 
test
 = 
	`malloc
(sizeof(char *) * 3);

10 
test
[0] = 
	`ft_strdup
("ls");

11 
test
[1] = 
	`ft_strdup
("-la");

12 
test
[2] = 
NULL
;

14 
bin
->
child
 = 
	`fork
();

15 if (
bin
->
child
 < 0)

16 return (
	`perror
("Fork: "));

17 if (
bin
->
child
 == 0)

19 
	`printf
("cmd = %s\n", 
bin
->
cmd
);

20 int 
res
 = 0;

21 
res
 = 
	`execve
(
bin
->
cmd
, 
test
 , 
g_shell
->
save_env
);

22 
	`printf
("res = %d\n", 
res
);

26 
	`waitpid
(
bin
->
child
, &
status
, 0);

27 
	}
}

29 void 
	$check_then_execute
(
t_token
 *
token
)

31 
t_bin
 *
bin
;

33 
bin
 = 
	`malloc
(sizeof(
t_bin
));

34 
g_shell
->
save_env
 = 
	`copy_env_tab
(g_shell->
env
);

35 if (
token
 && token->
id
 == 
WORD
)

37 if (
	`cmd_is_bin
(
token
, 
bin
))

38 
	`exec_bin
(
token
, 
bin
);

44 
	}
}

	@TESTS/execution_test/handler_ctr_c.c

12 #include 
	~"minishell.h
"

14 void 
	$handler_ctr_c
(int 
code
)

16 (void)
code
;

17 
	`printf
("\n");

18 
	`rl_replace_line
("", 0);

19 
	`rl_on_new_line
();

20 
	`rl_redisplay
();

21 
g_shell
->
exit_status
 = 1;

22 
	}
}

	@TESTS/execution_test/is_dollar.c

12 #include 
	~"minishell.h
"

16 int 
	$is_dollar
(char 
c
)

18 if (
c
 == '$')

21 
	}
}

	@TESTS/execution_test/is_operator.c

12 #include 
	~"minishell.h
"

16 int 
	$is_pipeline
(char 
c
)

18 if (
c
 == '|')

21 
	}
}

25 int 
	$is_lchevron
(char 
c
)

27 if (
c
 == '<')

30 
	}
}

32 int 
	$is_rchevron
(char 
c
)

34 if (
c
 == '>')

37 
	}
}

39 int 
	$is_chevron
(char 
c
)

41 if (
	`is_lchevron
(
c
) || 
	`is_rchevron
(c))

44 
	}
}

48 int 
	$is_operator
(char 
c
)

50 if (
	`is_pipeline
(
c
) || 
	`is_chevron
(c))

53 
	}
}

	@TESTS/execution_test/is_question.c

12 #include 
	~"minishell.h
"

14 int 
	$is_question
(char 
c
)

16 if (
c
 == '?')

19 
	}
}

21 int 
	$is_punct
(char 
c
)

23 if ((
c
 >= 33 && c <= 47) || \

24 (
c
 >= 58 && c <= 64) || \

25 (
c
 >= 91 && c <= 94) || \

26 (
c
 == 96) || \

27 (
c
 >= 123 && c <= 126))

30 
	}
}

	@TESTS/execution_test/is_quote.c

12 #include 
	~"minishell.h
"

16 int 
	$is_double_quote
(char 
c
)

18 if (
c
 == '\"')

21 
	}
}

23 int 
	$is_simple_quote
(char 
c
)

25 if (
c
 == '\'')

28 
	}
}

30 int 
	$is_quote
(char 
c
)

32 if (
	`is_double_quote
(
c
) || 
	`is_simple_quote
(c))

35 
	}
}

	@TESTS/execution_test/is_token.c

12 #include 
	~"minishell.h
"

16 int 
	$is_metacharacter
(char 
c
)

18 if (
	`is_blank
(
c
) || 
	`is_newline
(c) || 
	`is_operator
(c))

21 
	}
}

25 int 
	$is_delimiter
(char 
c
)

27 if (
	`is_metacharacter
(
c
))

30 
	}
}

34 int 
	$is_word
(char 
c
)

36 if (!
	`is_delimiter
(
c
))

39 
	}
}

	@TESTS/execution_test/is_white_space.c

12 #include 
	~"minishell.h
"

14 int 
	$is_blank
(char 
c
)

16 if (
c
 == ' ' || c == '\t')

19 
	}
}

21 int 
	$is_newline
(char 
c
)

23 if (
c
 == '\n')

26 
	}
}

28 int 
	$is_white_space
(char 
c
)

30 if (
	`is_blank
(
c
) || 
	`is_newline
(c))

33 
	}
}

	@TESTS/execution_test/launch_setup.c

12 #include 
	~"minishell.h
"

24 int 
	$sig_handler
(void)

26 
	`signal
(
SIGINT
, 
handler_ctr_c
);

27 
	`signal
(
SIGQUIT
, 
SIG_IGN
);

29 
	}
}

	@TESTS/execution_test/libft/ft_printf/ft_count_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_int
(int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

	@TESTS/execution_test/libft/ft_printf/ft_count_unsigned_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_unsigned_int
(unsigned int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 else if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 return (
count
);

30 
	}
}

	@TESTS/execution_test/libft/ft_printf/ft_dprintf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 
fd
, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 
fd
, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 
fd
, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 
fd
, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 
fd
, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_dprintf
(int 
fd
, const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 
fd
, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 
fd
, &
count
);

50 
	`ft_format_specifier_fd
(
last
[
i
 + 1], 
ap
, &
count
, 
fd
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@TESTS/execution_test/libft/ft_printf/ft_printf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier
(char 
format
, 
va_list
 
ap
, int *
count
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 1, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 1, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 1, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 1, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 1, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 1, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 1, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_printf
(const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 1, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 1, &
count
);

50 
	`ft_format_specifier
(
last
[
i
 + 1], 
ap
, &
count
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@TESTS/execution_test/libft/ft_printf/ft_printf_address.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
);

16 void 
	$ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
)

18 
	`ft_printf_str
("0x", 
fd
, 
count
);

19 
	`ft_put_uintptr_fd
(
n
, 
fd
, 
count
);

20 
	}
}

22 void 
	$ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
)

24 if (
n
 > 15)

26 
	`ft_put_uintptr_fd
(
n
 / 16, 
fd
, 
count
);

27 
	`ft_put_uintptr_fd
(
n
 % 16, 
fd
, 
count
);

29 if (
n
 < 10)

30 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

31 else if (
n
 > 9 && n < 16)

32 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

33 
	}
}

	@TESTS/execution_test/libft/ft_printf/ft_printf_char.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_char
(char 
c
, int 
fd
, int *
count
)

16 
	`ft_putchar_fd
(
c
, 
fd
);

17 *
count
 += 1;

18 
	}
}

	@TESTS/execution_test/libft/ft_printf/ft_printf_hexa.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
)

16 if (
n
 > 15)

18 
	`ft_printf_hexa
(
n
 / 16, 
fd
, 
count
, 
c
);

19 
	`ft_printf_hexa
(
n
 % 16, 
fd
, 
count
, 
c
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

25 if (
c
 == 'x')

26 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

27 else if (
c
 == 'X')

28 
	`ft_printf_char
(
n
 + 55, 
fd
, 
count
);

30 
	}
}

	@TESTS/execution_test/libft/ft_printf/ft_printf_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_int
(int 
n
, int 
fd
, int *
count
)

16 
	`ft_putnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_int
(
n
);

18 
	}
}

	@TESTS/execution_test/libft/ft_printf/ft_printf_str.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_str
(char *
s
, int 
fd
, int *
count
)

16 int 
i
;

18 
i
 = 0;

19 if (
s
 != 
NULL
)

21 while (
s
[
i
] != '\0')

22 
i
++;

23 
	`ft_putstr_fd
(
s
, 
fd
);

27 
	`ft_putstr_fd
("(null)", 1);

28 
i
 = 6;

30 *
count
 += 
i
;

31 
	}
}

	@TESTS/execution_test/libft/ft_printf/ft_printf_unsint.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
)

16 
	`ft_put_unsnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_unsigned_int
(
n
);

18 
	}
}

	@TESTS/execution_test/libft/ft_printf/ft_put_hexanbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_hexanbr_fd
(unsigned int 
n
, int 
fd
, int *
count
)

16 if (
n
 > 15)

18 
	`ft_put_hexanbr_fd
(
n
 / 16, 
fd
, 
count
);

19 
	`ft_put_hexanbr_fd
(
n
 % 16, 
fd
, 
count
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

24 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

25 
	}
}

	@TESTS/execution_test/libft/ft_printf/ft_put_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_put_int
(int 
n
, int 
fd
, int *
count
)

16 int 
a
;

18 
a
 = *
count
;

19 
	`ft_putnbr_fd
(
n
, 
fd
);

20 
a
 += 
	`ft_count_int
(
n
);

21 return (
a
);

22 
	}
}

	@TESTS/execution_test/libft/ft_printf/ft_put_unsnbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
)

16 if (
n
 > 9)

18 
	`ft_put_unsnbr_fd
(
n
 / 10, 
fd
);

19 
	`ft_put_unsnbr_fd
((
n
 % 10), 
fd
);

22 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

23 
	}
}

	@TESTS/execution_test/libft/get_next_line/get_next_line.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$create_nextline
(char *
result
, char *
line
)

16 int 
start
;

17 int 
size
;

18 char *
nextline
;

20 
start
 = 
	`ft_strlen_int
(
result
);

21 
size
 = 
	`ft_strlen_int
(
line
);

22 
size
 = size - 
start
;

23 if (
size
 == 0)

25 
	`free
 (
line
);

26 return (
NULL
);

28 
nextline
 = 
	`malloc
((
size
 + 1) * sizeof(char));

29 if (!
nextline
)

30 return (
NULL
);

31 
size
 = 0;

32 while (
line
[
start
] != '\0')

34 
nextline
[
size
] = 
line
[
start
];

35 
size
++;

36 
start
++;

38 
nextline
[
size
] = '\0';

39 
	`free
(
line
);

40 return (
nextline
);

41 
	}
}

55 char *
	$create_result
(char *
line
)

57 int 
i
;

58 char *
result
;

60 
i
 = 
	`there_is_n
(
line
);

61 if (
i
 == -1 && *
line
)

62 
i
 = 
	`ft_strlen_int
(
line
);

63 else if (
i
 == -1 && !*
line
)

64 return (
NULL
);

65 
result
 = 
	`malloc
((
i
 + 1) * sizeof(char));

66 if (!
result
)

67 return (
NULL
);

68 
i
 = 0;

69 while (
line
[
i
] != '\0')

71 
result
[
i
] = 
line
[i];

72 if (
line
[
i
] == '\n')

74 
i
++;

77 
i
++;

79 
result
[
i
] = '\0';

80 return (
result
);

81 
	}
}

94 char *
	$read_fd
(char *
line
, int 
fd
, int *
error
)

96 char *
buffer
;

97 int 
ret
;

99 
ret
 = 1;

100 
	`prepare_forstash
(&
line
, &
buffer
);

101 while (
ret
 > 0 && 
	`there_is_n
(
buffer
) == -1 && there_is_n(
line
) == -1)

103 
ret
 = (int)
	`read
(
fd
, 
buffer
, 
BUFFER_SIZE
);

104 if (
ret
 < 0)

106 
	`free
(
buffer
);

107 *
error
 = -1;

108 return (
NULL
);

110 if (
ret
 == 0)

112 *
error
 = 0;

115 
buffer
[
ret
] = '\0';

116 
line
 = 
	`ft_join
(line, 
buffer
);

118 
	`free
(
buffer
);

119 return (
line
);

120 
	}
}

130 int 
	$check_errors
(int 
fd
, char **
line
)

132 if (
fd
 < 0 || 
BUFFER_SIZE
 <= 0 || 
	`read
(fd, 0, 0) < 0)

134 
	`free
(*
line
);

135 *
line
 = 0;

139 
	}
}

150 char *
	$get_next_line
(int 
fd
)

152 static char *
line
;

153 char *
result
;

154 int 
error
;

156 
error
 = 
	`check_errors
(
fd
, &
line
);

157 if (
error
 == 0)

158 return (
NULL
);

159 
line
 = 
	`read_fd
(line, 
fd
, &
error
);

160 if (
error
 == -1 || (error == 0 && !*
line
))

162 
	`free
(
line
);

163 
line
 = 0;

164 return (
NULL
);

166 if (!
line
)

167 return (
NULL
);

168 
result
 = 
	`create_result
(
line
);

169 if (!
result
)

171 
line
 = 0;

172 
	`free
(
line
);

174 
line
 = 
	`create_nextline
(
result
, line);

175 return (
result
);

176 
	}
}

	@TESTS/execution_test/libft/get_next_line/get_next_line_bonus.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$get_next_line_maxopen
(int 
fd
)

16 static char *
line
[
OPEN_MAX
];

17 char *
result
;

18 int 
error
;

20 
error
 = 
	`check_errors
(
fd
, &
line
[fd]);

21 if (
error
 == 0)

22 return (
NULL
);

23 
line
[
fd
] = 
	`read_fd
(line[fd], fd, &
error
);

24 if (
error
 == -1 || (error == 0 && !*
line
[
fd
]))

26 
	`free
(
line
[
fd
]);

27 
line
[
fd
] = 0;

28 return (
NULL
);

30 if (!
line
[
fd
])

31 return (
NULL
);

32 
result
 = 
	`create_result
(
line
[
fd
]);

33 if (!
result
)

35 
line
[
fd
] = 0;

36 
	`free
(
line
[
fd
]);

38 
line
[
fd
] = 
	`create_nextline
(
result
, line[fd]);

39 return (
result
);

40 
	}
}

	@TESTS/execution_test/libft/get_next_line/get_next_line_utils.c

12 #include 
	~"../includes/get_next_line.h
"

14 void 
	$prepare_forstash
(char **
line
, char **
buffer
)

16 *
buffer
 = 
	`ft_calloc_count
(
BUFFER_SIZE
);

17 if (*
line
 == 
NULL
)

18 *
line
 = 
	`ft_calloc_count
(0);

19 
	}
}

21 char *
	$ft_join
(char *
line
, char *
buffer
)

23 int 
i
;

24 int 
j
;

25 char *
stash
;

27 if (!
line
 || !
buffer
)

28 return (
NULL
);

29 
i
 = 
	`ft_strlen_int
(
line
);

30 
j
 = 
	`ft_strlen_int
(
buffer
);

31 
stash
 = 
	`malloc
((
i
 + 
j
 + 1) * sizeof(char));

32 if (!
stash
)

33 return (
NULL
);

34 
i
 = 0;

35 
j
 = 0;

36 while (
line
[
i
] != '\0')

38 
stash
[
i
] = 
line
[i];

39 
i
++;

41 while (
buffer
[
j
] != '\0')

42 
stash
[
i
++] = 
buffer
[
j
++];

43 
stash
[
i
] = '\0';

44 
	`free
(
line
);

45 return (
stash
);

46 
	}
}

48 char *
	$ft_calloc_count
(int 
count
)

50 char *
string
;

51 int 
i
;

53 
i
 = 0;

54 
string
 = 
	`malloc
((
count
 + 1) * sizeof(char));

55 if (!
string
)

56 return (
NULL
);

57 while (
i
 <= 
count
)

59 
string
[
i
] = '\0';

60 
i
++;

62 return (
string
);

63 
	}
}

65 int 
	$ft_strlen_int
(const char *
string
)

67 int 
i
;

69 
i
 = 0;

70 while (
string
[
i
] != '\0')

71 
i
++;

72 return (
i
);

73 
	}
}

75 int 
	$there_is_n
(char *
line
)

77 int 
i
;

79 
i
 = 0;

80 while (
line
[
i
] != '\0')

82 if (
line
[
i
] == '\n')

83 return (
i
 + 1);

84 
i
++;

87 
	}
}

	@TESTS/execution_test/libft/includes/ft_printf.h

12 #ifndef 
FT_PRINTF_H


13 #define 
	#FT_PRINTF_H


	)

15 #include 
	~"libft.h
"

16 #include 
	~<stdarg.h
>

18 int 
ft_printf
(const char *
last
, ...);

19 void 
ft_printf_char
(char 
c
, int 
fd
, int *
count
);

20 void 
ft_printf_str
(char *
s
, int 
fd
, int *
count
);

21 void 
ft_printf_int
(int 
n
, int 
fd
, int *
count
);

22 int 
ft_count_int
(int 
n
);

23 void 
ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
);

24 void 
ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
);

25 int 
ft_count_unsigned_int
(unsigned int 
n
);

26 void 
ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
);

27 void 
ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
);

31 void 
ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
);

32 int 
ft_dprintf
(int 
fd
, const char *
last
, ...);

	@TESTS/execution_test/libft/includes/get_next_line.h

12 #ifndef 
GET_NEXT_LINE_H


13 #define 
	#GET_NEXT_LINE_H


	)

15 #include 
	~<unistd.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<limits.h
>

19 #ifndef 
BUFFER_SIZE


20 #define 
	#BUFFER_SIZE
 42

	)

23 char *
ft_calloc_count
(int 
count
);

24 int 
ft_strlen_int
(const char *
string
);

25 char *
ft_join
(char *
nextline
, char *
buffer
);

26 int 
there_is_n
(char *
line
);

27 char *
read_fd
(char *
nextline
, int 
fd
, int *
error
);

28 char *
create_result
(char *
line
);

29 char *
create_nextline
(char *
result
, char *
line
);

30 char *
get_next_line
(int 
fd
);

31 char *
get_next_line_maxopen
(int 
fd
);

32 int 
check_errors
(int 
fd
, char **
line
);

33 void 
prepare_forstash
(char **
line
, char **
buffer
);

	@TESTS/execution_test/libft/includes/libft.h

12 #ifndef 
LIBFT_H


13 #define 
	#LIBFT_H


	)

15 #include 
	~<stddef.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<unistd.h
>

18 #include 
	~"ft_printf.h
"

19 #include 
	~"get_next_line.h
"

21 typedef struct 
	ss_list


23 void *
	mcontent
;

24 struct 
s_list
 *
	mnext
;

25 } 
	tt_list
;

27 void *
ft_memset
(void *
b
, int 
c
, 
size_t
 
len
);

28 void 
ft_bzero
(void *
s
, 
size_t
 
n
);

29 void *
ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
);

30 void *
ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
);

31 void *
ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
);

32 int 
ft_isalpha
(int 
c
);

33 int 
ft_isdigit
(int 
c
);

34 int 
ft_isalnum
(int 
c
);

35 int 
ft_isascii
(int 
c
);

36 int 
ft_isprint
(int 
c
);

37 
size_t
 
ft_strlen
(const char *
s
);

38 int 
ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
);

39 char *
ft_strcpy
(char *
dst
, const char *
src
);

40 
size_t
 
ft_strlcpy
(char *
dst
, const char *
src
, size_t 
dstsize
);

41 
size_t
 
ft_strlcat
(char *
dst
, const char *
src
, size_t 
dstsize
);

42 char *
ft_strchr
(const char *
s
, int 
c
);

43 char *
ft_strrchr
(const char *
s
, int 
c
);

44 char *
ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
);

45 int 
ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
);

46 int 
ft_toupper
(int 
c
);

47 int 
ft_tolower
(int 
c
);

48 int 
ft_atoi
(const char *
str
);

49 void *
ft_calloc
(
size_t
 
count
, size_t 
size
);

50 char *
ft_strdup
(const char *
s1
);

51 char *
ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
);

52 char *
ft_strjoin
(char const *
s1
, char const *
s2
);

53 char *
ft_strtrim
(char const *
s1
, char const *
set
);

54 char **
ft_split
(char const *
s
, char 
c
);

55 char *
ft_itoa
(int 
n
);

56 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char));

57 void 
	`ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*));

58 void 
	`ft_putchar_fd
(char 
c
, int 
fd
);

59 void 
	`ft_putstr_fd
(char *
s
, int 
fd
);

60 void 
	`ft_putendl_fd
(char *
s
, int 
fd
);

61 void 
	`ft_putnbr_fd
(int 
n
, int 
fd
);

64 
t_list
 *
	`ft_lstnew
(void *
content
);

65 void 
	`ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
);

66 int 
	`ft_lstsize
(
t_list
 *
lst
);

67 
t_list
 *
	`ft_lstlast
(t_list *
lst
);

68 void 
	`ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
);

69 void 
	`ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*));

70 void 
	`ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*));

71 void 
	`ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *));

72 
t_list
 *
	`ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *));

73 void 
	`delete_first_el
(
t_list
 **
a
);

74 void 
	`delete_last_el
(
t_list
 **
a
);

75 void 
	`del
(void *
content
);

78 int 
	`power
(int 
str_base
, int 
power
);

79 int 
	`ft_atoi_base
(const char *
str
, int 
str_base
);

80 int 
	`transform
(char 
c
);

81 
size_t
 
	`ft_strcspn
(const char *
s
, const char *
reject
);

82 char *
	`ft_strpbrk
(const char *
s1
, const char *
s2
);

83 
size_t
 
	`ft_strspn
(const char *
s
, const char *
accept
);

84 char *
	`str_lowercase
(char *
str
);

	@TESTS/execution_test/libft/libft/del.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$del
(void *
content
)

16 if (
content
)

17 
	`free
(
content
);

18 
	}
}

	@TESTS/execution_test/libft/libft/ft_atoi.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_atoi
(const char *
str
)

16 int 
i
;

17 int 
result
;

18 int 
sign
;

20 
i
 = 0;

21 
result
 = 0;

22 
sign
 = 1;

23 while (
str
[
i
] == 32 || (str[i] >= 9 && str[i] <= 13))

24 
i
++;

25 if (
str
[
i
] == '-')

27 
sign
 *= (-1);

28 
i
++;

30 else if (
str
[
i
] == '+')

31 
i
++;

32 while (
str
[
i
] >= '0' && str[i] <= '9')

34 
result
 *= 10;

35 
result
 += 
str
[
i
] - 48;

36 
i
++;

38 return (
sign
 * 
result
);

39 
	}
}

	@TESTS/execution_test/libft/libft/ft_atoi_base.c

12 #include 
	~"../includes/libft.h
"

13 #include 
	~"../includes/get_next_line.h
"

15 int 
	$transform
(char 
c
)

17 int 
i
;

18 char 
c2
;

20 
i
 = 10;

21 if (
c
 >= 'A' && c <= 'F')

22 
c2
 = 'A';

23 if (
c
 >= 'a' && c <= 'f')

24 
c2
 = 'a';

25 while (
c
 != 
c2
)

27 
c2
++;

28 
i
++;

30 return (
i
);

31 
	}
}

33 int 
	$ft_atoi_base
(const char *
str
, int 
str_base
)

35 int 
i
;

36 int 
count
;

37 int 
result
;

38 int 
sign
;

40 
i
 = 0;

41 
result
 = 0;

42 
count
 = 
	`ft_strlen_int
(
str
) - 1;

43 
sign
 = 1;

44 if (
str
[
i
] == '-')

46 
i
++;

47 
sign
 = -1;

48 
count
--;

50 while (
str
[
i
++] != 0)

52 if (
str
[
i
] >= '0' && str[i] <= '9')

53 
result
 = result + (
str
[
i
] - '0') * 
	`power
(
str_base
, 
count
);

54 if ((
str
[
i
] >= 'A' && str[i] <= 'F') || \

55 (
str
[
i
] >= 'a' && str[i] <= 'f'))

56 
result
 = result + 
	`transform
(
str
[
i
]) * 
	`power
(
str_base
, 
count
);

57 
count
--;

59 return (
result
 * 
sign
);

60 
	}
}

	@TESTS/execution_test/libft/libft/ft_bzero.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_bzero
(void *
s
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (
n
 == 0)

21 while (
i
 < 
n
)

23 *(char *)(
s
 + 
i
) = 0;

24 
i
++;

26 
	}
}

	@TESTS/execution_test/libft/libft/ft_calloc.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_calloc
(
size_t
 
count
, size_t 
size
)

16 void *
ptr
;

18 
ptr
 = (void *)
	`malloc
(
count
 * 
size
);

19 if (!
ptr
)

20 return (
NULL
);

21 
	`ft_bzero
(
ptr
, (
count
 * 
size
));

22 return (
ptr
);

23 
	}
}

	@TESTS/execution_test/libft/libft/ft_isalnum.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalnum
(int 
c
)

16 if (
	`ft_isalpha
(
c
) == 1 || 
	`ft_isdigit
(c) == 1)

20 
	}
}

	@TESTS/execution_test/libft/libft/ft_isalpha.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalpha
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

18 else if (
c
 >= 'a' && c <= 'z')

22 
	}
}

	@TESTS/execution_test/libft/libft/ft_isascii.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isascii
(int 
c
)

16 if (
c
 >= 0 && c <= 127)

20 
	}
}

	@TESTS/execution_test/libft/libft/ft_isdigit.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isdigit
(int 
c
)

16 if (
c
 >= '0' && c <= '9')

20 
	}
}

	@TESTS/execution_test/libft/libft/ft_isprint.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isprint
(int 
c
)

16 if (
c
 >= 32 && c <= 126)

20 
	}
}

	@TESTS/execution_test/libft/libft/ft_itoa.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbchar
(int 
n
)

16 
size_t
 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

41 char *
	$ft_nb_is_negative
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

43 int 
result
;

45 
result
 = 0;

46 if (
n
 == -2147483648)

48 
n
 = -214748364;

49 
itoa_str
[
nb_char
 - 1] = (char)(8 + 48);

50 
nb_char
--;

52 
n
 *= (-1);

53 while (
n
 > 0)

55 
result
 = (
n
 % 10);

56 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

57 
n
 = n / 10;

58 
nb_char
--;

60 
itoa_str
[--
nb_char
] = '-';

61 return (
itoa_str
);

62 
	}
}

64 char *
	$ft_nb_is_positive
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

66 int 
result
;

68 
result
 = 0;

69 while (
n
 > 0)

71 
result
 = 
n
 % 10;

72 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

73 
n
 = n / 10;

74 
nb_char
--;

76 return (
itoa_str
);

77 
	}
}

79 char *
	$ft_itoa
(int 
n
)

81 
size_t
 
nb_char
;

82 
size_t
 
buff
;

83 char *
itoa_str
;

85 
buff
 = 0;

86 
nb_char
 = 
	`ft_count_nbchar
(
n
);

87 
itoa_str
 = (char *)
	`ft_calloc
((
nb_char
 + 1), sizeof(char));

88 if (!
itoa_str
)

89 return (
NULL
);

90 while (
buff
 < 
nb_char
)

92 
itoa_str
[
buff
] = '0';

93 
buff
++;

95 if (
n
 == 0)

96 
itoa_str
[0] = (char)(0 + 48);

97 else if (
n
 < 0)

98 
itoa_str
 = 
	`ft_nb_is_negative
(
n
, itoa_str, 
nb_char
);

99 else if (
n
 > 0)

100 
itoa_str
 = 
	`ft_nb_is_positive
(
n
, itoa_str, 
nb_char
);

101 return (
itoa_str
);

102 
	}
}

	@TESTS/execution_test/libft/libft/ft_lstadd_back.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
)

16 
t_list
 *
lstlast
;

18 if (*
lst
 == 
NULL
)

19 *
lst
 = 
new
;

20 else if (!
lst
 || !
new
)

24 
lstlast
 = 
	`ft_lstlast
(*
lst
);

25 
lstlast
->
next
 = 
new
;

27 
	}
}

	@TESTS/execution_test/libft/libft/ft_lstadd_front.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
)

16 if (*
lst
 == 
NULL
)

18 
new
->
next
 = 
NULL
;

19 *
lst
 = 
new
;

21 else if (*
lst
 != 
NULL
)

23 
new
->
next
 = *
lst
;

24 *
lst
 = 
new
;

26 
	}
}

	@TESTS/execution_test/libft/libft/ft_lstclear.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*))

16 
t_list
 *
temp
;

17 
t_list
 *
ptr
;

19 
ptr
 = *
lst
;

20 if (!
del
)

22 while (
ptr
 != 
NULL
)

24 
temp
 = 
ptr
->
next
;

25 
	`ft_lstdelone
(
ptr
, 
del
);

26 
ptr
 = 
temp
;

28 *
lst
 = 
NULL
;

29 
	}
}

	@TESTS/execution_test/libft/libft/ft_lstdel_first_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_first_el
(
t_list
 **
a
)

16 
t_list
 *
tmp
;

18 
tmp
 = (*
a
)->
next
;

19 
	`free
 (*
a
);

20 *
a
 = 
tmp
;

21 
	}
}

	@TESTS/execution_test/libft/libft/ft_lstdel_last_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_last_el
(
t_list
 **
a
)

16 
t_list
 *
end
;

17 
t_list
 *
prev
;

19 
end
 = *
a
;

20 
prev
 = 
NULL
;

21 while (
end
->
next
)

23 
prev
 = 
end
;

24 
end
 = end->
next
;

26 
prev
->
next
 = 
NULL
;

27 
	`free
 (
end
);

28 
	}
}

	@TESTS/execution_test/libft/libft/ft_lstdelone.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*))

16 if (!
lst
 || !
del
)

18 
	`del
(
lst
->
content
);

19 
	`free
(
lst
);

20 
	}
}

	@TESTS/execution_test/libft/libft/ft_lstiter.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *))

16 
t_list
 *
ptr
;

18 
ptr
 = 
lst
;

19 while (
ptr
 != 
NULL
)

21 
	`f
(
ptr
->
content
);

22 
ptr
 = ptr->
next
;

24 
	}
}

	@TESTS/execution_test/libft/libft/ft_lstlast.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstlast
(
t_list
 *
lst
)

16 while (
lst
 != 
NULL
 && lst->
next
 != NULL)

18 
lst
 = lst->
next
;

20 return (
lst
);

21 
	}
}

	@TESTS/execution_test/libft/libft/ft_lstmap.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *))

16 
t_list
 *
new_list
;

17 
t_list
 *
head
;

19 if (!
lst
 || !
f
)

20 return (
NULL
);

21 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

22 if (!
new_list
)

23 return (
NULL
);

24 
head
 = 
new_list
;

25 
lst
 = lst->
next
;

26 while (
lst
 != 
NULL
)

28 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

29 if (!
new_list
)

31 
	`ft_lstclear
(&
head
, 
del
);

32 return (
NULL
);

34 
	`ft_lstadd_back
(&
head
, 
new_list
);

35 
lst
 = lst->
next
;

37 return (
head
);

38 
	}
}

	@TESTS/execution_test/libft/libft/ft_lstnew.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstnew
(void *
content
)

16 
t_list
 *
lstnew
;

18 
lstnew
 = (
t_list
 *)
	`malloc
(sizeof(t_list));

19 if (!
lstnew
)

20 return (
NULL
);

21 
lstnew
->
next
 = 
NULL
;

22 
lstnew
->
content
 = (void *)content;

23 return (
lstnew
);

24 
	}
}

	@TESTS/execution_test/libft/libft/ft_lstsize.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_lstsize
(
t_list
 *
lst
)

16 int 
i
;

17 
t_list
 *
ptr
;

19 
i
 = 0;

20 
ptr
 = 
NULL
;

21 
ptr
 = 
lst
;

22 while (
ptr
 != 
NULL
)

24 
ptr
 = ptr->
next
;

25 
i
++;

27 return (
i
);

28 
	}
}

	@TESTS/execution_test/libft/libft/ft_memchr.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s
 + 
i
) == (unsigned char) 
c
)

23 return ((unsigned char *)(
s
 + 
i
));

26 
i
++;

28 return (
NULL
);

29 
	}
}

	@TESTS/execution_test/libft/libft/ft_memcmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s1
 + 
i
) != *(unsigned char *)(
s2
 + i))

23 return (*(unsigned char *)(
s1
 + 
i
) - *(unsigned char *)(
s2
 + i));

26 
i
++;

29 
	}
}

	@TESTS/execution_test/libft/libft/ft_memcpy.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 while (
i
 < 
n
)

23 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

24 
i
++;

26 return (
dst
);

27 
	}
}

	@TESTS/execution_test/libft/libft/ft_memmove.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 if (
dst
 > 
src
)

23 while (
len
--)

25 *(char *)(
dst
 + 
len
) = *(char *)(
src
 + len);

27 return (
dst
);

29 while (
i
 < 
len
)

31 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

32 
i
++;

34 return (
dst
);

35 
	}
}

	@TESTS/execution_test/libft/libft/ft_memset.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memset
(void *
b
, int 
c
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
len
)

21 *(unsigned char *)(
b
 + 
i
) = (unsigned char)
c
;

22 
i
++;

24 return (
b
);

25 
	}
}

	@TESTS/execution_test/libft/libft/ft_putchar_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putchar_fd
(char 
c
, int 
fd
)

16 
	`write
(
fd
, &
c
, 1);

17 
	}
}

	@TESTS/execution_test/libft/libft/ft_putendl_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putendl_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

26 
	`write
(
fd
, "\n", 1);

28 
	}
}

	@TESTS/execution_test/libft/libft/ft_putnbr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putnbr_fd
(int 
n
, int 
fd
)

16 if (
n
 == -2147483648)

18 
	`ft_putstr_fd
("-2147483648", 
fd
);

20 else if (
n
 < 0)

22 
	`ft_putchar_fd
('-', 
fd
);

23 
n
 = n * (-1);

24 
	`ft_putnbr_fd
(
n
, 
fd
);

26 else if (
n
 > 9)

28 
	`ft_putnbr_fd
(
n
 / 10, 
fd
);

29 
	`ft_putnbr_fd
((
n
 % 10), 
fd
);

32 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

33 
	}
}

	@TESTS/execution_test/libft/libft/ft_putstr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putstr_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

27 
	}
}

	@TESTS/execution_test/libft/libft/ft_split.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbsubstr
(const char *
s
, char 
c
)

16 unsigned int 
i
;

17 
size_t
 
count
;

19 
i
 = 0;

20 
count
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] != 
c
)

25 while (
s
[
i
] != 
c
 && s[i] != '\0')

26 
i
++;

27 
count
++;

29 while (
s
[
i
] == 
c
)

30 
i
++;

32 return (
count
);

33 
	}
}

35 unsigned int 
	$ft_start_index_substr
(char const *
s
, char 
c
, unsigned int 
start
)

37 while (
s
[
start
] == 
c
 && s[start] != '\0')

38 
start
++;

39 return (
start
);

40 
	}
}

42 unsigned int 
	$ft_nb_char_substr
(char const *
s
, char 
c
, unsigned int 
start
)

44 unsigned int 
nb_char_substr
;

46 
nb_char_substr
 = 0;

47 while (
s
[
start
] != 
c
 && s[start] != '\0')

49 
start
++;

50 
nb_char_substr
++;

52 return (
nb_char_substr
);

53 
	}
}

55 char *
ft_create_substr
(\

56 char const *
s
, char 
c
, unsigned int 
start
, unsigned int 
nb_char_substr
)

58 unsigned int 
	gi
;

59 char *
	gsubstr
;

61 
	gi
 = 0;

62 
	gsubstr
 = (char *)
ft_calloc
((
nb_char_substr
 + 1), sizeof(char));

63 if (!
	gsubstr
)

64 return (
	gNULL
);

65 while (
	gs
[
start
] != 
c
 && 
s
[start] != '\0' && 
i
 < 
nb_char_substr
)

66 
substr
[
i
++] = 
s
[
start
++];

67 return (
	gsubstr
);

70 char **
	$ft_split
(char const *
s
, char 
c
)

72 
size_t
 
nb_substr
;

73 
size_t
 
i
;

74 char **
tab2d
;

75 unsigned int 
start
;

76 unsigned int 
nb_char_substr
;

78 
i
 = 0;

79 
start
 = 0;

80 
nb_substr
 = 
	`ft_count_nbsubstr
(
s
, 
c
);

81 
tab2d
 = (char **)
	`ft_calloc
((
nb_substr
 + 1), sizeof(char *));

82 if (!
tab2d
)

83 return (
NULL
);

84 while (
s
[
start
] != '\0' && 
i
 < 
nb_substr
)

86 
start
 = 
	`ft_start_index_substr
(
s
, 
c
, start);

87 
nb_char_substr
 = 
	`ft_nb_char_substr
(
s
, 
c
, 
start
);

88 
tab2d
[
i
] = 
	`ft_create_substr
(
s
, 
c
, 
start
, 
nb_char_substr
);

89 
start
 = start + 
nb_char_substr
;

90 
i
++;

92 return (
tab2d
);

93 
	}
}

	@TESTS/execution_test/libft/libft/ft_strchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strchr
(const char *
s
, int 
c
)

16 int 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 if ((char)
c
 == 
s
[
i
])

22 return ((char *)(
s
 + 
i
));

23 
i
++;

25 if ((char)
c
 == '\0')

26 return ((char *)(
s
 + 
i
));

28 return (
NULL
);

29 
	}
}

	@TESTS/execution_test/libft/libft/ft_strcpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strcpy
(char *
dst
, const char *
src
)

16 int 
i
;

18 
i
 = 0;

19 while (
src
[
i
])

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 
dst
[
i
] = '\0';

25 return (
dst
);

26 
	}
}

	@TESTS/execution_test/libft/libft/ft_strcspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strcspn
(const char *
s
, const char *
reject
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
])

21 if (
	`ft_strchr
(
reject
, 
s
[
i
]) != 
NULL
)

22 return (
i
);

23 
i
++;

25 return (
i
);

26 
	}
}

	@TESTS/execution_test/libft/libft/ft_strdup.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strdup
(const char *
s1
)

16 int 
size
;

17 char *
s1_copie
;

19 
size
 = 
	`ft_strlen
(
s1
) + 1;

20 
s1_copie
 = (char *)
	`malloc
(
size
 * sizeof(char));

21 if (!
s1_copie
)

22 return (
NULL
);

23 
	`ft_strlcpy
(
s1_copie
, 
s1
, 
size
);

24 return (
s1_copie
);

25 
	}
}

	@TESTS/execution_test/libft/libft/ft_striteri.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*))

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`f
(
i
, &
s
[i]);

24 
i
++;

27 
	}
}

	@TESTS/execution_test/libft/libft/ft_strjoin.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strjoin
(char const *
s1
, char const *
s2
)

16 
size_t
 
size_s1
;

17 
size_t
 
size_s2
;

18 char *
strjoin
;

20 
size_s1
 = 
	`ft_strlen
(
s1
);

21 
size_s2
 = 
	`ft_strlen
(
s2
);

22 
strjoin
 = (char *)
	`malloc
((
size_s1
 + 
size_s2
 + 1) * sizeof(char));

23 if (!
strjoin
)

24 return (
NULL
);

25 
	`ft_memcpy
(
strjoin
, 
s1
, 
size_s1
);

26 
	`ft_memcpy
((
strjoin
 + 
size_s1
), 
s2
, 
size_s2
);

27 
	`ft_memset
((
strjoin
 + 
size_s1
 + 
size_s2
), 0, 1);

28 return (
strjoin
);

29 
	}
}

	@TESTS/execution_test/libft/libft/ft_strlcat.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcat
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
strlen_src
;

18 
size_t
 
strlen_dst
;

19 
size_t
 
temp
;

21 
i
 = 0;

22 
strlen_src
 = 
	`ft_strlen
(
src
);

23 
strlen_dst
 = 
	`ft_strlen
(
dst
);

24 
temp
 = 
strlen_dst
;

25 if (
dstsize
 < 
strlen_dst
)

26 return (
dstsize
 + 
strlen_src
);

27 if (
dstsize
 > 
strlen_dst
 + 1)

29 while (
src
[
i
] && 
strlen_dst
 != (
dstsize
 - 1))

31 
dst
[
strlen_dst
++] = 
src
[
i
++];

33 
dst
[
strlen_dst
] = '\0';

35 return (
temp
 + 
strlen_src
);

36 
	}
}

	@TESTS/execution_test/libft/libft/ft_strlcpy.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcpy
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
j
;

19 
i
 = 0;

20 
j
 = 0;

21 while (
src
[
i
] != '\0')

23 
i
++;

25 if (
dstsize
 > 0)

27 while (
j
 < (
dstsize
 - 1) && 
src
[j] != '\0')

29 
dst
[
j
] = 
src
[j];

30 
j
++;

32 
dst
[
j
] = '\0';

34 return (
i
);

35 
	}
}

	@TESTS/execution_test/libft/libft/ft_strlen.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlen
(const char *
s
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 
i
++;

23 return (
i
);

24 
	}
}

	@TESTS/execution_test/libft/libft/ft_strmapi.c

12 #include 
	~"../includes/libft.h
"

14 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char))

16 unsigned int 
i
;

17 
size_t
 
size
;

18 char *
strmapi
;

20 
i
 = 0;

21 
size
 = 
	`ft_strlen
(
s
);

22 
strmapi
 = (char *)
	`malloc
((
size
 + 1) * sizeof(char));

23 if (!
strmapi
)

24 return (
NULL
);

25 while (
s
[
i
] != '\0')

27 
strmapi
[
i
] = 
	`f
(i, 
s
[i]);

28 
i
++;

30 
strmapi
[
i
] = '\0';

31 return (
strmapi
);

32 
	}
}

	@TESTS/execution_test/libft/libft/ft_strncmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (((unsigned char)
s1
[
i
] || (unsigned char)
s2
[i]) && i < 
n
)

21 if (
s1
[
i
] != 
s2
[i])

22 return ((unsigned char)
s1
[
i
] - (unsigned char)
s2
[i]);

23 
i
++;

26 
	}
}

	@TESTS/execution_test/libft/libft/ft_strncpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strncpy
(char *
dst
, const char *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
src
[
i
] && i < 
len
)

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 while (
i
 < 
len
)

26 
dst
[
i
] = '\0';

27 
i
++;

29 return (
dst
);

30 
	}
}

	@TESTS/execution_test/libft/libft/ft_strnstr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
)

16 
size_t
 
len_needle
;

17 
size_t
 
len_haystack
;

19 
len_needle
 = 
	`ft_strlen
(
needle
);

20 
len_haystack
 = 
	`ft_strlen
(
haystack
);

21 if (
needle
[0] == '\0')

22 return ((char *)(
haystack
));

23 if (
len_needle
 > 
len_haystack
 || 
len
 < len_needle)

24 return (
NULL
);

25 if (
len
 > 
len_haystack
)

26 
len
 = 
len_haystack
;

27 while (
len
 >= 
len_needle
 && 
haystack
)

29 if (
	`ft_memcmp
(
haystack
, 
needle
, 
len_needle
) == 0)

30 return ((char *)(
haystack
));

33 
haystack
++;

34 
len
--;

37 return (
NULL
);

38 
	}
}

	@TESTS/execution_test/libft/libft/ft_strpbrk.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strpbrk
(const char *
s1
, const char *
s2
)

16 int 
i
;

18 
i
 = 0;

19 while (
s1
[
i
] != '\0')

21 if (
	`ft_strchr
(
s2
, 
s1
[
i
]) != 0)

23 return ((char *) &
s1
[
i
]);

25 ++
i
;

28 
	}
}

	@TESTS/execution_test/libft/libft/ft_strrchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strrchr
(const char *
s
, int 
c
)

16 int 
i
;

17 int 
k
;

19 
i
 = 0;

20 
k
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] == (char)
c
)

24 
k
 = 
i
;

25 
i
++;

27 if (
s
[
k
] == (char)
c
)

28 return ((char *)(
s
 + 
k
));

29 else if ((char)
c
 == 
s
[
i
])

30 return ((char *)(
s
 + 
i
));

32 return (
NULL
);

33 
	}
}

	@TESTS/execution_test/libft/libft/ft_strspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strspn
(const char *
s
, const char *
accept
)

16 
size_t
 
count
;

17 
size_t
 
i
;

19 
count
 = 0;

20 
i
 = 0;

21 while (
s
[
i
] && 
	`ft_strchr
(
accept
, s[i]) != 0)

23 
count
++;

24 
i
++;

26 return (
count
);

27 
	}
}

	@TESTS/execution_test/libft/libft/ft_strtrim.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strtrim
(char const *
s1
, char const *
set
)

16 unsigned int 
front
;

17 unsigned int 
end
;

18 unsigned int 
i
;

19 char *
strtrim
;

21 
front
 = 0;

22 
i
 = 0;

23 
end
 = (unsigned int)(
	`ft_strlen
(
s1
));

24 while (
s1
[
front
] != '\0' && 
	`ft_strchr
(
set
, *(s1 + front)) != 
NULL
)

25 
front
++;

26 while (
front
 < 
end
 && 
	`ft_strrchr
(
set
, *(
s1
 + end - 1)) != 
NULL
)

27 
end
--;

28 
strtrim
 = (char *)
	`malloc
((
end
 - 
front
 + 1) * sizeof(char));

29 if (!
strtrim
)

30 return (
NULL
);

31 
i
 = 0;

32 while (
front
 < 
end
)

33 
strtrim
[
i
++] = 
s1
[
front
++];

34 
strtrim
[
i
] = 0;

35 return (
strtrim
);

36 
	}
}

	@TESTS/execution_test/libft/libft/ft_substr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
)

16 char *
substr
;

17 unsigned int 
i
;

18 
size_t
 
size
;

20 
i
 = 0;

21 if (!
s
)

22 return (
NULL
);

23 
size
 = 
	`ft_strlen
(
s
);

24 if (
len
 > 
size
)

25 
len
 = 
size
;

26 if (
start
 >= (unsigned int)
size
)

28 
substr
 = (char *)
	`malloc
(1 * sizeof(char));

29 if (!
substr
)

30 return (
NULL
);

31 
substr
[0] = '\0';

32 return (
substr
);

34 
substr
 = (char *)
	`malloc
((
len
 + 1) * sizeof(char));

35 if (!
substr
)

36 return (
NULL
);

37 while (
i
 < (unsigned int)
len
 && 
s
[
start
] != '\0' )

38 
substr
[
i
++] = 
s
[
start
++];

39 
substr
[
i
] = '\0';

40 return (
substr
);

41 
	}
}

	@TESTS/execution_test/libft/libft/ft_tolower.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_tolower
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

17 return (
c
 + 32);

19 return (
c
);

20 
	}
}

	@TESTS/execution_test/libft/libft/ft_toupper.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_toupper
(int 
c
)

16 if (
c
 >= 'a' && c <= 'z')

17 return (
c
 - 32);

19 return (
c
);

20 
	}
}

	@TESTS/execution_test/libft/libft/power.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$power
(int 
str_base
, int 
power
)

16 int 
result
;

18 
result
 = 1;

19 if (
power
 < 0 || 
str_base
 == 0)

23 while (
power
 > 0)

25 
result
 = result * 
str_base
;

26 
power
--;

28 return (
result
);

29 
	}
}

	@TESTS/execution_test/libft/libft/str_lowercase.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$str_lowercase
(char *
str
)

16 int 
i
;

18 
i
 = 0;

19 while (
str
[
i
])

21 if (
str
[
i
] >= 'A' && str[i] <= 'Z')

22 
str
[
i
] += 32;

23 
i
++;

25 return (
str
);

26 
	}
}

	@TESTS/execution_test/main.c

2 #include 
	~"minishell.h
"

4 
t_shell
 *
	gg_shell
;

10 void 
	$print_env
()

12 
t_env
 *
ptr
;

14 
ptr
 = 
g_shell
->
env
;

15 if (!
g_shell
 || !g_shell->
env
)

17 while (
g_shell
->
env
)

19 
	`ft_printf
("print_env function: %s\n", 
g_shell
->
env
->
var_name
);

20 
	`ft_printf
("print_env function: %s\n", 
g_shell
->
env
->
var_value
);

21 
g_shell
->
env
 = g_shell->env->
next
;

23 
g_shell
->
env
 = 
ptr
;

24 
	}
}

27 void 
	$free_shell
(void)

29 
	`free_env
(&
g_shell
->
env
);

31 if (
g_shell
)

32 
	`free
(
g_shell
);

33 
	}
}

35 int 
	$shell_no_env
()

37 
t_env
 *
env_no
;

38 
env_no
 = 
	`malloc
(sizeof(
t_env
));

39 if (!
env_no
)

41 
	`malloc_error_print_message
(
	`strerror
(
errno
));

44 
env_no
->
var_name
 = 
	`ft_strdup
("SHLVL");

45 
env_no
->
var_value
 = 
	`ft_strdup
("1");

46 
env_no
->
next
 = 
NULL
;

47 
g_shell
->
env
 = 
env_no
;

50 
	}
}

52 int 
	$init_shell
(char **
envp
)

54 
g_shell
 = 
	`ft_calloc
(1, sizeof(
t_shell
));

55 if (!
g_shell
)

57 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

60 if (!*
envp
)

62 if (!
	`shell_no_env
())

67 
g_shell
->
env
 = 
	`get_envp
(
envp
);

68 if (!
g_shell
->
env
)

69 return (
	`free_shell
(), 0);

71 
g_shell
->
exit_status
 = 0;

75 
	}
}

78 int 
	$main
(int 
ac
, char **
av
, char **
envp
)

80 (void)
av
;

81 (void)
ac
;

82 char *
line
;

83 
t_token
 *
token
;

85 if (!
	`init_shell
(
envp
))

87 if (
	`sig_handler
() == -1)

91 
line
 = 
NULL
;

92 
line
 = 
	`readline
(
BLU_2
"minishell$ "
RESET
);

93 if (!
line
)

95 
	`rl_clear_history
();

98 if (
line
[0])

99 
	`add_history
(
line
);

102 
token
 = 
	`parsing
(
line
);

104 
	`check_then_execute
(
token
);

105 
g_shell
->
exit_status
 = 0;

106 
	`free_token
(&
token
);

108 
	`free_shell
();

110 
	}
}

	@TESTS/execution_test/malloc_error_print_message.c

12 #include 
	~"minishell.h
"

14 void 
	$malloc_error_print_message
(char *
s
)

16 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
s
);

17 
g_shell
->
exit_status
 = 1;

18 
	}
}

	@TESTS/execution_test/minishell.h

13 #ifndef 
MINISHELL_H


14 #define 
	#MINISHELL_H


	)

16 #include 
	~<stdio.h
>

17 #include 
	~<string.h
>

18 #include 
	~<stdlib.h
>

19 #include 
	~<errno.h
>

20 #include 
	~<curses.h
>

21 #include 
	~<term.h
>

22 #include 
	~<signal.h
>

23 #include 
	~<unistd.h
>

24 #include 
	~<fcntl.h
>

25 #include 
	~<stdarg.h
>

26 #include 
	~<sys/wait.h
>

27 #include 
	~<sys/stat.h
>

28 #include 
	~<sys/types.h
>

29 #include 
	~<readline/readline.h
>

30 #include 
	~<readline/history.h
>

31 #include 
	~"libft/includes/libft.h
"

34 #define 
	#RED
 "\x1b[31m"

	)

35 #define 
	#BLU
 "\x1B[34m"

	)

36 #define 
	#BLU_2
 "\e[1;34m"

	)

37 #define 
	#GRN
 "\x1B[32m"

	)

38 #define 
	#YEL
 "\x1B[33m"

	)

39 #define 
	#MAG
 "\x1B[35m"

	)

40 #define 
	#CYN
 "\x1B[36m"

	)

41 #define 
	#WHT
 "\x1B[37m"

	)

42 #define 
	#RESET
 "\x1B[0m"

	)

44 #define 
	#WORD
 1

	)

45 #define 
	#PIPELINE
 2

	)

46 #define 
	#L_CHEVRON
 3

	)

47 #define 
	#R_CHEVRON
 4

	)

48 #define 
	#APPEND
 5

	)

49 #define 
	#HERE_DOC
 6

	)

50 #define 
	#DOLLAR
 7

	)

51 #define 
	#QUESTION
 8

	)

52 #define 
	#EXPAND
 9

	)

53 #define 
	#DELETE
 10

	)

54 #define 
	#EXPANDED
 11

	)

55 #define 
	#CONTINUE
 -1

	)

56 #define 
	#ERROR_EXIT
 -169

	)

57 #define 
	#ERROR_EXIT_
 0

	)

62 typedef struct 
	ss_env


64 char *
	mvar_name
;

65 char *
	mvar_value
;

66 struct 
s_env
 *
	mnext
;

67 } 
	tt_env
;

69 typedef struct 
	ss_token


71 char *
	mcontent
;

72 int 
	mid
;

73 struct 
s_token
 *
	mnext
;

74 } 
	tt_token
;

77 typedef struct 
	ss_cmd


80 char **
	mcmd
;

81 char **
	mredir
;

82 char **
	mpath
;

86 int 
	mfdout
;

87 int 
	mfdin
;

88 int 
	mfd
[2];

89 } 
	tt_cmd
;

93 typedef struct 
	ss_bin


95 char *
	mpath
;

96 char **
	msplitted_path
;

97 char *
	mcmd
;

98 int 
	mok
;

99 
pid_t
 
	mchild
;

100 } 
	tt_bin
;

103 typedef struct 
	ss_shell


105 
t_env
 *
	menv
;

106 int 
	mexit_status
;

107 char **
	msave_env
;

108 } 
	tt_shell
;

111 extern 
t_shell
 *
g_shell
;

113 int 
expansion
(
t_token
 **
token
, t_token *
curr
, int 
pos
);

114 int 
check_dollar
(
t_token
 *
curr
, int 
i
);

115 int 
trim_dollar
(
t_token
 *
curr
, int 
pos
);

118 int 
is_dollar_to_expand
(
t_token
 *
curr
, int 
i
);

119 int 
not_within_squotes
(
t_token
 *
curr
, int 
pos
);

122 int 
trim_dollar
(
t_token
 *
curr
, int 
pos
);

125 int 
loop_dollars
(char *
s
, int 
i
);

126 int 
loop_through
(char *
s
, int 
i
);

131 int 
size_var
(char *
s
);

132 int 
check_var_exist
(
t_token
 *
tmp
);

135 int 
join_tokens
(
t_token
 **
new
, t_token *
curr
);

138 int 
prepare_expand
(
t_token
 *
tmp
, int 
i
);

139 int 
set_id_expansion
(
t_token
 *
token
);

142 int 
quote_removing
(
t_token
 **
head
, t_token *
curr
, int 
pos
);

144 
t_token
 *
delete_token
(t_token **
head
);

145 int 
token_list_size
(
t_token
 **
head
);

148 int 
_pwd
(
t_cmd
 *
cmd
);

149 int 
_env
(
t_env
 *
env
);

152 char **
env_copied
(char **
envp
);

153 void 
free_tab
(char **
table
);

156 
t_env
 *
get_envp
(char **
envp
);

157 void 
free_env
(
t_env
 **
head
);

161 
t_token
 *
parsing
(char *
line
);

162 int 
syntax_error_check
(char *
s
);

163 int 
check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
);

164 int 
check_quotes_errors
(char *
s
, char 
c
, int *
i
);

165 int 
count_metachar
(char *
s
, char 
c
, int 
num
);

166 int 
check_multiple_operators_error
(int 
i
, int 
num
, char 
c
);

167 void 
print_syntax_error_char
(char 
c
);

168 void 
print_syntax_error_dchar
(char 
c
);

169 void 
print_syntax_error_str
(char *
s
);

172 int 
character_extraction
(char *
line
, int 
ind
);

173 int 
token_extraction
(char *
line
, int 
ind
);

174 
t_token
 *
get_tokens
(char *
line
);

175 int 
get_tokens_size
(char *
line
, int *
i
);

176 
t_token
 *
create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
);

179 void 
malloc_error_print_message
(char *
s
);

182 
t_token
 *
new_token
(char *
line
, int 
start
, int 
len
);

183 void 
set_id
(
t_token
 *
token
);

184 int 
token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
);

185 int 
link_token
(
t_token
 **
head
, t_token *
new
);

186 void 
free_token
(
t_token
 **
head
);

189 int 
is_dollar
(char 
c
);

190 int 
is_pipeline
(char 
c
);

191 int 
is_chevron
(char 
c
);

192 int 
is_lchevron
(char 
c
);

193 int 
is_rchevron
(char 
c
);

194 int 
is_operator
(char 
c
);

195 int 
is_newline
(char 
c
);

196 int 
is_white_space
(char 
c
);

197 int 
is_blank
(char 
c
);

198 int 
is_metacharacter
(char 
c
);

199 int 
is_delimiter
(char 
c
);

200 int 
is_word
(char 
c
);

201 int 
is_double_quote
(char 
c
);

202 int 
is_simple_quote
(char 
c
);

203 int 
is_quote
(char 
c
);

204 int 
is_question
(char 
c
);

205 int 
is_punct
(char 
c
);

208 int 
sig_handler
(void);

211 void 
handler_ctr_c
(int 
code
);

214 char **
ft_splitpath
(char *
s
, char 
c
);

217 char **
copy_env_tab
(
t_env
 *
env
);

219 int 
cmd_is_bin
(
t_token
 *
token
, 
t_bin
 *
bin
);

220 void 
check_then_execute
(
t_token
 *
token
);

	@TESTS/execution_test/parsing.c

12 #include 
	~"minishell.h
"

16 void 
	$print_token
(
t_token
 **
head
)

18 int 
i
;

19 
t_token
 *
tmp
;

21 
i
 = 0;

22 if (!*
head
 || !head)

24 
tmp
 = *
head
;

25 while (
tmp
)

27 if (
tmp
->
id
 == 
L_CHEVRON
)

28 
	`printf
("L_CHEVRON: ");

29 else if (
tmp
->
id
 == 
R_CHEVRON
)

30 
	`printf
("R_CHEVRON: ");

31 else if (
tmp
->
id
 == 
PIPELINE
)

32 
	`printf
("PIPELINE: ");

33 else if (
tmp
->
id
 == 
WORD
)

34 
	`printf
("WORD: ");

35 else if (
tmp
->
id
 == 
APPEND
)

36 
	`printf
("APPEND: ");

37 else if (
tmp
->
id
 == 
HERE_DOC
)

38 
	`printf
("HERE_DOC: ");

39 else if (
tmp
->
id
 == 
DOLLAR
)

40 
	`printf
("DOLLAR: ");

41 while (
tmp
->
content
[
i
])

43 
	`printf
 ("%c", 
tmp
->
content
[
i
]);

44 
i
++;

46 
	`printf
 ("%c", 
tmp
->
content
[
i
]);

47 
	`printf
 ("\n");

48 
i
 = 0;

49 
tmp
 = tmp->
next
;

51 
	}
}

89 
t_token
 *
	$parsing
(char *
line
)

91 
t_token
 *
token
;

93 if (!
	`syntax_error_check
(
line
))

94 return (
NULL
);

95 
token
 = 
	`get_tokens
(
line
);

96 if (!
token
)

97 return (
NULL
);

98 if (!
	`expansion
(&
token
, token, 0))

99 return (
NULL
);

100 if (!
	`quote_removing
(&
token
, token, 0))

101 return (
NULL
);

102 
	`print_token
(&
token
);

103 return (
token
);

104 
	}
}

	@TESTS/execution_test/parsing_expansion.c

12 #include 
	~"minishell.h
"

42 int 
	$check_dollar
(
t_token
 *
curr
, int 
i
)

44 int 
res
;

46 while (
curr
->
content
[
i
])

48 if (
	`is_dollar
(
curr
->
content
[
i
]) && 
	`not_within_squotes
(curr, i))

50 if (
	`is_dollar_to_expand
(
curr
, 
i
))

51 return (
	`prepare_expand
(
curr
, 
i
));

52 else if (
	`is_dollar
(
curr
->
content
[
i
 + 1]))

53 
i
 = 
	`loop_dollars
(
curr
->
content
, i);

54 else if (
	`is_quote
(
curr
->
content
[
i
 + 1]))

56 
res
 = 
	`trim_dollar
(
curr
, 
i
);

57 if (
res
 == 
ERROR_EXIT
)

58 return (
ERROR_EXIT
);

59 
i
 += 
res
;

61 else if (
curr
->
content
[
i
 + 1] == '\0')

64 
i
++;

67 
i
++;

69 
curr
->
id
 = 
WORD
;

70 return (
i
);

71 
	}
}

73 static void 
	$expansion_next_token
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

75 
pos
 = 0;

76 if (
curr
->
next
)

78 
curr
 = curr->
next
;

79 
	`expansion
(
head
, 
curr
, 
pos
);

81 
	}
}

107 int 
	$expansion
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

109 if (
curr
)

111 if (
curr
->
id
 == 
DOLLAR
)

113 
pos
 = 
	`check_dollar
(
curr
, pos);

114 if (
pos
 == 
ERROR_EXIT
)

115 return (
	`free_token
(
head
), 0);

116 if (
curr
->
id
 == 
DELETE
)

118 
curr
 = 
	`delete_token
(
head
);

119 if (!
curr
)

121 
head
 = 
NULL
;

124 
pos
 = 0;

126 
	`expansion
(
head
, 
curr
, 
pos
);

129 
	`expansion_next_token
(
head
, 
curr
, 
pos
);

132 
	}
}

	@TESTS/execution_test/parsing_expansion_dollar_conditions.c

12 #include 
	~"minishell.h
"

18 int 
	$not_within_squotes
(
t_token
 *
curr
, int 
pos
)

20 int 
i
;

21 int 
start
;

23 
i
 = 0;

24 
start
 = 0;

25 if (!
	`is_dollar
(
curr
->
content
[
pos
]))

27 while (
curr
->
content
[
i
])

29 if (
	`is_double_quote
(
curr
->
content
[
i
]))

30 
i
 = 
	`loop_through
(
curr
->
content
, i);

31 else if (
	`is_simple_quote
(
curr
->
content
[
i
]))

33 
start
 = 
i
;

34 
i
 = 
	`loop_through
(
curr
->
content
, i);

35 if (
pos
 > 
start
 && pos < 
i
)

38 
i
++;

41 
	}
}

43 int 
	$is_dollar_to_expand
(
t_token
 *
curr
, int 
i
)

45 if (
	`is_question
(
curr
->
content
[
i
 + 1]) || \

46 (!
	`is_dollar
(
curr
->
content
[
i
 + 1]) && \

47 !
	`is_quote
(
curr
->
content
[
i
 + 1]) && \

48 !
	`is_punct
(
curr
->
content
[
i
 + 1]) && \

49 !
	`is_white_space
(
curr
->
content
[
i
 + 1]) && \

50 
curr
->
content
[
i
 + 1] != '\0'))

55 
	}
}

	@TESTS/execution_test/parsing_expansion_expand_var_helper.c

12 #include 
	~"minishell.h
"

14 static int 
	$replace_content
(
t_token
 *
tmp
, char *
s
)

16 
	`free
(
tmp
->
content
);

17 
tmp
->
content
 = 
NULL
;

18 
tmp
->
content
 = 
	`ft_strdup
(
s
);

19 if (!
tmp
->
content
)

21 
	`malloc_error_print_message
("ft_strdup failed");

22 return (
ERROR_EXIT
);

25 
	}
}

27 int 
	$check_var_exist
(
t_token
 *
tmp
)

29 if (
	`ft_strncmp
(&
tmp
->
content
[1], "?", 1) == 0)

31 return (
	`replace_content
(
tmp
, 
	`ft_itoa
(
g_shell
->
exit_status
)));

33 else if (
g_shell
 && g_shell->
env
 && g_shell->env->
var_name
)

35 if (
	`ft_strncmp
(
g_shell
->
env
->
var_name
, &
tmp
->
content
[1], \

36 
	`ft_strlen
(
tmp
->
content
)) == 0)

38 return (
	`replace_content
(
tmp
, 
g_shell
->
env
->
var_value
));

42 
	}
}

44 int 
	$size_var
(char *
s
)

46 int 
i
;

47 int 
count
;

49 
i
 = 0;

50 
count
 = 0;

51 while (
s
[
i
] && 
	`is_white_space
(s[i]))

52 
i
++;

53 while (
s
[
i
] && !
	`is_white_space
(s[i]))

55 
count
++;

56 
i
++;

58 return (
count
);

59 
	}
}

	@TESTS/execution_test/parsing_expansion_helper.c

12 #include 
	~"minishell.h
"

14 int 
	$expand_var
(
t_token
 **
new
)

16 
t_token
 *
tmp
;

17 
t_env
 *
save
;

18 int 
res
;

20 
tmp
 = *
new
;

21 
save
 = 
g_shell
->
env
;

22 while (
tmp
->
id
 != 
EXPAND
)

23 
tmp
 = tmp->
next
;

24 while (
g_shell
->
env
)

26 
res
 = 
	`check_var_exist
(
tmp
);

27 if (
res
 == 
ERROR_EXIT
)

28 return (
ERROR_EXIT
);

29 else if (
res
 == 1)

31 
tmp
->
id
 = 
EXPANDED
;

32 
g_shell
->
env
 = 
save
;

33 return (
	`size_var
(
tmp
->
content
));

35 
g_shell
->
env
 = g_shell->env->
next
;

37 
tmp
->
id
 = 
DELETE
;

38 
g_shell
->
env
 = 
save
;

40 
	}
}

42 int 
	$split_tokens
(
t_token
 **
new
, char *
s
, int 
start
, int 
len
)

44 if (
start
 != 0)

46 *
new
 = 
	`new_token
(
s
, 0, 
start
);

47 if (!*
new
)

48 return (
ERROR_EXIT
);

49 (*
new
)->
id
 = 
WORD
;

50 if (!
	`token_linked_list
(
new
, 
s
, 
start
, 
len
))

51 return (
ERROR_EXIT
);

52 (*
new
)->
next
->
id
 = 
EXPAND
;

56 *
new
 = 
	`new_token
(
s
, 
start
, 
len
);

57 if (!*
new
)

58 return (
ERROR_EXIT
);

59 (*
new
)->
id
 = 
EXPAND
;

61 
start
 += 
len
;

62 
len
 = 
start
;

63 while (
s
[
len
])

64 
len
++;

65 if (
len
 != 
start
)

66 if (!
	`token_linked_list
(
new
, 
s
, 
start
, 
len
))

67 return (
ERROR_EXIT
);

69 
	}
}

71 static int 
	$var_len
(char *
s
, int 
i
)

73 int 
len
;

75 
len
 = 0;

76 
i
++;

77 if (
	`is_question
(
s
[
i
]))

81 while (
s
[
i
] && \

82 !
	`is_white_space
(
s
[
i
]) && \

83 !
	`is_quote
(
s
[
i
]) && \

84 !
	`is_question
(
s
[
i
]) && \

85 !
	`is_dollar
(
s
[
i
]) && \

86 !
	`is_punct
(
s
[
i
]))

88 
i
++;

89 
len
++;

92 return (
len
);

93 
	}
}

95 int 
	$new_id
(
t_token
 **
new
)

97 
t_token
 *
ptr
;

99 
ptr
 = *
new
;

100 while (
ptr
)

102 if (
ptr
->
id
 == 
DELETE
 || ptr->id == 
EXPANDED
)

104 
ptr
 = ptr->
next
;

106 if (
ptr
->
next
 == 
NULL
)

107 return (
WORD
);

108 return(
	`set_id_expansion
(
ptr
->
next
));

109 
	}
}

116 int 
	$prepare_expand
(
t_token
 *
curr
, int 
i
)

118 
t_token
 *
new
;

119 int 
len
;

120 int 
id
;

122 
new
 = 
NULL
;

123 
len
 = 
	`var_len
(
curr
->
content
, 
i
);

124 if (
	`split_tokens
(&
new
, 
curr
->
content
, 
i
, 
len
 + 1) == 
ERROR_EXIT
)

125 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

126 
len
 = 
	`expand_var
(&
new
);

127 if (
len
 == 
ERROR_EXIT
)

128 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

129 
id
 = 
	`new_id
 (&
new
);

130 if (
	`join_tokens
(&
new
, 
curr
) == 
ERROR_EXIT
)

131 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

132 if (
curr
->
id
 == 
DELETE
)

134 
curr
->
id
 = id ;

135 return (
len
 + 
i
);

136 
	}
}

	@TESTS/execution_test/parsing_expansion_join_tokens.c

12 #include 
	~"minishell.h
"

14 static int 
	$get_expanded_size
(char *
s
, int 
i
)

16 int 
size
;

18 
size
 = 0;

19 while (
	`is_white_space
(
s
[
i
]))

20 
i
++;

21 while (
s
[
i
] && !
	`is_white_space
(s[i]))

23 
i
++;

24 
size
++;

26 return (
size
);

27 
	}
}

29 static int 
	$get_new_size
(
t_token
 **
new
)

31 
t_token
 *
ptr
;

32 int 
size
;

33 int 
i
;

35 
size
 = 0;

36 
ptr
 = *
new
;

37 while (
ptr
)

39 
i
 = 0;

40 if (
ptr
->
id
 == 
EXPANDED
)

41 
size
 += 
	`get_expanded_size
(
ptr
->
content
, 
i
);

42 else if (
ptr
->
id
 != 
DELETE
)

44 while (
ptr
->
content
[
i
])

46 
size
++;

47 
i
++;

50 
ptr
 = ptr->
next
;

52 return (
size
);

53 
	}
}

55 static void 
	$copy_helper
(
t_token
 **
new
, t_token *
curr
)

57 int 
i
;

58 int 
j
;

59 
t_token
 *
ptr
;

61 
i
 = 0;

62 
j
 = 0;

63 
ptr
 = *
new
;

64 while (
ptr
)

66 if (
ptr
->
id
 == 
EXPANDED
)

68 while (
ptr
->
content
[
j
] && 
	`is_white_space
(ptr->content[j]))

69 
j
++;

70 while (
ptr
->
content
[
j
] && !
	`is_white_space
(ptr->content[j]))

71 
curr
->
content
[
i
++] = 
ptr
->content[
j
++];

73 else if (
ptr
->
id
 != 
DELETE
)

74 while (
ptr
->
content
[
j
])

75 
curr
->
content
[
i
++] = 
ptr
->content[
j
++];

76 
ptr
 = ptr->
next
;

77 
j
 = 0;

79 
curr
->
content
[
i
] = '\0';

80 
	}
}

82 static int 
	$copy_join_tokens
(
t_token
 **
new
, t_token *
curr
, int 
size
)

84 
	`free
(
curr
->
content
);

85 
curr
->
content
 = 
NULL
;

86 
curr
->
content
 = 
	`malloc
((
size
 + 1) * sizeof(char));

87 if (!
curr
->
content
)

89 
	`malloc_error_print_message
(
	`strerror
(
errno
));

90 return (
ERROR_EXIT
);

92 
	`copy_helper
(
new
, 
curr
);

93 
	`free_token
(
new
);

95 
	}
}

97 int 
	$join_tokens
(
t_token
 **
new
, t_token *
curr
)

99 int 
size
;

101 
size
 = 
	`get_new_size
(
new
);

102 if (
size
 == 0)

104 
	`free_token
(
new
);

105 
curr
->
id
 = 
DELETE
;

108 if (
	`copy_join_tokens
(
new
, 
curr
, 
size
) == 
ERROR_EXIT
)

109 return (
ERROR_EXIT
);

111 
	}
}

	@TESTS/execution_test/parsing_expansion_looping.c

12 #include 
	~"minishell.h
"

53 int 
	$loop_dollars
(char *
s
, int 
i
)

55 while (
	`is_dollar
(
s
[
i
]) && s[i])

56 
i
++;

57 if (
s
[
i
] != '\0' && !
	`is_white_space
(s[i]))

58 
i
--;

59 return (
i
);

60 
	}
}

68 int 
	$loop_through
(char *
s
, int 
i
)

70 char 
c
;

72 
c
 = 
s
[
i
];

73 
i
++;

74 while (
s
[
i
] != 
c
)

75 
i
++;

76 return (
i
);

77 
	}
}

	@TESTS/execution_test/parsing_expansion_trim_dollar.c

12 #include 
	~"minishell.h
"

17 static int 
	$copy_string
(
t_token
 *
curr
, char **
s
, int 
pos
)

19 int 
i
;

20 int 
j
;

22 
i
 = 0;

23 
j
 = 0;

24 *
s
 = 
	`malloc
(sizeof(char) * 
	`ft_strlen
(
curr
->
content
));

25 if (!*
s
)

27 
i
 = 0;

28 while (
curr
->
content
[
i
])

30 if (
i
 == 
pos
)

31 
i
++;

32 (*
s
)[
j
] = 
curr
->
content
[
i
];

33 
i
++;

34 
j
++;

36 (*
s
)[
j
] = '\0';

37 
	`free
(
curr
->
content
);

38 
curr
->
content
 = *
s
;

40 
	}
}

46 int 
	$trim_dollar
(
t_token
 *
curr
, int 
pos
)

48 int 
i
;

49 int 
start
;

50 char *
s
;

52 
s
 = 
NULL
;

53 
i
 = 0;

54 
start
 = 0;

55 while (
curr
->
content
[
i
])

57 if (
	`is_double_quote
(
curr
->
content
[
i
]))

59 
start
 = 
i
;

60 
i
 = 
	`loop_through
(
curr
->
content
, i);

61 if (
pos
 > 
start
 && pos < 
i
)

64 
i
++;

66 if (!
	`copy_string
(
curr
, &
s
, 
pos
))

67 return (
ERROR_EXIT
);

69 
	}
}

	@TESTS/execution_test/parsing_quote_removing.c

12 #include 
	~"minishell.h
"

14 static int 
copy_string_unquoted
(
t_token
 *
curr
, char *
new_str
, \

15 int 
start
, int 
pos
)

17 int 
	gj
;

18 int 
	gi
;

19 int 
	gsave
;

21 
	gj
 = 0;

22 
	gi
 = 0;

23 
	gsave
 = 0;

24 while (
	gcurr
->
	gcontent
[
i
])

26 if (
	gi
 == 
start
)

27 
i
++;

28 else if (
	gi
 == 
pos
)

30 
i
++;

31 
	gsave
 = 
j
;

35 
	gnew_str
[
j
] = 
curr
->
content
[
i
];

36 
	gi
++;

37 
	gj
++;

40 
	gnew_str
[
j
] = '\0';

41 return (
	gsave
);

44 int 
	$string_replace
(
t_token
 *
curr
, int 
start
, int 
pos
)

46 int 
save
;

47 char *
new_str
;

49 
new_str
 = 
	`malloc
(sizeof(char) * (
	`ft_strlen
(
curr
->
content
) - 2 + 1));

50 if (!
new_str
)

52 
	`malloc_error_print_message
(
	`strerror
(
errno
));

53 return (
ERROR_EXIT
);

55 
save
 = 
	`copy_string_unquoted
(
curr
, 
new_str
, 
start
, 
pos
);

56 
	`free
(
curr
->
content
);

57 
curr
->
content
 = 
NULL
;

58 
curr
->
content
 = 
new_str
;

59 return (
save
);

60 
	}
}

62 int 
	$remove_q
(
t_token
 *
curr
, int 
pos
)

64 int 
start
;

66 
start
 = 
pos
;

67 
pos
 = 
	`loop_through
(
curr
->
content
, pos);

68 
pos
 = 
	`string_replace
(
curr
, 
start
, pos);

69 if (
pos
 == 
ERROR_EXIT
)

70 return (
ERROR_EXIT
);

71 return (
pos
++);

72 
	}
}

74 int 
	$quote_removing
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

76 if (!
head
 || !*head)

78 if (
curr
->
content
[
pos
] == '\0')

80 if (
curr
->
next
)

82 
pos
 = 0;

83 
curr
 = curr->
next
;

84 
	`quote_removing
(
head
, 
curr
, 
pos
);

88 else if (
	`is_quote
(
curr
->
content
[
pos
]))

90 
pos
 = 
	`remove_q
(
curr
, pos);

91 if (
pos
 == 
ERROR_EXIT
)

92 return (
	`free_token
(
head
), 0);

93 
	`quote_removing
(
head
, 
curr
, 
pos
);

97 
pos
++;

98 
	`quote_removing
(
head
, 
curr
, 
pos
);

101 
	}
}

	@TESTS/execution_test/parsing_syntax_errors.c

12 #include 
	~"minishell.h
"

14 int 
	$check_multiple_operators_error
(int 
i
, int 
num
, char 
c
)

16 if (
i
 > 
num
)

18 if (
	`is_chevron
(
c
))

19 
	`print_syntax_error_dchar
(
c
);

20 else if (
	`is_pipeline
(
c
))

21 
	`print_syntax_error_char
(
c
);

25 
	}
}

27 int 
	$count_metachar
(char *
s
, char 
c
, int 
num
)

29 int 
i
;

31 
i
 = 1;

32 while (
s
[
i
] && s[i] == 
c
)

33 
i
++;

34 if (!
	`check_multiple_operators_error
(
i
, 
num
, 
c
))

36 while (
s
[
i
] && 
	`is_blank
(s[i]))

37 
i
++;

38 if (
	`is_operator
(
s
[
i
]) && !
	`is_pipeline
(
c
))

40 
c
 = 
s
[
i
];

41 if (
	`is_chevron
(
c
) && is_chevron(
s
[
i
 + 1]))

42 return (
	`print_syntax_error_dchar
(
c
), 0);

44 
	`print_syntax_error_char
(
c
);

47 else if (
s
[
i
] == '\0')

48 return (
	`print_syntax_error_str
("newline"), 0);

50 
	}
}

52 int 
	$check_quotes_errors
(char *
s
, char 
c
, int *
i
)

54 int 
j
;

56 
j
 = *
i
 + 1;

57 while (
s
[
j
] && s[j] != 
c
)

58 
j
++;

59 if (
s
[
j
] != 
c
)

61 
	`print_syntax_error_char
(
c
);

64 (*
i
)++;

65 while (
s
[*
i
] && s[*i] != 
c
)

66 (*
i
)++;

68 
	}
}

70 int 
	$check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
)

72 int 
j
;

74 
j
 = 0;

75 while (
s
[
j
] && 
	`is_blank
(s[j]))

76 
j
++;

77 if (
s
[
j
] == 
c
)

79 
	`print_syntax_error_char
(
c
);

82 if (!
	`count_metachar
(&
s
[
i
], 
c
, 
num
))

85 
	}
}

132 int 
	$syntax_error_check
(char *
s
)

134 int 
i
;

136 
i
 = 0;

137 while (
s
[
i
])

139 if (
	`is_quote
(
s
[
i
]))

141 if (!
	`check_quotes_errors
(
s
, s[
i
], &i))

142 return (
	`free
(
s
), 0);

144 else if ((
	`is_lchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '<', 2)) || \

145 (
	`is_rchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '>', 2)))

146 return (
	`free
(
s
), 0);

147 else if (
	`is_pipeline
(
s
[
i
]) && !
	`check_pipeline_errors
(s, i, '|', 1))

148 return (
	`free
(
s
), 0);

149 
i
++;

152 
	}
}

	@TESTS/execution_test/parsing_syntax_errors_print_message.c

12 #include 
	~"minishell.h
"

19 void 
	$print_syntax_error_char
(char 
c
)

21 
	`ft_dprintf
(2, "minishell: ");

22 
	`ft_dprintf
(2, "syntax error near unexpected token ");

23 
	`ft_dprintf
(2, "\'%c\'\n", 
c
);

24 
g_shell
->
exit_status
 = 258;

25 
	}
}

27 void 
	$print_syntax_error_dchar
(char 
c
)

29 
	`ft_dprintf
(2, "minishell: ");

30 
	`ft_dprintf
(2, "syntax error near unexpected token ");

31 
	`ft_dprintf
(2, "\'%c%c\'\n", 
c
, c);

32 
g_shell
->
exit_status
 = 258;

33 
	}
}

35 void 
	$print_syntax_error_str
(char *
s
)

37 
	`ft_dprintf
(2, "minishell: ");

38 
	`ft_dprintf
(2, "syntax error near unexpected token ");

39 
	`ft_dprintf
(2, "\'%s\'\n", 
s
);

40 
g_shell
->
exit_status
 = 258;

41 
	}
}

	@TESTS/execution_test/parsing_token_extraction.c

12 #include 
	~"minishell.h
"

21 int 
	$character_extraction
(char *
line
, int 
ind
)

23 if ((
line
[
ind
] == '>' && line[ind + 1] == '>') || \

24 (
line
[
ind
] == '<' && line[ind + 1] == '<'))

27 
	}
}

43 int 
	$word_extraction
(char *
line
, int 
ind
)

45 int 
start
;

46 char 
c
;

48 
start
 = 
ind
;

49 while (
	`is_word
(
line
[
ind
]) && line[ind])

51 if (
	`is_quote
(
line
[
ind
]))

53 
c
 = 
line
[
ind
];

54 
ind
++;

55 while (
line
[
ind
] && line[ind] != 
c
)

56 
ind
++;

58 
ind
++;

60 return (
ind
 - 
start
);

61 
	}
}

64 int 
	$get_tokens_size
(char *
line
, int *
i
)

66 int 
len
;

68 
len
 = 0;

69 while (
	`is_white_space
(
line
[*
i
]))

70 (*
i
)++;

71 if (
	`is_word
(
line
[*
i
]))

72 
len
 = 
	`word_extraction
(
line
, *
i
);

73 else if (
	`is_operator
(
line
[*
i
]))

74 
len
 = 
	`character_extraction
(
line
, *
i
);

75 return (
len
);

76 
	}
}

83 
t_token
 *
	$create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
)

85 
t_token
 *
head
;

87 
head
 = 
	`new_token
(
line
, 
i
, 
len
);

88 if (!
head
)

89 return (
NULL
);

90 *
flag
 = 1;

91 return (
head
);

92 
	}
}

122 
t_token
 *
	$get_tokens
(char *
line
)

124 int 
i
;

125 int 
len
;

126 int 
flag
;

127 
t_token
 *
head
;

129 
i
 = 0;

130 
flag
 = 0;

131 
head
 = 
NULL
;

132 while (
line
[
i
])

134 
len
 = 
	`get_tokens_size
(
line
, &
i
);

135 if (
len
 == 0)

137 if (!
flag
)

139 
head
 = 
	`create_token_head
(
line
, 
i
, 
len
, &
flag
);

140 if (!
head
)

141 return (
	`free
(
line
), 
NULL
);

144 if (!
	`token_linked_list
(&
head
, 
line
, 
i
, 
len
))

145 return (
	`free_token
(&
head
), 
	`free
(
line
), 
NULL
);

146 
i
 += 
len
;

148 return (
	`free
(
line
), 
head
);

149 
	}
}

	@TESTS/execution_test/sans_readline_main.c

13 #include 
	~"minishell.h
"

15 
t_shell
 *
	gg_shell
;

21 void 
	$print_env
(
t_env
 **
head
)

23 
t_env
 *
ptr
;

25 
ptr
 = *
head
;

26 if (!
head
 || !*head)

28 while (
ptr
)

30 
	`ft_printf
("print_env function: %s\n", 
ptr
->
var_name
);

31 
	`ft_printf
("print_env function: %s\n", 
ptr
->
var_value
);

32 
ptr
 = ptr->
next
;

34 
	}
}

37 void 
	$free_shell
(void)

39 
	`free_env
(&
g_shell
->
env
);

41 if (
g_shell
)

42 
	`free
(
g_shell
);

43 
	}
}

45 int 
	$init_shell
(char **
envp
)

47 
g_shell
 = 
	`ft_calloc
(1, sizeof(
t_shell
));

48 if (!
g_shell
)

50 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

53 if (!*
envp
)

58 
g_shell
->
env
 = 
	`get_envp
(
envp
);

59 if (!
g_shell
->
env
)

61 
	`free_shell
();

62 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

65 
g_shell
->
exit_status
 = 0;

69 
	}
}

72 int 
	$main
(int 
ac
, char **
av
, char **
envp
)

74 (void)
av
;

75 (void)
ac
;

76 char *
line
;

77 
t_token
 *
token
;

79 if (!
	`init_shell
(
envp
))

81 
line
 = 
NULL
;

83 
line
 = 
	`ft_strdup
("ls");

85 
	`printf
("LINE = %s\n", 
line
);

86 
token
 = 
	`parsing
(
line
);

87 
	`check_then_execute
(
token
);

89 
g_shell
->
exit_status
 = 0;

90 if (
token
)

91 
	`free_token
(&
token
);

92 
	`free_shell
();

94 
	}
}

	@TESTS/execution_test/token_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_token
(
t_token
 **
head
)

16 
t_token
 *
ptr
;

17 
t_token
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
content
);

27 
	`free
(
tmp
);

29 *
head
 = 
NULL
;

30 
head
 = 
NULL
;

31 
	}
}

46 
t_token
 *
	$new_token
(char *
line
, int 
start
, int 
len
)

48 
t_token
 *
token
;

50 
token
 = 
NULL
;

51 
token
 = 
	`malloc
(sizeof(
t_token
));

52 if (!
token
)

54 
	`malloc_error_print_message
(
	`strerror
(
errno
));

55 return (
NULL
);

57 
token
->
content
 = 
	`ft_substr
(
line
, 
start
, 
len
);

58 if (!
token
->
content
)

60 
	`malloc_error_print_message
(
	`strerror
(
errno
));

61 return (
	`free_token
(&
token
), 
NULL
);

63 
	`set_id
(
token
);

64 
token
->
next
 = 
NULL
;

65 return (
token
);

66 
	}
}

75 int 
	$link_token
(
t_token
 **
head
, t_token *
new
)

77 
t_token
 *
ptr
;

79 if (!
new
)

81 
ptr
 = *
head
;

82 while (
ptr
)

84 if (!
ptr
->
next
)

86 
ptr
 = ptr->
next
;

88 
ptr
->
next
 = 
new
;

90 
	}
}

113 int 
	$token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
)

115 
t_token
 *
new
;

117 if (!
head
)

119 
new
 = 
	`new_token
(
line
, 
start
, 
len
);

120 if (!
new
)

122 if (!
	`link_token
(
head
, 
new
))

125 
	}
}

	@TESTS/execution_test/token_routine_delete.c

12 #include 
	~"minishell.h
"

14 int 
	$token_list_size
(
t_token
 **
head
)

16 
t_token
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

29 static 
t_token
 *
delete_helper
(t_token **
head
, t_token *
curr
, \

30 
t_token
 *
prev
, int 
i
)

32 int 
	gsize
;

34 
	gsize
 = 
token_list_size
(
head
);

35 if (
	gi
 == 0 && 
size
 == 1)

37 
free
(
curr
->
content
);

38 
free
(
curr
);

39 *
	ghead
 = 
NULL
;

40 return (*
	ghead
);

42 else if (
	gi
 == 0 && 
size
 > 1)

44 *
head
 = 
curr
->
next
;

45 
	gprev
 = *
head
;

47 else if (
	gi
 == 
size
 - 1)

48 
prev
->
next
 = 
NULL
;

50 
	gprev
->
	gnext
 = 
curr
->
next
;

51 
free
(
curr
->
content
);

52 
free
(
curr
);

53 
	gcurr
 = 
NULL
;

54 return (
	gprev
);

57 
t_token
 *
	$delete_token
(
t_token
 **
head
)

59 int 
i
;

60 
t_token
 *
curr
;

61 
t_token
 *
prev
;

63 
i
 = 0;

64 
curr
 = *
head
;

65 
prev
 = 
NULL
;

66 while (
curr
->
id
 != 
DELETE
)

68 
prev
 = 
curr
;

69 
curr
 = curr->
next
;

70 
i
++;

72 return (
	`delete_helper
(
head
, 
curr
, 
prev
, 
i
));

73 
	}
}

	@TESTS/execution_test/token_routine_set_id.c

12 #include 
	~"minishell.h
"

14 int 
	$set_id_expansion
(
t_token
 *
token
)

16 if (
	`ft_strchr
(
token
->
content
, '$'))

17 return(
DOLLAR
);

18 return (
WORD
);

19 
	}
}

21 void 
	$set_id
(
t_token
 *
token
)

23 if (
	`ft_strncmp
(
token
->
content
, "|", 2) == 0)

24 
token
->
id
 = 
PIPELINE
;

25 else if (
	`ft_strncmp
(
token
->
content
, "<", 2) == 0)

26 
token
->
id
 = 
L_CHEVRON
;

27 else if (
	`ft_strncmp
(
token
->
content
, ">", 2) == 0)

28 
token
->
id
 = 
R_CHEVRON
;

29 else if (
	`ft_strncmp
(
token
->
content
, "<<", 3) == 0)

30 
token
->
id
 = 
HERE_DOC
;

31 else if (
	`ft_strncmp
(
token
->
content
, ">>", 3) == 0)

32 
token
->
id
 = 
APPEND
;

33 else if (
	`ft_strchr
(
token
->
content
, '$'))

34 
token
->
id
 = 
DOLLAR
;

36 
token
->
id
 = 
WORD
;

38 
	}
}

	@TESTS/expansion_test/copy_env_tab.c

12 #include 
	~"minishell.h
"

14 int 
	$column_size
(
t_env
 **
head
)

16 
t_env
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

29 char *
	$name_plus_value
(char *
name
, char *
value
)

31 char *
joined
;

32 int 
len_name
;

33 int 
len_value
;

34 int 
i
;

35 int 
j
;

37 
i
 = 0;

38 
j
 = 0;

39 
len_name
 = 
	`ft_strlen
(
name
);

40 
len_value
 = 
	`ft_strlen
(
value
);

41 
joined
 = 
	`malloc
(sizeof(char) * (
len_name
 + 
len_value
 + 2));

42 if (!
joined
)

43 return (
NULL
);

44 while (
i
 < 
len_name
)

45 
joined
[
i
++] = 
name
[
j
++];

46 
joined
[
i
] = '=';

47 
j
 = 0;

48 while (
j
 < 
len_value
)

49 
joined
[
i
++] = 
value
[
j
++];

50 
joined
[
i
] = '\0';

51 return (
joined
);

52 
	}
}

54 char **
	$copy_env_tab
(
t_env
 *
env
)

56 char **
res
;

57 int 
column
;

58 int 
i
;

60 
i
 = 0;

61 
column
 = 
	`column_size
(&
env
);

63 
res
 = 
	`malloc
(sizeof(char *) * (
column
 + 1));

64 if (!
res
)

65 return (
NULL
);

66 while (
env
)

68 
res
[
i
] = 
	`name_plus_value
(
env
->
var_name
, env->
var_value
);

70 if (!
res
[
i
])

71 return (
NULL
);

72 
i
++;

73 
env
 = env->
next
;

75 
res
 = 
NULL
;

76 return (
res
);

77 
	}
}

	@TESTS/expansion_test/envp_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_env
(
t_env
 **
head
)

16 
t_env
 *
ptr
;

17 
t_env
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
var_name
);

27 
	`free
(
tmp
->
var_value
);

28 
	`free
(
tmp
);

30 *
head
 = 
NULL
;

31 
	}
}

40 
t_env
 *
	$new_env
(char *
envp
)

42 
t_env
 *
env
;

43 int 
end
;

44 int 
start
;

46 if (!
envp
)

47 return (
NULL
);

48 
start
 = 0;

49 
end
 = 0;

50 
env
 = 
	`malloc
(sizeof(
t_env
));

51 if (!
env
)

52 return (
	`malloc_error_print_message
(
	`strerror
(
errno
)), 
NULL
);

53 while (
envp
[
end
] != '=')

54 
end
++;

55 
env
->
var_name
 = 
	`ft_substr
(
envp
, 0, 
end
);

56 if (!
env
->
var_name
)

57 return (
NULL
);

58 
end
++;

59 
start
 = 
end
;

60 while (
envp
[
end
] != '\0')

61 
end
++;

62 
env
->
var_value
 = 
	`ft_substr
(
envp
, 
start
, 
end
 - start);

63 if (!
env
->
var_value
)

64 return (
	`malloc_error_print_message
("ft stubstr failed"), 
NULL
);

65 
env
->
next
 = 
NULL
;

66 return (
env
);

67 
	}
}

72 int 
	$link_env
(
t_env
 **
head
, t_env *
last
)

74 
t_env
 *
ptr
;

76 if (!
last
)

78 
ptr
 = *
head
;

79 while (
ptr
)

81 if (!
ptr
->
next
)

83 
ptr
 = ptr->
next
;

85 
ptr
->
next
 = 
last
;

87 
	}
}

100 
t_env
 *
	$get_envp
(char **
envp
)

102 
t_env
 **
head
;

103 
t_env
 *
env
;

104 int 
i
;

106 
i
 = 0;

107 
head
 = 
NULL
;

108 if (!
envp
)

109 return (
NULL
);

110 
env
 = 
	`new_env
(
envp
[
i
]);

111 if (!
env
)

112 return (
NULL
);

113 
head
 = &
env
;

114 
i
++;

115 while (
envp
[
i
])

117 if (
	`link_env
(
head
, 
	`new_env
(
envp
[
i
])) < 0)

118 return (
	`free_env
(
head
), 
NULL
);

119 
i
++;

121 return (*
head
);

122 
	}
}

	@TESTS/expansion_test/is_dollar.c

12 #include 
	~"minishell.h
"

16 int 
	$is_dollar
(char 
c
)

18 if (
c
 == '$')

21 
	}
}

	@TESTS/expansion_test/is_operator.c

12 #include 
	~"minishell.h
"

16 int 
	$is_pipeline
(char 
c
)

18 if (
c
 == '|')

21 
	}
}

25 int 
	$is_lchevron
(char 
c
)

27 if (
c
 == '<')

30 
	}
}

32 int 
	$is_rchevron
(char 
c
)

34 if (
c
 == '>')

37 
	}
}

39 int 
	$is_chevron
(char 
c
)

41 if (
	`is_lchevron
(
c
) || 
	`is_rchevron
(c))

44 
	}
}

48 int 
	$is_operator
(char 
c
)

50 if (
	`is_pipeline
(
c
) || 
	`is_chevron
(c))

53 
	}
}

	@TESTS/expansion_test/is_question.c

12 #include 
	~"minishell.h
"

14 int 
	$is_question
(char 
c
)

16 if (
c
 == '?')

19 
	}
}

21 int 
	$is_punct
(char 
c
)

23 if ((
c
 >= 33 && c <= 47) || \

24 (
c
 >= 58 && c <= 64) || \

25 (
c
 >= 91 && c <= 94) || \

26 (
c
 == 96) || \

27 (
c
 >= 123 && c <= 126))

30 
	}
}

	@TESTS/expansion_test/is_quote.c

12 #include 
	~"minishell.h
"

16 int 
	$is_double_quote
(char 
c
)

18 if (
c
 == '\"')

21 
	}
}

23 int 
	$is_simple_quote
(char 
c
)

25 if (
c
 == '\'')

28 
	}
}

30 int 
	$is_quote
(char 
c
)

32 if (
	`is_double_quote
(
c
) || 
	`is_simple_quote
(c))

35 
	}
}

	@TESTS/expansion_test/is_token.c

12 #include 
	~"minishell.h
"

16 int 
	$is_metacharacter
(char 
c
)

18 if (
	`is_blank
(
c
) || 
	`is_newline
(c) || 
	`is_operator
(c))

21 
	}
}

25 int 
	$is_delimiter
(char 
c
)

27 if (
	`is_metacharacter
(
c
))

30 
	}
}

34 int 
	$is_word
(char 
c
)

36 if (!
	`is_delimiter
(
c
))

39 
	}
}

	@TESTS/expansion_test/is_white_space.c

12 #include 
	~"minishell.h
"

14 int 
	$is_blank
(char 
c
)

16 if (
c
 == ' ' || c == '\t')

19 
	}
}

21 int 
	$is_newline
(char 
c
)

23 if (
c
 == '\n')

26 
	}
}

28 int 
	$is_white_space
(char 
c
)

30 if (
	`is_blank
(
c
) || 
	`is_newline
(c))

33 
	}
}

	@TESTS/expansion_test/libft/ft_printf/ft_count_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_int
(int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

	@TESTS/expansion_test/libft/ft_printf/ft_count_unsigned_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_unsigned_int
(unsigned int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 else if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 return (
count
);

30 
	}
}

	@TESTS/expansion_test/libft/ft_printf/ft_dprintf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 
fd
, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 
fd
, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 
fd
, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 
fd
, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 
fd
, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_dprintf
(int 
fd
, const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 
fd
, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 
fd
, &
count
);

50 
	`ft_format_specifier_fd
(
last
[
i
 + 1], 
ap
, &
count
, 
fd
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@TESTS/expansion_test/libft/ft_printf/ft_printf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier
(char 
format
, 
va_list
 
ap
, int *
count
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 1, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 1, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 1, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 1, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 1, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 1, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 1, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_printf
(const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 1, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 1, &
count
);

50 
	`ft_format_specifier
(
last
[
i
 + 1], 
ap
, &
count
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@TESTS/expansion_test/libft/ft_printf/ft_printf_address.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
);

16 void 
	$ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
)

18 
	`ft_printf_str
("0x", 
fd
, 
count
);

19 
	`ft_put_uintptr_fd
(
n
, 
fd
, 
count
);

20 
	}
}

22 void 
	$ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
)

24 if (
n
 > 15)

26 
	`ft_put_uintptr_fd
(
n
 / 16, 
fd
, 
count
);

27 
	`ft_put_uintptr_fd
(
n
 % 16, 
fd
, 
count
);

29 if (
n
 < 10)

30 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

31 else if (
n
 > 9 && n < 16)

32 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

33 
	}
}

	@TESTS/expansion_test/libft/ft_printf/ft_printf_char.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_char
(char 
c
, int 
fd
, int *
count
)

16 
	`ft_putchar_fd
(
c
, 
fd
);

17 *
count
 += 1;

18 
	}
}

	@TESTS/expansion_test/libft/ft_printf/ft_printf_hexa.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
)

16 if (
n
 > 15)

18 
	`ft_printf_hexa
(
n
 / 16, 
fd
, 
count
, 
c
);

19 
	`ft_printf_hexa
(
n
 % 16, 
fd
, 
count
, 
c
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

25 if (
c
 == 'x')

26 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

27 else if (
c
 == 'X')

28 
	`ft_printf_char
(
n
 + 55, 
fd
, 
count
);

30 
	}
}

	@TESTS/expansion_test/libft/ft_printf/ft_printf_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_int
(int 
n
, int 
fd
, int *
count
)

16 
	`ft_putnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_int
(
n
);

18 
	}
}

	@TESTS/expansion_test/libft/ft_printf/ft_printf_str.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_str
(char *
s
, int 
fd
, int *
count
)

16 int 
i
;

18 
i
 = 0;

19 if (
s
 != 
NULL
)

21 while (
s
[
i
] != '\0')

22 
i
++;

23 
	`ft_putstr_fd
(
s
, 
fd
);

27 
	`ft_putstr_fd
("(null)", 1);

28 
i
 = 6;

30 *
count
 += 
i
;

31 
	}
}

	@TESTS/expansion_test/libft/ft_printf/ft_printf_unsint.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
)

16 
	`ft_put_unsnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_unsigned_int
(
n
);

18 
	}
}

	@TESTS/expansion_test/libft/ft_printf/ft_put_hexanbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_hexanbr_fd
(unsigned int 
n
, int 
fd
, int *
count
)

16 if (
n
 > 15)

18 
	`ft_put_hexanbr_fd
(
n
 / 16, 
fd
, 
count
);

19 
	`ft_put_hexanbr_fd
(
n
 % 16, 
fd
, 
count
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

24 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

25 
	}
}

	@TESTS/expansion_test/libft/ft_printf/ft_put_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_put_int
(int 
n
, int 
fd
, int *
count
)

16 int 
a
;

18 
a
 = *
count
;

19 
	`ft_putnbr_fd
(
n
, 
fd
);

20 
a
 += 
	`ft_count_int
(
n
);

21 return (
a
);

22 
	}
}

	@TESTS/expansion_test/libft/ft_printf/ft_put_unsnbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
)

16 if (
n
 > 9)

18 
	`ft_put_unsnbr_fd
(
n
 / 10, 
fd
);

19 
	`ft_put_unsnbr_fd
((
n
 % 10), 
fd
);

22 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

23 
	}
}

	@TESTS/expansion_test/libft/get_next_line/get_next_line.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$create_nextline
(char *
result
, char *
line
)

16 int 
start
;

17 int 
size
;

18 char *
nextline
;

20 
start
 = 
	`ft_strlen_int
(
result
);

21 
size
 = 
	`ft_strlen_int
(
line
);

22 
size
 = size - 
start
;

23 if (
size
 == 0)

25 
	`free
 (
line
);

26 return (
NULL
);

28 
nextline
 = 
	`malloc
((
size
 + 1) * sizeof(char));

29 if (!
nextline
)

30 return (
NULL
);

31 
size
 = 0;

32 while (
line
[
start
] != '\0')

34 
nextline
[
size
] = 
line
[
start
];

35 
size
++;

36 
start
++;

38 
nextline
[
size
] = '\0';

39 
	`free
(
line
);

40 return (
nextline
);

41 
	}
}

55 char *
	$create_result
(char *
line
)

57 int 
i
;

58 char *
result
;

60 
i
 = 
	`there_is_n
(
line
);

61 if (
i
 == -1 && *
line
)

62 
i
 = 
	`ft_strlen_int
(
line
);

63 else if (
i
 == -1 && !*
line
)

64 return (
NULL
);

65 
result
 = 
	`malloc
((
i
 + 1) * sizeof(char));

66 if (!
result
)

67 return (
NULL
);

68 
i
 = 0;

69 while (
line
[
i
] != '\0')

71 
result
[
i
] = 
line
[i];

72 if (
line
[
i
] == '\n')

74 
i
++;

77 
i
++;

79 
result
[
i
] = '\0';

80 return (
result
);

81 
	}
}

94 char *
	$read_fd
(char *
line
, int 
fd
, int *
error
)

96 char *
buffer
;

97 int 
ret
;

99 
ret
 = 1;

100 
	`prepare_forstash
(&
line
, &
buffer
);

101 while (
ret
 > 0 && 
	`there_is_n
(
buffer
) == -1 && there_is_n(
line
) == -1)

103 
ret
 = (int)
	`read
(
fd
, 
buffer
, 
BUFFER_SIZE
);

104 if (
ret
 < 0)

106 
	`free
(
buffer
);

107 *
error
 = -1;

108 return (
NULL
);

110 if (
ret
 == 0)

112 *
error
 = 0;

115 
buffer
[
ret
] = '\0';

116 
line
 = 
	`ft_join
(line, 
buffer
);

118 
	`free
(
buffer
);

119 return (
line
);

120 
	}
}

130 int 
	$check_errors
(int 
fd
, char **
line
)

132 if (
fd
 < 0 || 
BUFFER_SIZE
 <= 0 || 
	`read
(fd, 0, 0) < 0)

134 
	`free
(*
line
);

135 *
line
 = 0;

139 
	}
}

150 char *
	$get_next_line
(int 
fd
)

152 static char *
line
;

153 char *
result
;

154 int 
error
;

156 
error
 = 
	`check_errors
(
fd
, &
line
);

157 if (
error
 == 0)

158 return (
NULL
);

159 
line
 = 
	`read_fd
(line, 
fd
, &
error
);

160 if (
error
 == -1 || (error == 0 && !*
line
))

162 
	`free
(
line
);

163 
line
 = 0;

164 return (
NULL
);

166 if (!
line
)

167 return (
NULL
);

168 
result
 = 
	`create_result
(
line
);

169 if (!
result
)

171 
line
 = 0;

172 
	`free
(
line
);

174 
line
 = 
	`create_nextline
(
result
, line);

175 return (
result
);

176 
	}
}

	@TESTS/expansion_test/libft/get_next_line/get_next_line_bonus.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$get_next_line_maxopen
(int 
fd
)

16 static char *
line
[
OPEN_MAX
];

17 char *
result
;

18 int 
error
;

20 
error
 = 
	`check_errors
(
fd
, &
line
[fd]);

21 if (
error
 == 0)

22 return (
NULL
);

23 
line
[
fd
] = 
	`read_fd
(line[fd], fd, &
error
);

24 if (
error
 == -1 || (error == 0 && !*
line
[
fd
]))

26 
	`free
(
line
[
fd
]);

27 
line
[
fd
] = 0;

28 return (
NULL
);

30 if (!
line
[
fd
])

31 return (
NULL
);

32 
result
 = 
	`create_result
(
line
[
fd
]);

33 if (!
result
)

35 
line
[
fd
] = 0;

36 
	`free
(
line
[
fd
]);

38 
line
[
fd
] = 
	`create_nextline
(
result
, line[fd]);

39 return (
result
);

40 
	}
}

	@TESTS/expansion_test/libft/get_next_line/get_next_line_utils.c

12 #include 
	~"../includes/get_next_line.h
"

14 void 
	$prepare_forstash
(char **
line
, char **
buffer
)

16 *
buffer
 = 
	`ft_calloc_count
(
BUFFER_SIZE
);

17 if (*
line
 == 
NULL
)

18 *
line
 = 
	`ft_calloc_count
(0);

19 
	}
}

21 char *
	$ft_join
(char *
line
, char *
buffer
)

23 int 
i
;

24 int 
j
;

25 char *
stash
;

27 if (!
line
 || !
buffer
)

28 return (
NULL
);

29 
i
 = 
	`ft_strlen_int
(
line
);

30 
j
 = 
	`ft_strlen_int
(
buffer
);

31 
stash
 = 
	`malloc
((
i
 + 
j
 + 1) * sizeof(char));

32 if (!
stash
)

33 return (
NULL
);

34 
i
 = 0;

35 
j
 = 0;

36 while (
line
[
i
] != '\0')

38 
stash
[
i
] = 
line
[i];

39 
i
++;

41 while (
buffer
[
j
] != '\0')

42 
stash
[
i
++] = 
buffer
[
j
++];

43 
stash
[
i
] = '\0';

44 
	`free
(
line
);

45 return (
stash
);

46 
	}
}

48 char *
	$ft_calloc_count
(int 
count
)

50 char *
string
;

51 int 
i
;

53 
i
 = 0;

54 
string
 = 
	`malloc
((
count
 + 1) * sizeof(char));

55 if (!
string
)

56 return (
NULL
);

57 while (
i
 <= 
count
)

59 
string
[
i
] = '\0';

60 
i
++;

62 return (
string
);

63 
	}
}

65 int 
	$ft_strlen_int
(const char *
string
)

67 int 
i
;

69 
i
 = 0;

70 while (
string
[
i
] != '\0')

71 
i
++;

72 return (
i
);

73 
	}
}

75 int 
	$there_is_n
(char *
line
)

77 int 
i
;

79 
i
 = 0;

80 while (
line
[
i
] != '\0')

82 if (
line
[
i
] == '\n')

83 return (
i
 + 1);

84 
i
++;

87 
	}
}

	@TESTS/expansion_test/libft/includes/ft_printf.h

12 #ifndef 
FT_PRINTF_H


13 #define 
	#FT_PRINTF_H


	)

15 #include 
	~"libft.h
"

16 #include 
	~<stdarg.h
>

18 int 
ft_printf
(const char *
last
, ...);

19 void 
ft_printf_char
(char 
c
, int 
fd
, int *
count
);

20 void 
ft_printf_str
(char *
s
, int 
fd
, int *
count
);

21 void 
ft_printf_int
(int 
n
, int 
fd
, int *
count
);

22 int 
ft_count_int
(int 
n
);

23 void 
ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
);

24 void 
ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
);

25 int 
ft_count_unsigned_int
(unsigned int 
n
);

26 void 
ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
);

27 void 
ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
);

31 void 
ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
);

32 int 
ft_dprintf
(int 
fd
, const char *
last
, ...);

	@TESTS/expansion_test/libft/includes/get_next_line.h

12 #ifndef 
GET_NEXT_LINE_H


13 #define 
	#GET_NEXT_LINE_H


	)

15 #include 
	~<unistd.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<limits.h
>

19 #ifndef 
BUFFER_SIZE


20 #define 
	#BUFFER_SIZE
 42

	)

23 char *
ft_calloc_count
(int 
count
);

24 int 
ft_strlen_int
(const char *
string
);

25 char *
ft_join
(char *
nextline
, char *
buffer
);

26 int 
there_is_n
(char *
line
);

27 char *
read_fd
(char *
nextline
, int 
fd
, int *
error
);

28 char *
create_result
(char *
line
);

29 char *
create_nextline
(char *
result
, char *
line
);

30 char *
get_next_line
(int 
fd
);

31 char *
get_next_line_maxopen
(int 
fd
);

32 int 
check_errors
(int 
fd
, char **
line
);

33 void 
prepare_forstash
(char **
line
, char **
buffer
);

	@TESTS/expansion_test/libft/includes/libft.h

12 #ifndef 
LIBFT_H


13 #define 
	#LIBFT_H


	)

15 #include 
	~<stddef.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<unistd.h
>

18 #include 
	~"ft_printf.h
"

19 #include 
	~"get_next_line.h
"

21 typedef struct 
	ss_list


23 void *
	mcontent
;

24 struct 
s_list
 *
	mnext
;

25 } 
	tt_list
;

27 void *
ft_memset
(void *
b
, int 
c
, 
size_t
 
len
);

28 void 
ft_bzero
(void *
s
, 
size_t
 
n
);

29 void *
ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
);

30 void *
ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
);

31 void *
ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
);

32 int 
ft_isalpha
(int 
c
);

33 int 
ft_isdigit
(int 
c
);

34 int 
ft_isalnum
(int 
c
);

35 int 
ft_isascii
(int 
c
);

36 int 
ft_isprint
(int 
c
);

37 
size_t
 
ft_strlen
(const char *
s
);

38 int 
ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
);

39 char *
ft_strcpy
(char *
dst
, const char *
src
);

40 
size_t
 
ft_strlcpy
(char *
dst
, const char *
src
, size_t 
dstsize
);

41 
size_t
 
ft_strlcat
(char *
dst
, const char *
src
, size_t 
dstsize
);

42 char *
ft_strchr
(const char *
s
, int 
c
);

43 char *
ft_strrchr
(const char *
s
, int 
c
);

44 char *
ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
);

45 int 
ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
);

46 int 
ft_toupper
(int 
c
);

47 int 
ft_tolower
(int 
c
);

48 int 
ft_atoi
(const char *
str
);

49 void *
ft_calloc
(
size_t
 
count
, size_t 
size
);

50 char *
ft_strdup
(const char *
s1
);

51 char *
ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
);

52 char *
ft_strjoin
(char const *
s1
, char const *
s2
);

53 char *
ft_strtrim
(char const *
s1
, char const *
set
);

54 char **
ft_split
(char const *
s
, char 
c
);

55 char *
ft_itoa
(int 
n
);

56 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char));

57 void 
	`ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*));

58 void 
	`ft_putchar_fd
(char 
c
, int 
fd
);

59 void 
	`ft_putstr_fd
(char *
s
, int 
fd
);

60 void 
	`ft_putendl_fd
(char *
s
, int 
fd
);

61 void 
	`ft_putnbr_fd
(int 
n
, int 
fd
);

64 
t_list
 *
	`ft_lstnew
(void *
content
);

65 void 
	`ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
);

66 int 
	`ft_lstsize
(
t_list
 *
lst
);

67 
t_list
 *
	`ft_lstlast
(t_list *
lst
);

68 void 
	`ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
);

69 void 
	`ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*));

70 void 
	`ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*));

71 void 
	`ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *));

72 
t_list
 *
	`ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *));

73 void 
	`delete_first_el
(
t_list
 **
a
);

74 void 
	`delete_last_el
(
t_list
 **
a
);

75 void 
	`del
(void *
content
);

78 int 
	`power
(int 
str_base
, int 
power
);

79 int 
	`ft_atoi_base
(const char *
str
, int 
str_base
);

80 int 
	`transform
(char 
c
);

81 
size_t
 
	`ft_strcspn
(const char *
s
, const char *
reject
);

82 char *
	`ft_strpbrk
(const char *
s1
, const char *
s2
);

83 
size_t
 
	`ft_strspn
(const char *
s
, const char *
accept
);

84 char *
	`str_lowercase
(char *
str
);

	@TESTS/expansion_test/libft/libft/del.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$del
(void *
content
)

16 if (
content
)

17 
	`free
(
content
);

18 
	}
}

	@TESTS/expansion_test/libft/libft/ft_atoi.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_atoi
(const char *
str
)

16 int 
i
;

17 int 
result
;

18 int 
sign
;

20 
i
 = 0;

21 
result
 = 0;

22 
sign
 = 1;

23 while (
str
[
i
] == 32 || (str[i] >= 9 && str[i] <= 13))

24 
i
++;

25 if (
str
[
i
] == '-')

27 
sign
 *= (-1);

28 
i
++;

30 else if (
str
[
i
] == '+')

31 
i
++;

32 while (
str
[
i
] >= '0' && str[i] <= '9')

34 
result
 *= 10;

35 
result
 += 
str
[
i
] - 48;

36 
i
++;

38 return (
sign
 * 
result
);

39 
	}
}

	@TESTS/expansion_test/libft/libft/ft_atoi_base.c

12 #include 
	~"../includes/libft.h
"

13 #include 
	~"../includes/get_next_line.h
"

15 int 
	$transform
(char 
c
)

17 int 
i
;

18 char 
c2
;

20 
i
 = 10;

21 if (
c
 >= 'A' && c <= 'F')

22 
c2
 = 'A';

23 if (
c
 >= 'a' && c <= 'f')

24 
c2
 = 'a';

25 while (
c
 != 
c2
)

27 
c2
++;

28 
i
++;

30 return (
i
);

31 
	}
}

33 int 
	$ft_atoi_base
(const char *
str
, int 
str_base
)

35 int 
i
;

36 int 
count
;

37 int 
result
;

38 int 
sign
;

40 
i
 = 0;

41 
result
 = 0;

42 
count
 = 
	`ft_strlen_int
(
str
) - 1;

43 
sign
 = 1;

44 if (
str
[
i
] == '-')

46 
i
++;

47 
sign
 = -1;

48 
count
--;

50 while (
str
[
i
++] != 0)

52 if (
str
[
i
] >= '0' && str[i] <= '9')

53 
result
 = result + (
str
[
i
] - '0') * 
	`power
(
str_base
, 
count
);

54 if ((
str
[
i
] >= 'A' && str[i] <= 'F') || \

55 (
str
[
i
] >= 'a' && str[i] <= 'f'))

56 
result
 = result + 
	`transform
(
str
[
i
]) * 
	`power
(
str_base
, 
count
);

57 
count
--;

59 return (
result
 * 
sign
);

60 
	}
}

	@TESTS/expansion_test/libft/libft/ft_bzero.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_bzero
(void *
s
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (
n
 == 0)

21 while (
i
 < 
n
)

23 *(char *)(
s
 + 
i
) = 0;

24 
i
++;

26 
	}
}

	@TESTS/expansion_test/libft/libft/ft_calloc.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_calloc
(
size_t
 
count
, size_t 
size
)

16 void *
ptr
;

18 
ptr
 = (void *)
	`malloc
(
count
 * 
size
);

19 if (!
ptr
)

20 return (
NULL
);

21 
	`ft_bzero
(
ptr
, (
count
 * 
size
));

22 return (
ptr
);

23 
	}
}

	@TESTS/expansion_test/libft/libft/ft_isalnum.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalnum
(int 
c
)

16 if (
	`ft_isalpha
(
c
) == 1 || 
	`ft_isdigit
(c) == 1)

20 
	}
}

	@TESTS/expansion_test/libft/libft/ft_isalpha.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalpha
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

18 else if (
c
 >= 'a' && c <= 'z')

22 
	}
}

	@TESTS/expansion_test/libft/libft/ft_isascii.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isascii
(int 
c
)

16 if (
c
 >= 0 && c <= 127)

20 
	}
}

	@TESTS/expansion_test/libft/libft/ft_isdigit.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isdigit
(int 
c
)

16 if (
c
 >= '0' && c <= '9')

20 
	}
}

	@TESTS/expansion_test/libft/libft/ft_isprint.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isprint
(int 
c
)

16 if (
c
 >= 32 && c <= 126)

20 
	}
}

	@TESTS/expansion_test/libft/libft/ft_itoa.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbchar
(int 
n
)

16 
size_t
 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

41 char *
	$ft_nb_is_negative
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

43 int 
result
;

45 
result
 = 0;

46 if (
n
 == -2147483648)

48 
n
 = -214748364;

49 
itoa_str
[
nb_char
 - 1] = (char)(8 + 48);

50 
nb_char
--;

52 
n
 *= (-1);

53 while (
n
 > 0)

55 
result
 = (
n
 % 10);

56 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

57 
n
 = n / 10;

58 
nb_char
--;

60 
itoa_str
[--
nb_char
] = '-';

61 return (
itoa_str
);

62 
	}
}

64 char *
	$ft_nb_is_positive
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

66 int 
result
;

68 
result
 = 0;

69 while (
n
 > 0)

71 
result
 = 
n
 % 10;

72 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

73 
n
 = n / 10;

74 
nb_char
--;

76 return (
itoa_str
);

77 
	}
}

79 char *
	$ft_itoa
(int 
n
)

81 
size_t
 
nb_char
;

82 
size_t
 
buff
;

83 char *
itoa_str
;

85 
buff
 = 0;

86 
nb_char
 = 
	`ft_count_nbchar
(
n
);

87 
itoa_str
 = (char *)
	`ft_calloc
((
nb_char
 + 1), sizeof(char));

88 if (!
itoa_str
)

89 return (
NULL
);

90 while (
buff
 < 
nb_char
)

92 
itoa_str
[
buff
] = '0';

93 
buff
++;

95 if (
n
 == 0)

96 
itoa_str
[0] = (char)(0 + 48);

97 else if (
n
 < 0)

98 
itoa_str
 = 
	`ft_nb_is_negative
(
n
, itoa_str, 
nb_char
);

99 else if (
n
 > 0)

100 
itoa_str
 = 
	`ft_nb_is_positive
(
n
, itoa_str, 
nb_char
);

101 return (
itoa_str
);

102 
	}
}

	@TESTS/expansion_test/libft/libft/ft_lstadd_back.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
)

16 
t_list
 *
lstlast
;

18 if (*
lst
 == 
NULL
)

19 *
lst
 = 
new
;

20 else if (!
lst
 || !
new
)

24 
lstlast
 = 
	`ft_lstlast
(*
lst
);

25 
lstlast
->
next
 = 
new
;

27 
	}
}

	@TESTS/expansion_test/libft/libft/ft_lstadd_front.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
)

16 if (*
lst
 == 
NULL
)

18 
new
->
next
 = 
NULL
;

19 *
lst
 = 
new
;

21 else if (*
lst
 != 
NULL
)

23 
new
->
next
 = *
lst
;

24 *
lst
 = 
new
;

26 
	}
}

	@TESTS/expansion_test/libft/libft/ft_lstclear.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*))

16 
t_list
 *
temp
;

17 
t_list
 *
ptr
;

19 
ptr
 = *
lst
;

20 if (!
del
)

22 while (
ptr
 != 
NULL
)

24 
temp
 = 
ptr
->
next
;

25 
	`ft_lstdelone
(
ptr
, 
del
);

26 
ptr
 = 
temp
;

28 *
lst
 = 
NULL
;

29 
	}
}

	@TESTS/expansion_test/libft/libft/ft_lstdel_first_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_first_el
(
t_list
 **
a
)

16 
t_list
 *
tmp
;

18 
tmp
 = (*
a
)->
next
;

19 
	`free
 (*
a
);

20 *
a
 = 
tmp
;

21 
	}
}

	@TESTS/expansion_test/libft/libft/ft_lstdel_last_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_last_el
(
t_list
 **
a
)

16 
t_list
 *
end
;

17 
t_list
 *
prev
;

19 
end
 = *
a
;

20 
prev
 = 
NULL
;

21 while (
end
->
next
)

23 
prev
 = 
end
;

24 
end
 = end->
next
;

26 
prev
->
next
 = 
NULL
;

27 
	`free
 (
end
);

28 
	}
}

	@TESTS/expansion_test/libft/libft/ft_lstdelone.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*))

16 if (!
lst
 || !
del
)

18 
	`del
(
lst
->
content
);

19 
	`free
(
lst
);

20 
	}
}

	@TESTS/expansion_test/libft/libft/ft_lstiter.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *))

16 
t_list
 *
ptr
;

18 
ptr
 = 
lst
;

19 while (
ptr
 != 
NULL
)

21 
	`f
(
ptr
->
content
);

22 
ptr
 = ptr->
next
;

24 
	}
}

	@TESTS/expansion_test/libft/libft/ft_lstlast.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstlast
(
t_list
 *
lst
)

16 while (
lst
 != 
NULL
 && lst->
next
 != NULL)

18 
lst
 = lst->
next
;

20 return (
lst
);

21 
	}
}

	@TESTS/expansion_test/libft/libft/ft_lstmap.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *))

16 
t_list
 *
new_list
;

17 
t_list
 *
head
;

19 if (!
lst
 || !
f
)

20 return (
NULL
);

21 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

22 if (!
new_list
)

23 return (
NULL
);

24 
head
 = 
new_list
;

25 
lst
 = lst->
next
;

26 while (
lst
 != 
NULL
)

28 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

29 if (!
new_list
)

31 
	`ft_lstclear
(&
head
, 
del
);

32 return (
NULL
);

34 
	`ft_lstadd_back
(&
head
, 
new_list
);

35 
lst
 = lst->
next
;

37 return (
head
);

38 
	}
}

	@TESTS/expansion_test/libft/libft/ft_lstnew.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstnew
(void *
content
)

16 
t_list
 *
lstnew
;

18 
lstnew
 = (
t_list
 *)
	`malloc
(sizeof(t_list));

19 if (!
lstnew
)

20 return (
NULL
);

21 
lstnew
->
next
 = 
NULL
;

22 
lstnew
->
content
 = (void *)content;

23 return (
lstnew
);

24 
	}
}

	@TESTS/expansion_test/libft/libft/ft_lstsize.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_lstsize
(
t_list
 *
lst
)

16 int 
i
;

17 
t_list
 *
ptr
;

19 
i
 = 0;

20 
ptr
 = 
NULL
;

21 
ptr
 = 
lst
;

22 while (
ptr
 != 
NULL
)

24 
ptr
 = ptr->
next
;

25 
i
++;

27 return (
i
);

28 
	}
}

	@TESTS/expansion_test/libft/libft/ft_memchr.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s
 + 
i
) == (unsigned char) 
c
)

23 return ((unsigned char *)(
s
 + 
i
));

26 
i
++;

28 return (
NULL
);

29 
	}
}

	@TESTS/expansion_test/libft/libft/ft_memcmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s1
 + 
i
) != *(unsigned char *)(
s2
 + i))

23 return (*(unsigned char *)(
s1
 + 
i
) - *(unsigned char *)(
s2
 + i));

26 
i
++;

29 
	}
}

	@TESTS/expansion_test/libft/libft/ft_memcpy.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 while (
i
 < 
n
)

23 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

24 
i
++;

26 return (
dst
);

27 
	}
}

	@TESTS/expansion_test/libft/libft/ft_memmove.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 if (
dst
 > 
src
)

23 while (
len
--)

25 *(char *)(
dst
 + 
len
) = *(char *)(
src
 + len);

27 return (
dst
);

29 while (
i
 < 
len
)

31 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

32 
i
++;

34 return (
dst
);

35 
	}
}

	@TESTS/expansion_test/libft/libft/ft_memset.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memset
(void *
b
, int 
c
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
len
)

21 *(unsigned char *)(
b
 + 
i
) = (unsigned char)
c
;

22 
i
++;

24 return (
b
);

25 
	}
}

	@TESTS/expansion_test/libft/libft/ft_putchar_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putchar_fd
(char 
c
, int 
fd
)

16 
	`write
(
fd
, &
c
, 1);

17 
	}
}

	@TESTS/expansion_test/libft/libft/ft_putendl_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putendl_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

26 
	`write
(
fd
, "\n", 1);

28 
	}
}

	@TESTS/expansion_test/libft/libft/ft_putnbr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putnbr_fd
(int 
n
, int 
fd
)

16 if (
n
 == -2147483648)

18 
	`ft_putstr_fd
("-2147483648", 
fd
);

20 else if (
n
 < 0)

22 
	`ft_putchar_fd
('-', 
fd
);

23 
n
 = n * (-1);

24 
	`ft_putnbr_fd
(
n
, 
fd
);

26 else if (
n
 > 9)

28 
	`ft_putnbr_fd
(
n
 / 10, 
fd
);

29 
	`ft_putnbr_fd
((
n
 % 10), 
fd
);

32 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

33 
	}
}

	@TESTS/expansion_test/libft/libft/ft_putstr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putstr_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

27 
	}
}

	@TESTS/expansion_test/libft/libft/ft_split.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbsubstr
(const char *
s
, char 
c
)

16 unsigned int 
i
;

17 
size_t
 
count
;

19 
i
 = 0;

20 
count
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] != 
c
)

25 while (
s
[
i
] != 
c
 && s[i] != '\0')

26 
i
++;

27 
count
++;

29 while (
s
[
i
] == 
c
)

30 
i
++;

32 return (
count
);

33 
	}
}

35 unsigned int 
	$ft_start_index_substr
(char const *
s
, char 
c
, unsigned int 
start
)

37 while (
s
[
start
] == 
c
 && s[start] != '\0')

38 
start
++;

39 return (
start
);

40 
	}
}

42 unsigned int 
	$ft_nb_char_substr
(char const *
s
, char 
c
, unsigned int 
start
)

44 unsigned int 
nb_char_substr
;

46 
nb_char_substr
 = 0;

47 while (
s
[
start
] != 
c
 && s[start] != '\0')

49 
start
++;

50 
nb_char_substr
++;

52 return (
nb_char_substr
);

53 
	}
}

55 char *
ft_create_substr
(\

56 char const *
s
, char 
c
, unsigned int 
start
, unsigned int 
nb_char_substr
)

58 unsigned int 
	gi
;

59 char *
	gsubstr
;

61 
	gi
 = 0;

62 
	gsubstr
 = (char *)
ft_calloc
((
nb_char_substr
 + 1), sizeof(char));

63 if (!
	gsubstr
)

64 return (
	gNULL
);

65 while (
	gs
[
start
] != 
c
 && 
s
[start] != '\0' && 
i
 < 
nb_char_substr
)

66 
substr
[
i
++] = 
s
[
start
++];

67 return (
	gsubstr
);

70 char **
	$ft_split
(char const *
s
, char 
c
)

72 
size_t
 
nb_substr
;

73 
size_t
 
i
;

74 char **
tab2d
;

75 unsigned int 
start
;

76 unsigned int 
nb_char_substr
;

78 
i
 = 0;

79 
start
 = 0;

80 
nb_substr
 = 
	`ft_count_nbsubstr
(
s
, 
c
);

81 
tab2d
 = (char **)
	`ft_calloc
((
nb_substr
 + 1), sizeof(char *));

82 if (!
tab2d
)

83 return (
NULL
);

84 while (
s
[
start
] != '\0' && 
i
 < 
nb_substr
)

86 
start
 = 
	`ft_start_index_substr
(
s
, 
c
, start);

87 
nb_char_substr
 = 
	`ft_nb_char_substr
(
s
, 
c
, 
start
);

88 
tab2d
[
i
] = 
	`ft_create_substr
(
s
, 
c
, 
start
, 
nb_char_substr
);

89 
start
 = start + 
nb_char_substr
;

90 
i
++;

92 return (
tab2d
);

93 
	}
}

	@TESTS/expansion_test/libft/libft/ft_strchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strchr
(const char *
s
, int 
c
)

16 int 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 if ((char)
c
 == 
s
[
i
])

22 return ((char *)(
s
 + 
i
));

23 
i
++;

25 if ((char)
c
 == '\0')

26 return ((char *)(
s
 + 
i
));

28 return (
NULL
);

29 
	}
}

	@TESTS/expansion_test/libft/libft/ft_strcpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strcpy
(char *
dst
, const char *
src
)

16 int 
i
;

18 
i
 = 0;

19 while (
src
[
i
])

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 
dst
[
i
] = '\0';

25 return (
dst
);

26 
	}
}

	@TESTS/expansion_test/libft/libft/ft_strcspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strcspn
(const char *
s
, const char *
reject
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
])

21 if (
	`ft_strchr
(
reject
, 
s
[
i
]) != 
NULL
)

22 return (
i
);

23 
i
++;

25 return (
i
);

26 
	}
}

	@TESTS/expansion_test/libft/libft/ft_strdup.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strdup
(const char *
s1
)

16 int 
size
;

17 char *
s1_copie
;

19 
size
 = 
	`ft_strlen
(
s1
) + 1;

20 
s1_copie
 = (char *)
	`malloc
(
size
 * sizeof(char));

21 if (!
s1_copie
)

22 return (
NULL
);

23 
	`ft_strlcpy
(
s1_copie
, 
s1
, 
size
);

24 return (
s1_copie
);

25 
	}
}

	@TESTS/expansion_test/libft/libft/ft_striteri.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*))

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`f
(
i
, &
s
[i]);

24 
i
++;

27 
	}
}

	@TESTS/expansion_test/libft/libft/ft_strjoin.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strjoin
(char const *
s1
, char const *
s2
)

16 
size_t
 
size_s1
;

17 
size_t
 
size_s2
;

18 char *
strjoin
;

20 
size_s1
 = 
	`ft_strlen
(
s1
);

21 
size_s2
 = 
	`ft_strlen
(
s2
);

22 
strjoin
 = (char *)
	`malloc
((
size_s1
 + 
size_s2
 + 1) * sizeof(char));

23 if (!
strjoin
)

24 return (
NULL
);

25 
	`ft_memcpy
(
strjoin
, 
s1
, 
size_s1
);

26 
	`ft_memcpy
((
strjoin
 + 
size_s1
), 
s2
, 
size_s2
);

27 
	`ft_memset
((
strjoin
 + 
size_s1
 + 
size_s2
), 0, 1);

28 return (
strjoin
);

29 
	}
}

	@TESTS/expansion_test/libft/libft/ft_strlcat.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcat
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
strlen_src
;

18 
size_t
 
strlen_dst
;

19 
size_t
 
temp
;

21 
i
 = 0;

22 
strlen_src
 = 
	`ft_strlen
(
src
);

23 
strlen_dst
 = 
	`ft_strlen
(
dst
);

24 
temp
 = 
strlen_dst
;

25 if (
dstsize
 < 
strlen_dst
)

26 return (
dstsize
 + 
strlen_src
);

27 if (
dstsize
 > 
strlen_dst
 + 1)

29 while (
src
[
i
] && 
strlen_dst
 != (
dstsize
 - 1))

31 
dst
[
strlen_dst
++] = 
src
[
i
++];

33 
dst
[
strlen_dst
] = '\0';

35 return (
temp
 + 
strlen_src
);

36 
	}
}

	@TESTS/expansion_test/libft/libft/ft_strlcpy.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcpy
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
j
;

19 
i
 = 0;

20 
j
 = 0;

21 while (
src
[
i
] != '\0')

23 
i
++;

25 if (
dstsize
 > 0)

27 while (
j
 < (
dstsize
 - 1) && 
src
[j] != '\0')

29 
dst
[
j
] = 
src
[j];

30 
j
++;

32 
dst
[
j
] = '\0';

34 return (
i
);

35 
	}
}

	@TESTS/expansion_test/libft/libft/ft_strlen.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlen
(const char *
s
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 
i
++;

23 return (
i
);

24 
	}
}

	@TESTS/expansion_test/libft/libft/ft_strmapi.c

12 #include 
	~"../includes/libft.h
"

14 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char))

16 unsigned int 
i
;

17 
size_t
 
size
;

18 char *
strmapi
;

20 
i
 = 0;

21 
size
 = 
	`ft_strlen
(
s
);

22 
strmapi
 = (char *)
	`malloc
((
size
 + 1) * sizeof(char));

23 if (!
strmapi
)

24 return (
NULL
);

25 while (
s
[
i
] != '\0')

27 
strmapi
[
i
] = 
	`f
(i, 
s
[i]);

28 
i
++;

30 
strmapi
[
i
] = '\0';

31 return (
strmapi
);

32 
	}
}

	@TESTS/expansion_test/libft/libft/ft_strncmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (((unsigned char)
s1
[
i
] || (unsigned char)
s2
[i]) && i < 
n
)

21 if (
s1
[
i
] != 
s2
[i])

22 return ((unsigned char)
s1
[
i
] - (unsigned char)
s2
[i]);

23 
i
++;

26 
	}
}

	@TESTS/expansion_test/libft/libft/ft_strncpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strncpy
(char *
dst
, const char *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
src
[
i
] && i < 
len
)

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 while (
i
 < 
len
)

26 
dst
[
i
] = '\0';

27 
i
++;

29 return (
dst
);

30 
	}
}

	@TESTS/expansion_test/libft/libft/ft_strnstr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
)

16 
size_t
 
len_needle
;

17 
size_t
 
len_haystack
;

19 
len_needle
 = 
	`ft_strlen
(
needle
);

20 
len_haystack
 = 
	`ft_strlen
(
haystack
);

21 if (
needle
[0] == '\0')

22 return ((char *)(
haystack
));

23 if (
len_needle
 > 
len_haystack
 || 
len
 < len_needle)

24 return (
NULL
);

25 if (
len
 > 
len_haystack
)

26 
len
 = 
len_haystack
;

27 while (
len
 >= 
len_needle
 && 
haystack
)

29 if (
	`ft_memcmp
(
haystack
, 
needle
, 
len_needle
) == 0)

30 return ((char *)(
haystack
));

33 
haystack
++;

34 
len
--;

37 return (
NULL
);

38 
	}
}

	@TESTS/expansion_test/libft/libft/ft_strpbrk.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strpbrk
(const char *
s1
, const char *
s2
)

16 int 
i
;

18 
i
 = 0;

19 while (
s1
[
i
] != '\0')

21 if (
	`ft_strchr
(
s2
, 
s1
[
i
]) != 0)

23 return ((char *) &
s1
[
i
]);

25 ++
i
;

28 
	}
}

	@TESTS/expansion_test/libft/libft/ft_strrchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strrchr
(const char *
s
, int 
c
)

16 int 
i
;

17 int 
k
;

19 
i
 = 0;

20 
k
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] == (char)
c
)

24 
k
 = 
i
;

25 
i
++;

27 if (
s
[
k
] == (char)
c
)

28 return ((char *)(
s
 + 
k
));

29 else if ((char)
c
 == 
s
[
i
])

30 return ((char *)(
s
 + 
i
));

32 return (
NULL
);

33 
	}
}

	@TESTS/expansion_test/libft/libft/ft_strspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strspn
(const char *
s
, const char *
accept
)

16 
size_t
 
count
;

17 
size_t
 
i
;

19 
count
 = 0;

20 
i
 = 0;

21 while (
s
[
i
] && 
	`ft_strchr
(
accept
, s[i]) != 0)

23 
count
++;

24 
i
++;

26 return (
count
);

27 
	}
}

	@TESTS/expansion_test/libft/libft/ft_strtrim.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strtrim
(char const *
s1
, char const *
set
)

16 unsigned int 
front
;

17 unsigned int 
end
;

18 unsigned int 
i
;

19 char *
strtrim
;

21 
front
 = 0;

22 
i
 = 0;

23 
end
 = (unsigned int)(
	`ft_strlen
(
s1
));

24 while (
s1
[
front
] != '\0' && 
	`ft_strchr
(
set
, *(s1 + front)) != 
NULL
)

25 
front
++;

26 while (
front
 < 
end
 && 
	`ft_strrchr
(
set
, *(
s1
 + end - 1)) != 
NULL
)

27 
end
--;

28 
strtrim
 = (char *)
	`malloc
((
end
 - 
front
 + 1) * sizeof(char));

29 if (!
strtrim
)

30 return (
NULL
);

31 
i
 = 0;

32 while (
front
 < 
end
)

33 
strtrim
[
i
++] = 
s1
[
front
++];

34 
strtrim
[
i
] = 0;

35 return (
strtrim
);

36 
	}
}

	@TESTS/expansion_test/libft/libft/ft_substr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
)

16 char *
substr
;

17 unsigned int 
i
;

18 
size_t
 
size
;

20 
i
 = 0;

21 if (!
s
)

22 return (
NULL
);

23 
size
 = 
	`ft_strlen
(
s
);

24 if (
len
 > 
size
)

25 
len
 = 
size
;

26 if (
start
 >= (unsigned int)
size
)

28 
substr
 = (char *)
	`malloc
(1 * sizeof(char));

29 if (!
substr
)

30 return (
NULL
);

31 
substr
[0] = '\0';

32 return (
substr
);

34 
substr
 = (char *)
	`malloc
((
len
 + 1) * sizeof(char));

35 if (!
substr
)

36 return (
NULL
);

37 while (
i
 < (unsigned int)
len
 && 
s
[
start
] != '\0' )

38 
substr
[
i
++] = 
s
[
start
++];

39 
substr
[
i
] = '\0';

40 return (
substr
);

41 
	}
}

	@TESTS/expansion_test/libft/libft/ft_tolower.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_tolower
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

17 return (
c
 + 32);

19 return (
c
);

20 
	}
}

	@TESTS/expansion_test/libft/libft/ft_toupper.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_toupper
(int 
c
)

16 if (
c
 >= 'a' && c <= 'z')

17 return (
c
 - 32);

19 return (
c
);

20 
	}
}

	@TESTS/expansion_test/libft/libft/power.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$power
(int 
str_base
, int 
power
)

16 int 
result
;

18 
result
 = 1;

19 if (
power
 < 0 || 
str_base
 == 0)

23 while (
power
 > 0)

25 
result
 = result * 
str_base
;

26 
power
--;

28 return (
result
);

29 
	}
}

	@TESTS/expansion_test/libft/libft/str_lowercase.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$str_lowercase
(char *
str
)

16 int 
i
;

18 
i
 = 0;

19 while (
str
[
i
])

21 if (
str
[
i
] >= 'A' && str[i] <= 'Z')

22 
str
[
i
] += 32;

23 
i
++;

25 return (
str
);

26 
	}
}

	@TESTS/expansion_test/main.c

13 #include 
	~"minishell.h
"

15 
t_shell
 *
	gg_shell
;

21 void 
	$print_env
(
t_env
 **
head
)

23 
t_env
 *
ptr
;

25 
ptr
 = *
head
;

26 if (!
head
 || !*head)

28 while (
ptr
)

30 
	`ft_printf
("print_env function: %s\n", 
ptr
->
var_name
);

31 
	`ft_printf
("print_env function: %s\n", 
ptr
->
var_value
);

32 
ptr
 = ptr->
next
;

34 
	}
}

37 void 
	$free_shell
(void)

39 
	`free_env
(&
g_shell
->
env
);

41 if (
g_shell
)

42 
	`free
(
g_shell
);

43 
	}
}

45 int 
	$init_shell
(char **
envp
)

47 
g_shell
 = 
	`ft_calloc
(1, sizeof(
t_shell
));

48 if (!
g_shell
)

50 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

53 if (!*
envp
)

58 
g_shell
->
env
 = 
	`get_envp
(
envp
);

59 if (!
g_shell
->
env
)

61 
	`free_shell
();

62 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

65 
g_shell
->
exit_status
 = 0;

67 
g_shell
->
save_env
 = 
	`copy_env_tab
(g_shell->
env
);

69 
	}
}

72 int 
	$main
(int 
ac
, char **
av
, char **
envp
)

74 (void)
av
;

75 (void)
ac
;

76 char *
line
;

77 
t_token
 *
token
;

79 if (!
	`init_shell
(
envp
))

81 
line
 = 
NULL
;

83 
line
 = 
	`ft_strdup
("\"$USER\"");

85 
	`printf
("LINE = %s\n", 
line
);

86 
token
 = 
	`parsing
(
line
);

88 
g_shell
->
exit_status
 = 0;

89 if (
token
)

90 
	`free_token
(&
token
);

91 
	`free_shell
();

93 
	}
}

	@TESTS/expansion_test/malloc_error_print_message.c

12 #include 
	~"minishell.h
"

14 void 
	$malloc_error_print_message
(char *
s
)

16 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
s
);

17 
g_shell
->
exit_status
 = 1;

18 
	}
}

	@TESTS/expansion_test/minishell.h

13 #ifndef 
MINISHELL_H


14 #define 
	#MINISHELL_H


	)

16 #include 
	~<stdio.h
>

17 #include 
	~<string.h
>

18 #include 
	~<stdlib.h
>

19 #include 
	~<errno.h
>

20 #include 
	~<curses.h
>

21 #include 
	~<term.h
>

22 #include 
	~<signal.h
>

23 #include 
	~<unistd.h
>

24 #include 
	~<fcntl.h
>

25 #include 
	~<stdarg.h
>

26 #include 
	~<sys/wait.h
>

27 #include 
	~<sys/stat.h
>

28 #include 
	~<sys/types.h
>

29 #include 
	~<readline/readline.h
>

30 #include 
	~<readline/history.h
>

31 #include 
	~"libft/includes/libft.h
"

34 #define 
	#RED
 "\x1b[31m"

	)

35 #define 
	#BLU
 "\x1B[34m"

	)

36 #define 
	#BLU_2
 "\e[1;34m"

	)

37 #define 
	#GRN
 "\x1B[32m"

	)

38 #define 
	#YEL
 "\x1B[33m"

	)

39 #define 
	#MAG
 "\x1B[35m"

	)

40 #define 
	#CYN
 "\x1B[36m"

	)

41 #define 
	#WHT
 "\x1B[37m"

	)

42 #define 
	#RESET
 "\x1B[0m"

	)

44 #define 
	#WORD
 1

	)

45 #define 
	#PIPELINE
 2

	)

46 #define 
	#L_CHEVRON
 3

	)

47 #define 
	#R_CHEVRON
 4

	)

48 #define 
	#APPEND
 5

	)

49 #define 
	#HERE_DOC
 6

	)

50 #define 
	#DOLLAR
 7

	)

51 #define 
	#QUESTION
 8

	)

52 #define 
	#EXPAND
 9

	)

53 #define 
	#DELETE
 10

	)

54 #define 
	#EXPANDED
 11

	)

55 #define 
	#CONTINUE
 -1

	)

56 #define 
	#ERROR_EXIT
 -169

	)

57 #define 
	#ERROR_EXIT_
 0

	)

62 typedef struct 
	ss_env


64 char *
	mvar_name
;

65 char *
	mvar_value
;

66 struct 
s_env
 *
	mnext
;

67 } 
	tt_env
;

69 typedef struct 
	ss_token


71 char *
	mcontent
;

72 int 
	mid
;

73 struct 
s_token
 *
	mnext
;

74 } 
	tt_token
;

77 typedef struct 
	ss_cmd


80 char **
	mcmd
;

81 char **
	mredir
;

82 char **
	mpath
;

86 int 
	mfdout
;

87 int 
	mfdin
;

88 int 
	mfd
[2];

89 } 
	tt_cmd
;

91 typedef struct 
	ss_shell


93 
t_env
 *
	menv
;

94 int 
	mexit_status
;

95 char **
	msave_env
;

96 } 
	tt_shell
;

99 extern 
t_shell
 *
g_shell
;

101 int 
expansion
(
t_token
 **
token
, t_token *
curr
, int 
pos
);

102 int 
check_dollar
(
t_token
 *
curr
, int 
i
);

103 int 
trim_dollar
(
t_token
 *
curr
, int 
pos
);

106 int 
is_dollar_to_expand
(
t_token
 *
curr
, int 
i
);

107 int 
not_within_squotes
(
t_token
 *
curr
, int 
pos
);

110 int 
trim_dollar
(
t_token
 *
curr
, int 
pos
);

113 int 
loop_dollars
(char *
s
, int 
i
);

114 int 
loop_through
(char *
s
, int 
i
);

119 int 
size_var
(char *
s
);

120 int 
check_var_exist
(
t_token
 *
tmp
);

123 int 
join_tokens
(
t_token
 **
new
, t_token *
curr
);

126 int 
prepare_expand
(
t_token
 *
tmp
, int 
i
);

127 int 
set_id_expansion
(
t_token
 *
token
);

130 int 
quote_removing
(
t_token
 **
head
, t_token *
curr
, int 
pos
);

132 
t_token
 *
delete_token
(t_token **
head
);

133 int 
token_list_size
(
t_token
 **
head
);

136 int 
_pwd
(
t_cmd
 *
cmd
);

137 int 
_env
(
t_env
 *
env
);

140 char **
env_copied
(char **
envp
);

141 void 
free_tab
(char **
table
);

144 
t_env
 *
get_envp
(char **
envp
);

145 void 
free_env
(
t_env
 **
head
);

149 
t_token
 *
parsing
(char *
line
);

150 int 
syntax_error_check
(char *
s
);

151 int 
check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
);

152 int 
check_quotes_errors
(char *
s
, char 
c
, int *
i
);

153 int 
count_metachar
(char *
s
, char 
c
, int 
num
);

154 int 
check_multiple_operators_error
(int 
i
, int 
num
, char 
c
);

155 void 
print_syntax_error_char
(char 
c
);

156 void 
print_syntax_error_dchar
(char 
c
);

157 void 
print_syntax_error_str
(char *
s
);

160 int 
character_extraction
(char *
line
, int 
ind
);

161 int 
token_extraction
(char *
line
, int 
ind
);

162 
t_token
 *
get_tokens
(char *
line
);

163 int 
get_tokens_size
(char *
line
, int *
i
);

164 
t_token
 *
create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
);

167 void 
malloc_error_print_message
(char *
s
);

170 
t_token
 *
new_token
(char *
line
, int 
start
, int 
len
);

171 void 
set_id
(
t_token
 *
token
);

172 int 
token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
);

173 int 
link_token
(
t_token
 **
head
, t_token *
new
);

174 void 
free_token
(
t_token
 **
head
);

177 int 
is_dollar
(char 
c
);

178 int 
is_pipeline
(char 
c
);

179 int 
is_chevron
(char 
c
);

180 int 
is_lchevron
(char 
c
);

181 int 
is_rchevron
(char 
c
);

182 int 
is_operator
(char 
c
);

183 int 
is_newline
(char 
c
);

184 int 
is_white_space
(char 
c
);

185 int 
is_blank
(char 
c
);

186 int 
is_metacharacter
(char 
c
);

187 int 
is_delimiter
(char 
c
);

188 int 
is_word
(char 
c
);

189 int 
is_double_quote
(char 
c
);

190 int 
is_simple_quote
(char 
c
);

191 int 
is_quote
(char 
c
);

192 int 
is_question
(char 
c
);

193 int 
is_punct
(char 
c
);

196 int 
sig_handler
(void);

199 void 
handler_ctr_c
(int 
code
);

202 char **
ft_splitpath
(char *
s
, char 
c
);

205 char **
copy_env_tab
(
t_env
 *
env
);

	@TESTS/expansion_test/parsing.c

12 #include 
	~"minishell.h
"

16 void 
	$print_token
(
t_token
 **
head
)

18 int 
i
;

19 
t_token
 *
tmp
;

21 
i
 = 0;

22 if (!*
head
 || !head)

24 
tmp
 = *
head
;

25 while (
tmp
)

27 if (
tmp
->
id
 == 
L_CHEVRON
)

28 
	`printf
("L_CHEVRON: ");

29 else if (
tmp
->
id
 == 
R_CHEVRON
)

30 
	`printf
("R_CHEVRON: ");

31 else if (
tmp
->
id
 == 
PIPELINE
)

32 
	`printf
("PIPELINE: ");

33 else if (
tmp
->
id
 == 
WORD
)

34 
	`printf
("WORD: ");

35 else if (
tmp
->
id
 == 
APPEND
)

36 
	`printf
("APPEND: ");

37 else if (
tmp
->
id
 == 
HERE_DOC
)

38 
	`printf
("HERE_DOC: ");

39 else if (
tmp
->
id
 == 
DOLLAR
)

40 
	`printf
("DOLLAR: ");

41 while (
tmp
->
content
[
i
])

43 
	`printf
 ("%c", 
tmp
->
content
[
i
]);

44 
i
++;

46 
	`printf
 ("%c", 
tmp
->
content
[
i
]);

47 
	`printf
 ("\n");

48 
i
 = 0;

49 
tmp
 = tmp->
next
;

51 
	}
}

89 
t_token
 *
	$parsing
(char *
line
)

91 
t_token
 *
token
;

93 if (!
	`syntax_error_check
(
line
))

94 return (
NULL
);

95 
token
 = 
	`get_tokens
(
line
);

96 if (!
token
)

97 return (
NULL
);

98 if (!
	`expansion
(&
token
, token, 0))

99 return (
NULL
);

100 if (!
	`quote_removing
(&
token
, token, 0))

101 return (
NULL
);

103 return (
token
);

104 
	}
}

	@TESTS/expansion_test/parsing_expansion.c

12 #include 
	~"minishell.h
"

42 int 
	$check_dollar
(
t_token
 *
curr
, int 
i
)

44 int 
res
;

46 while (
curr
->
content
[
i
])

48 if (
	`is_dollar
(
curr
->
content
[
i
]) && 
	`not_within_squotes
(curr, i))

50 if (
	`is_dollar_to_expand
(
curr
, 
i
))

51 return (
	`prepare_expand
(
curr
, 
i
));

52 else if (
	`is_dollar
(
curr
->
content
[
i
 + 1]))

53 
i
 = 
	`loop_dollars
(
curr
->
content
, i);

54 else if (
	`is_quote
(
curr
->
content
[
i
 + 1]))

56 
res
 = 
	`trim_dollar
(
curr
, 
i
);

57 if (
res
 == 
ERROR_EXIT
)

58 return (
ERROR_EXIT
);

59 
i
 += 
res
;

61 else if (
curr
->
content
[
i
 + 1] == '\0')

64 
i
++;

67 
i
++;

69 
curr
->
id
 = 
WORD
;

70 return (
i
);

71 
	}
}

73 static void 
	$expansion_next_token
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

75 
pos
 = 0;

76 if (
curr
->
next
)

78 
curr
 = curr->
next
;

79 
	`expansion
(
head
, 
curr
, 
pos
);

81 
	}
}

107 int 
	$expansion
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

109 if (
curr
)

111 if (
curr
->
id
 == 
DOLLAR
)

113 
pos
 = 
	`check_dollar
(
curr
, pos);

114 if (
pos
 == 
ERROR_EXIT
)

115 return (
	`free_token
(
head
), 0);

116 if (
curr
->
id
 == 
DELETE
)

118 
curr
 = 
	`delete_token
(
head
);

119 if (!
curr
)

121 
head
 = 
NULL
;

124 
pos
 = 0;

126 
	`expansion
(
head
, 
curr
, 
pos
);

129 
	`expansion_next_token
(
head
, 
curr
, 
pos
);

132 
	}
}

	@TESTS/expansion_test/parsing_expansion_dollar_conditions.c

12 #include 
	~"minishell.h
"

18 int 
	$not_within_squotes
(
t_token
 *
curr
, int 
pos
)

20 int 
i
;

21 int 
start
;

23 
i
 = 0;

24 
start
 = 0;

25 if (!
	`is_dollar
(
curr
->
content
[
pos
]))

27 while (
curr
->
content
[
i
])

29 if (
	`is_double_quote
(
curr
->
content
[
i
]))

30 
i
 = 
	`loop_through
(
curr
->
content
, i);

31 else if (
	`is_simple_quote
(
curr
->
content
[
i
]))

33 
start
 = 
i
;

34 
i
 = 
	`loop_through
(
curr
->
content
, i);

35 if (
pos
 > 
start
 && pos < 
i
)

38 
i
++;

41 
	}
}

43 int 
	$is_dollar_to_expand
(
t_token
 *
curr
, int 
i
)

45 if (
	`is_question
(
curr
->
content
[
i
 + 1]) || \

46 (!
	`is_dollar
(
curr
->
content
[
i
 + 1]) && \

47 !
	`is_quote
(
curr
->
content
[
i
 + 1]) && \

48 !
	`is_punct
(
curr
->
content
[
i
 + 1]) && \

49 !
	`is_white_space
(
curr
->
content
[
i
 + 1]) && \

50 
curr
->
content
[
i
 + 1] != '\0'))

55 
	}
}

	@TESTS/expansion_test/parsing_expansion_expand_var_helper.c

12 #include 
	~"minishell.h
"

14 static int 
	$replace_content
(
t_token
 *
tmp
, char *
s
)

16 
	`free
(
tmp
->
content
);

17 
tmp
->
content
 = 
NULL
;

18 
tmp
->
content
 = 
	`ft_strdup
(
s
);

19 if (!
tmp
->
content
)

21 
	`malloc_error_print_message
("ft_strdup failed");

22 return (
ERROR_EXIT
);

25 
	}
}

27 int 
	$check_var_exist
(
t_token
 *
tmp
)

29 if (
	`ft_strncmp
(&
tmp
->
content
[1], "?", 1) == 0)

31 return (
	`replace_content
(
tmp
, 
	`ft_itoa
(
g_shell
->
exit_status
)));

33 else if (
g_shell
 && g_shell->
env
 && g_shell->env->
var_name
)

35 if (
	`ft_strncmp
(
g_shell
->
env
->
var_name
, &
tmp
->
content
[1], \

36 
	`ft_strlen
(
tmp
->
content
)) == 0)

38 return (
	`replace_content
(
tmp
, 
g_shell
->
env
->
var_value
));

42 
	}
}

44 int 
	$size_var
(char *
s
)

46 int 
i
;

47 int 
count
;

49 
i
 = 0;

50 
count
 = 0;

51 while (
s
[
i
] && 
	`is_white_space
(s[i]))

52 
i
++;

53 while (
s
[
i
] && !
	`is_white_space
(s[i]))

55 
count
++;

56 
i
++;

58 return (
count
);

59 
	}
}

	@TESTS/expansion_test/parsing_expansion_helper.c

12 #include 
	~"minishell.h
"

14 int 
	$expand_var
(
t_token
 **
new
)

16 
t_token
 *
tmp
;

17 
t_env
 *
save
;

18 int 
res
;

20 
tmp
 = *
new
;

21 
save
 = 
g_shell
->
env
;

22 while (
tmp
->
id
 != 
EXPAND
)

23 
tmp
 = tmp->
next
;

24 while (
g_shell
->
env
)

26 
res
 = 
	`check_var_exist
(
tmp
);

27 if (
res
 == 
ERROR_EXIT
)

28 return (
ERROR_EXIT
);

29 else if (
res
 == 1)

31 
tmp
->
id
 = 
EXPANDED
;

32 
g_shell
->
env
 = 
save
;

33 return (
	`size_var
(
tmp
->
content
));

35 
g_shell
->
env
 = g_shell->env->
next
;

37 
tmp
->
id
 = 
DELETE
;

38 
g_shell
->
env
 = 
save
;

40 
	}
}

42 int 
	$split_tokens
(
t_token
 **
new
, char *
s
, int 
start
, int 
len
)

44 if (
start
 != 0)

46 *
new
 = 
	`new_token
(
s
, 0, 
start
);

47 if (!*
new
)

48 return (
ERROR_EXIT
);

49 (*
new
)->
id
 = 
WORD
;

50 if (!
	`token_linked_list
(
new
, 
s
, 
start
, 
len
))

51 return (
ERROR_EXIT
);

52 (*
new
)->
next
->
id
 = 
EXPAND
;

56 *
new
 = 
	`new_token
(
s
, 
start
, 
len
);

57 if (!*
new
)

58 return (
ERROR_EXIT
);

59 (*
new
)->
id
 = 
EXPAND
;

61 
start
 += 
len
;

62 
len
 = 
start
;

63 while (
s
[
len
])

64 
len
++;

65 if (
len
 != 
start
)

66 if (!
	`token_linked_list
(
new
, 
s
, 
start
, 
len
))

67 return (
ERROR_EXIT
);

69 
	}
}

71 static int 
	$var_len
(char *
s
, int 
i
)

73 int 
len
;

75 
len
 = 0;

76 
i
++;

77 if (
	`is_question
(
s
[
i
]))

81 while (
s
[
i
] && \

82 !
	`is_white_space
(
s
[
i
]) && \

83 !
	`is_quote
(
s
[
i
]) && \

84 !
	`is_question
(
s
[
i
]) && \

85 !
	`is_dollar
(
s
[
i
]) && \

86 !
	`is_punct
(
s
[
i
]))

88 
i
++;

89 
len
++;

92 return (
len
);

93 
	}
}

95 int 
	$new_id
(
t_token
 **
new
)

97 
t_token
 *
ptr
;

99 
ptr
 = *
new
;

100 while (
ptr
)

102 if (
ptr
->
id
 == 
DELETE
 || ptr->id == 
EXPANDED
)

104 
ptr
 = ptr->
next
;

106 if (
ptr
->
next
 == 
NULL
)

107 return (
WORD
);

108 return(
	`set_id_expansion
(
ptr
->
next
));

109 
	}
}

116 int 
	$prepare_expand
(
t_token
 *
curr
, int 
i
)

118 
t_token
 *
new
;

119 int 
len
;

120 int 
id
;

122 
new
 = 
NULL
;

123 
len
 = 
	`var_len
(
curr
->
content
, 
i
);

124 if (
	`split_tokens
(&
new
, 
curr
->
content
, 
i
, 
len
 + 1) == 
ERROR_EXIT
)

125 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

126 
len
 = 
	`expand_var
(&
new
);

127 if (
len
 == 
ERROR_EXIT
)

128 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

129 
id
 = 
	`new_id
 (&
new
);

130 if (
	`join_tokens
(&
new
, 
curr
) == 
ERROR_EXIT
)

131 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

132 if (
curr
->
id
 == 
DELETE
)

134 
curr
->
id
 = id ;

135 return (
len
 + 
i
);

136 
	}
}

	@TESTS/expansion_test/parsing_expansion_join_tokens.c

12 #include 
	~"minishell.h
"

14 static int 
	$get_expanded_size
(char *
s
, int 
i
)

16 int 
size
;

18 
size
 = 0;

19 while (
	`is_white_space
(
s
[
i
]))

20 
i
++;

21 while (
s
[
i
] && !
	`is_white_space
(s[i]))

23 
i
++;

24 
size
++;

26 return (
size
);

27 
	}
}

29 static int 
	$get_new_size
(
t_token
 **
new
)

31 
t_token
 *
ptr
;

32 int 
size
;

33 int 
i
;

35 
size
 = 0;

36 
ptr
 = *
new
;

37 while (
ptr
)

39 
i
 = 0;

40 if (
ptr
->
id
 == 
EXPANDED
)

41 
size
 += 
	`get_expanded_size
(
ptr
->
content
, 
i
);

42 else if (
ptr
->
id
 != 
DELETE
)

44 while (
ptr
->
content
[
i
])

46 
size
++;

47 
i
++;

50 
ptr
 = ptr->
next
;

52 return (
size
);

53 
	}
}

55 static void 
	$copy_helper
(
t_token
 **
new
, t_token *
curr
)

57 int 
i
;

58 int 
j
;

59 
t_token
 *
ptr
;

61 
i
 = 0;

62 
j
 = 0;

63 
ptr
 = *
new
;

64 while (
ptr
)

66 if (
ptr
->
id
 == 
EXPANDED
)

68 while (
ptr
->
content
[
j
] && 
	`is_white_space
(ptr->content[j]))

69 
j
++;

70 while (
ptr
->
content
[
j
] && !
	`is_white_space
(ptr->content[j]))

71 
curr
->
content
[
i
++] = 
ptr
->content[
j
++];

73 else if (
ptr
->
id
 != 
DELETE
)

74 while (
ptr
->
content
[
j
])

75 
curr
->
content
[
i
++] = 
ptr
->content[
j
++];

76 
ptr
 = ptr->
next
;

77 
j
 = 0;

79 
curr
->
content
[
i
] = '\0';

80 
	}
}

82 static int 
	$copy_join_tokens
(
t_token
 **
new
, t_token *
curr
, int 
size
)

84 
	`free
(
curr
->
content
);

85 
curr
->
content
 = 
NULL
;

86 
curr
->
content
 = 
	`malloc
((
size
 + 1) * sizeof(char));

87 if (!
curr
->
content
)

89 
	`malloc_error_print_message
(
	`strerror
(
errno
));

90 return (
ERROR_EXIT
);

92 
	`copy_helper
(
new
, 
curr
);

93 
	`free_token
(
new
);

95 
	}
}

97 int 
	$join_tokens
(
t_token
 **
new
, t_token *
curr
)

99 int 
size
;

101 
size
 = 
	`get_new_size
(
new
);

102 if (
size
 == 0)

104 
	`free_token
(
new
);

105 
curr
->
id
 = 
DELETE
;

108 if (
	`copy_join_tokens
(
new
, 
curr
, 
size
) == 
ERROR_EXIT
)

109 return (
ERROR_EXIT
);

111 
	}
}

	@TESTS/expansion_test/parsing_expansion_looping.c

12 #include 
	~"minishell.h
"

53 int 
	$loop_dollars
(char *
s
, int 
i
)

55 while (
	`is_dollar
(
s
[
i
]) && s[i])

56 
i
++;

57 if (
s
[
i
] != '\0' && !
	`is_white_space
(s[i]))

58 
i
--;

59 return (
i
);

60 
	}
}

68 int 
	$loop_through
(char *
s
, int 
i
)

70 char 
c
;

72 
c
 = 
s
[
i
];

73 
i
++;

74 while (
s
[
i
] != 
c
)

75 
i
++;

76 return (
i
);

77 
	}
}

	@TESTS/expansion_test/parsing_expansion_trim_dollar.c

12 #include 
	~"minishell.h
"

17 static int 
	$copy_string
(
t_token
 *
curr
, char **
s
, int 
pos
)

19 int 
i
;

20 int 
j
;

22 
i
 = 0;

23 
j
 = 0;

24 *
s
 = 
	`malloc
(sizeof(char) * 
	`ft_strlen
(
curr
->
content
));

25 if (!*
s
)

27 
i
 = 0;

28 while (
curr
->
content
[
i
])

30 if (
i
 == 
pos
)

31 
i
++;

32 (*
s
)[
j
] = 
curr
->
content
[
i
];

33 
i
++;

34 
j
++;

36 (*
s
)[
j
] = '\0';

37 
	`free
(
curr
->
content
);

38 
curr
->
content
 = *
s
;

40 
	}
}

46 int 
	$trim_dollar
(
t_token
 *
curr
, int 
pos
)

48 int 
i
;

49 int 
start
;

50 char *
s
;

52 
s
 = 
NULL
;

53 
i
 = 0;

54 
start
 = 0;

55 while (
curr
->
content
[
i
])

57 if (
	`is_double_quote
(
curr
->
content
[
i
]))

59 
start
 = 
i
;

60 
i
 = 
	`loop_through
(
curr
->
content
, i);

61 if (
pos
 > 
start
 && pos < 
i
)

64 
i
++;

66 if (!
	`copy_string
(
curr
, &
s
, 
pos
))

67 return (
ERROR_EXIT
);

69 
	}
}

	@TESTS/expansion_test/parsing_quote_removing.c

12 #include 
	~"minishell.h
"

14 static int 
copy_string_unquoted
(
t_token
 *
curr
, char *
new_str
, \

15 int 
start
, int 
pos
)

17 int 
	gj
;

18 int 
	gi
;

19 int 
	gsave
;

21 
	gj
 = 0;

22 
	gi
 = 0;

23 
	gsave
 = 0;

24 while (
	gcurr
->
	gcontent
[
i
])

26 if (
	gi
 == 
start
)

27 
i
++;

28 else if (
	gi
 == 
pos
)

30 
i
++;

31 
	gsave
 = 
j
;

35 
	gnew_str
[
j
] = 
curr
->
content
[
i
];

36 
	gi
++;

37 
	gj
++;

40 
	gnew_str
[
j
] = '\0';

41 return (
	gsave
);

44 int 
	$string_replace
(
t_token
 *
curr
, int 
start
, int 
pos
)

46 int 
save
;

47 char *
new_str
;

49 
new_str
 = 
	`malloc
(sizeof(char) * (
	`ft_strlen
(
curr
->
content
) - 2 + 1));

50 if (!
new_str
)

52 
	`malloc_error_print_message
(
	`strerror
(
errno
));

53 return (
ERROR_EXIT
);

55 
save
 = 
	`copy_string_unquoted
(
curr
, 
new_str
, 
start
, 
pos
);

56 
	`free
(
curr
->
content
);

57 
curr
->
content
 = 
NULL
;

58 
curr
->
content
 = 
new_str
;

59 return (
save
);

60 
	}
}

62 int 
	$remove_q
(
t_token
 *
curr
, int 
pos
)

64 int 
start
;

66 
start
 = 
pos
;

67 
pos
 = 
	`loop_through
(
curr
->
content
, pos);

68 
pos
 = 
	`string_replace
(
curr
, 
start
, pos);

69 if (
pos
 == 
ERROR_EXIT
)

70 return (
ERROR_EXIT
);

71 return (
pos
++);

72 
	}
}

74 int 
	$quote_removing
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

76 if (!
head
 || !*head)

78 if (
curr
->
content
[
pos
] == '\0')

80 if (
curr
->
next
)

82 
pos
 = 0;

83 
curr
 = curr->
next
;

84 
	`quote_removing
(
head
, 
curr
, 
pos
);

88 else if (
	`is_quote
(
curr
->
content
[
pos
]))

90 
pos
 = 
	`remove_q
(
curr
, pos);

91 if (
pos
 == 
ERROR_EXIT
)

92 return (
	`free_token
(
head
), 0);

93 
	`quote_removing
(
head
, 
curr
, 
pos
);

97 
pos
++;

98 
	`quote_removing
(
head
, 
curr
, 
pos
);

101 
	}
}

	@TESTS/expansion_test/parsing_syntax_errors.c

12 #include 
	~"minishell.h
"

14 int 
	$check_multiple_operators_error
(int 
i
, int 
num
, char 
c
)

16 if (
i
 > 
num
)

18 if (
	`is_chevron
(
c
))

19 
	`print_syntax_error_dchar
(
c
);

20 else if (
	`is_pipeline
(
c
))

21 
	`print_syntax_error_char
(
c
);

25 
	}
}

27 int 
	$count_metachar
(char *
s
, char 
c
, int 
num
)

29 int 
i
;

31 
i
 = 1;

32 while (
s
[
i
] && s[i] == 
c
)

33 
i
++;

34 if (!
	`check_multiple_operators_error
(
i
, 
num
, 
c
))

36 while (
s
[
i
] && 
	`is_blank
(s[i]))

37 
i
++;

38 if (
	`is_operator
(
s
[
i
]) && !
	`is_pipeline
(
c
))

40 
c
 = 
s
[
i
];

41 if (
	`is_chevron
(
c
) && is_chevron(
s
[
i
 + 1]))

42 return (
	`print_syntax_error_dchar
(
c
), 0);

44 
	`print_syntax_error_char
(
c
);

47 else if (
s
[
i
] == '\0')

48 return (
	`print_syntax_error_str
("newline"), 0);

50 
	}
}

52 int 
	$check_quotes_errors
(char *
s
, char 
c
, int *
i
)

54 int 
j
;

56 
j
 = *
i
 + 1;

57 while (
s
[
j
] && s[j] != 
c
)

58 
j
++;

59 if (
s
[
j
] != 
c
)

61 
	`print_syntax_error_char
(
c
);

64 (*
i
)++;

65 while (
s
[*
i
] && s[*i] != 
c
)

66 (*
i
)++;

68 
	}
}

70 int 
	$check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
)

72 int 
j
;

74 
j
 = 0;

75 while (
s
[
j
] && 
	`is_blank
(s[j]))

76 
j
++;

77 if (
s
[
j
] == 
c
)

79 
	`print_syntax_error_char
(
c
);

82 if (!
	`count_metachar
(&
s
[
i
], 
c
, 
num
))

85 
	}
}

132 int 
	$syntax_error_check
(char *
s
)

134 int 
i
;

136 
i
 = 0;

137 while (
s
[
i
])

139 if (
	`is_quote
(
s
[
i
]))

141 if (!
	`check_quotes_errors
(
s
, s[
i
], &i))

142 return (
	`free
(
s
), 0);

144 else if ((
	`is_lchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '<', 2)) || \

145 (
	`is_rchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '>', 2)))

146 return (
	`free
(
s
), 0);

147 else if (
	`is_pipeline
(
s
[
i
]) && !
	`check_pipeline_errors
(s, i, '|', 1))

148 return (
	`free
(
s
), 0);

149 
i
++;

152 
	}
}

	@TESTS/expansion_test/parsing_syntax_errors_print_message.c

12 #include 
	~"minishell.h
"

19 void 
	$print_syntax_error_char
(char 
c
)

21 
	`ft_dprintf
(2, "minishell: ");

22 
	`ft_dprintf
(2, "syntax error near unexpected token ");

23 
	`ft_dprintf
(2, "\'%c\'\n", 
c
);

24 
g_shell
->
exit_status
 = 258;

25 
	}
}

27 void 
	$print_syntax_error_dchar
(char 
c
)

29 
	`ft_dprintf
(2, "minishell: ");

30 
	`ft_dprintf
(2, "syntax error near unexpected token ");

31 
	`ft_dprintf
(2, "\'%c%c\'\n", 
c
, c);

32 
g_shell
->
exit_status
 = 258;

33 
	}
}

35 void 
	$print_syntax_error_str
(char *
s
)

37 
	`ft_dprintf
(2, "minishell: ");

38 
	`ft_dprintf
(2, "syntax error near unexpected token ");

39 
	`ft_dprintf
(2, "\'%s\'\n", 
s
);

40 
g_shell
->
exit_status
 = 258;

41 
	}
}

	@TESTS/expansion_test/parsing_token_extraction.c

12 #include 
	~"minishell.h
"

21 int 
	$character_extraction
(char *
line
, int 
ind
)

23 if ((
line
[
ind
] == '>' && line[ind + 1] == '>') || \

24 (
line
[
ind
] == '<' && line[ind + 1] == '<'))

27 
	}
}

43 int 
	$word_extraction
(char *
line
, int 
ind
)

45 int 
start
;

46 char 
c
;

48 
start
 = 
ind
;

49 while (
	`is_word
(
line
[
ind
]) && line[ind])

51 if (
	`is_quote
(
line
[
ind
]))

53 
c
 = 
line
[
ind
];

54 
ind
++;

55 while (
line
[
ind
] && line[ind] != 
c
)

56 
ind
++;

58 
ind
++;

60 return (
ind
 - 
start
);

61 
	}
}

64 int 
	$get_tokens_size
(char *
line
, int *
i
)

66 int 
len
;

68 
len
 = 0;

69 while (
	`is_white_space
(
line
[*
i
]))

70 (*
i
)++;

71 if (
	`is_word
(
line
[*
i
]))

72 
len
 = 
	`word_extraction
(
line
, *
i
);

73 else if (
	`is_operator
(
line
[*
i
]))

74 
len
 = 
	`character_extraction
(
line
, *
i
);

75 return (
len
);

76 
	}
}

83 
t_token
 *
	$create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
)

85 
t_token
 *
head
;

87 
head
 = 
	`new_token
(
line
, 
i
, 
len
);

88 if (!
head
)

89 return (
NULL
);

90 *
flag
 = 1;

91 return (
head
);

92 
	}
}

122 
t_token
 *
	$get_tokens
(char *
line
)

124 int 
i
;

125 int 
len
;

126 int 
flag
;

127 
t_token
 *
head
;

129 
i
 = 0;

130 
flag
 = 0;

131 
head
 = 
NULL
;

132 while (
line
[
i
])

134 
len
 = 
	`get_tokens_size
(
line
, &
i
);

135 if (
len
 == 0)

137 if (!
flag
)

139 
head
 = 
	`create_token_head
(
line
, 
i
, 
len
, &
flag
);

140 if (!
head
)

141 return (
	`free
(
line
), 
NULL
);

144 if (!
	`token_linked_list
(&
head
, 
line
, 
i
, 
len
))

145 return (
	`free_token
(&
head
), 
	`free
(
line
), 
NULL
);

146 
i
 += 
len
;

148 return (
	`free
(
line
), 
head
);

149 
	}
}

	@TESTS/expansion_test/token_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_token
(
t_token
 **
head
)

16 
t_token
 *
ptr
;

17 
t_token
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
content
);

27 
	`free
(
tmp
);

29 *
head
 = 
NULL
;

30 
head
 = 
NULL
;

31 
	}
}

46 
t_token
 *
	$new_token
(char *
line
, int 
start
, int 
len
)

48 
t_token
 *
token
;

50 
token
 = 
NULL
;

51 
token
 = 
	`malloc
(sizeof(
t_token
));

52 if (!
token
)

54 
	`malloc_error_print_message
(
	`strerror
(
errno
));

55 return (
NULL
);

57 
token
->
content
 = 
	`ft_substr
(
line
, 
start
, 
len
);

58 if (!
token
->
content
)

60 
	`malloc_error_print_message
(
	`strerror
(
errno
));

61 return (
	`free_token
(&
token
), 
NULL
);

63 
	`set_id
(
token
);

64 
token
->
next
 = 
NULL
;

65 return (
token
);

66 
	}
}

75 int 
	$link_token
(
t_token
 **
head
, t_token *
new
)

77 
t_token
 *
ptr
;

79 if (!
new
)

81 
ptr
 = *
head
;

82 while (
ptr
)

84 if (!
ptr
->
next
)

86 
ptr
 = ptr->
next
;

88 
ptr
->
next
 = 
new
;

90 
	}
}

113 int 
	$token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
)

115 
t_token
 *
new
;

117 if (!
head
)

119 
new
 = 
	`new_token
(
line
, 
start
, 
len
);

120 if (!
new
)

122 if (!
	`link_token
(
head
, 
new
))

125 
	}
}

	@TESTS/expansion_test/token_routine_delete.c

12 #include 
	~"minishell.h
"

14 int 
	$token_list_size
(
t_token
 **
head
)

16 
t_token
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

29 static 
t_token
 *
delete_helper
(t_token **
head
, t_token *
curr
, \

30 
t_token
 *
prev
, int 
i
)

32 int 
	gsize
;

34 
	gsize
 = 
token_list_size
(
head
);

35 if (
	gi
 == 0 && 
size
 == 1)

37 
free
(
curr
->
content
);

38 
free
(
curr
);

39 *
	ghead
 = 
NULL
;

40 return (*
	ghead
);

42 else if (
	gi
 == 0 && 
size
 > 1)

44 *
head
 = 
curr
->
next
;

45 
	gprev
 = *
head
;

47 else if (
	gi
 == 
size
 - 1)

48 
prev
->
next
 = 
NULL
;

50 
	gprev
->
	gnext
 = 
curr
->
next
;

51 
free
(
curr
->
content
);

52 
free
(
curr
);

53 
	gcurr
 = 
NULL
;

54 return (
	gprev
);

57 
t_token
 *
	$delete_token
(
t_token
 **
head
)

59 int 
i
;

60 
t_token
 *
curr
;

61 
t_token
 *
prev
;

63 
i
 = 0;

64 
curr
 = *
head
;

65 
prev
 = 
NULL
;

66 while (
curr
->
id
 != 
DELETE
)

68 
prev
 = 
curr
;

69 
curr
 = curr->
next
;

70 
i
++;

72 return (
	`delete_helper
(
head
, 
curr
, 
prev
, 
i
));

73 
	}
}

	@TESTS/expansion_test/token_routine_set_id.c

12 #include 
	~"minishell.h
"

14 int 
	$set_id_expansion
(
t_token
 *
token
)

16 if (
	`ft_strchr
(
token
->
content
, '$'))

17 return(
DOLLAR
);

18 return (
WORD
);

19 
	}
}

21 void 
	$set_id
(
t_token
 *
token
)

23 if (
	`ft_strncmp
(
token
->
content
, "|", 2) == 0)

24 
token
->
id
 = 
PIPELINE
;

25 else if (
	`ft_strncmp
(
token
->
content
, "<", 2) == 0)

26 
token
->
id
 = 
L_CHEVRON
;

27 else if (
	`ft_strncmp
(
token
->
content
, ">", 2) == 0)

28 
token
->
id
 = 
R_CHEVRON
;

29 else if (
	`ft_strncmp
(
token
->
content
, "<<", 3) == 0)

30 
token
->
id
 = 
HERE_DOC
;

31 else if (
	`ft_strncmp
(
token
->
content
, ">>", 3) == 0)

32 
token
->
id
 = 
APPEND
;

33 else if (
	`ft_strchr
(
token
->
content
, '$'))

34 
token
->
id
 = 
DOLLAR
;

36 
token
->
id
 = 
WORD
;

38 
	}
}

	@TESTS/parsing tests/main_parsing_syntax_errors.c

12 #include 
	~"minishell.h
"

14 int 
	gg_exit_status
 = 0;

18 int 
	$main
(int 
ac
, char **
av
)

20 (void)
ac
;

21 char *
line
;

22 
line
 = 
	`ft_strdup
(
av
[1]);

23 
	`syntax_error_check
(
line
);

24 
	`printf
("exit_status = %d\n", 
exit_status
);

25 return (
exit_status
);

26 
	}
}

	@TESTS/parsing tests/main_parsing_token_extraction.c

12 #include 
	~"minishell.h
"

14 int 
	gexit_status
 = 0;

26 int 
	$main
(int 
ac
, char **
av
)

28 (void)
ac
;

29 
t_token
 *
head
;

30 
t_token
 *
ptr
;

31 char *
line
;

33 
line
 = 
NULL
;

34 
head
 = 
NULL
;

35 
line
 = 
	`ft_strdup
(
av
[1]);

36 
head
 = 
	`get_words
(
line
);

37 if (!
head
)

39 
	`printf
(" exit from main\n");

40 return (
exit_status
);

42 
ptr
 = 
head
;

43 while (
ptr
)

45 
	`printf
("from main: %s\n", 
ptr
->
content
);

46 
ptr
 = ptr->
next
;

48 
	`free_token
(&
head
);

49 return (
exit_status
);

50 
	}
}

	@TESTS/parsing tests/main_token_routine.c

12 #include 
	~"minishell.h
"

14 int 
	gg_exit_status
 = 0;

18 int 
	$main
(int 
ac
, char **
av
)

20 (void)
ac
;

21 
t_token
 *
head
;

22 
t_token
 *
ptr
;

23 int 
i
;

24 int 
j
;

25 char **
line
;

27 
i
 = 0;

28 
j
 = 1;

29 
line
 = 
	`malloc
(sizeof(char *) * 
ac
);

30 while (
av
[
j
])

32 
line
[
i
] = 
	`ft_strdup
(
av
[
j
]);

33 
i
++;

34 
j
++;

36 
line
[
i
] = 
NULL
;

37 
head
 = 
NULL
;

38 
head
 = 
	`new_token
(
line
[0], 0, 
	`ft_strlen
(line[0]));

39 if (!
head
)

41 
	`printf
("malloc: %s\n", 
	`strerror
(
errno
));

44 
i
 = 1;

45 while (
line
[
i
])

47 
	`token_linked_list
(&
head
, 
line
[
i
], 0, 
	`ft_strlen
(line[i]));

48 
i
++;

50 
i
 = 0;

51 
ptr
 = 
head
;

52 while (
ptr
)

54 
	`printf
("%s\n", 
ptr
->
content
);

55 
ptr
 = ptr->
next
;

56 
i
++;

58 
	`free_token
(&
head
);

59 return (
exit_status
);

60 
	}
}

	@TESTS/test_getenv.c

1 #include 
	~"minishell.h
"

6 int 
	$main
(int 
ac
, char **
av
, char **
envp
)

8 (void)
ac
;

9 (void)
av
;

11 
t_env
 **
env
;

12 
t_env
 *
ptr
;

13 
env
 = 
	`get_envp
(
envp
);

14 if (!
env
)

16 
ptr
 = *
env
;

17 while (
ptr
 != 
NULL
)

19 
	`printf
("%s", 
ptr
->
var_name
);

20 
	`printf
("%s\n", 
ptr
->
var_value
);

21 
ptr
 = ptr->
next
;

24 
	}
}

	@TESTS/test_tgetent.c

1 #include 
	~<stdio.h
>

2 #include 
	~<stdlib.h
>

3 #include 
	~<termcap.h
>

5 int 
	$main
() {

6 char 
term_buffer
[2048];

7 char *
term_type
 = 
	`getenv
("TERM");

9 if (
term_type
 == 
NULL
) {

10 
	`fprintf
(
stderr
, "La variable d'environnement TERM n'est pas dfinie.\n");

15 if (
	`tgetent
(
term_buffer
, 
term_type
) != 1) {

16 
	`fprintf
(
stderr
, "Impossible d'obtenir les informations du terminal.\n");

21 char *
cursor_motion
 = 
	`tgetstr
("cm", 
NULL
);

22 if (
cursor_motion
 == 
NULL
) {

23 
	`fprintf
(
stderr
, "La capacit cm (dplacement du curseur) n'est pas prise en charge par ce terminal.\n");

27 
	`printf
("Les informations du terminal %s ont t rcupres avec succs.\n", 
term_type
);

28 
	`printf
("La capacit cm (dplacement du curseur) est : %s\n", 
cursor_motion
);

31 
	}
}

	@builtins/cd.c

12 #include 
	~"minishell.h
"

14 static void 
	$change_env_error
(char *
oldpwd
, char *
pwd
, 
t_cmd
 **
head
)

16 
	`malloc_error_print_message
("ft_strdup failed");

17 if (
oldpwd
)

18 
	`free
 (
oldpwd
);

19 if (
pwd
)

20 
	`free
 (
pwd
);

21 
	`free_and_exit_prog
(
head
, 1);

22 
	}
}

24 static void 
	$change_env
(char *
oldpwd
, char *
pwd
, 
t_cmd
 **
head
)

26 
t_env
 *
env
;

28 
env
 = 
g_shell
->env;

29 while (
env
 != 
NULL
)

31 if (
	`ft_strncmp
(
env
->
var_name
, "OLDPWD", 7) == 0)

33 
	`free
(
env
->
var_value
);

34 
env
->
var_value
 = 
NULL
;

35 
env
->
var_value
 = 
	`ft_strdup
(
oldpwd
);

36 if (!
env
->
var_value
)

37 
	`change_env_error
(
oldpwd
, 
pwd
, 
head
);

39 if (
	`ft_strncmp
(
env
->
var_name
, "PWD", 4) == 0)

41 
	`free
(
env
->
var_value
);

42 
env
->
var_value
 = 
NULL
;

43 
env
->
var_value
 = 
	`ft_strdup
(
pwd
);

44 if (!
env
->
var_value
)

45 
	`change_env_error
(
oldpwd
, 
pwd
, 
head
);

47 
env
 = env->
next
;

49 
g_shell
->
exit_status
 = 0;

50 return (
	`free
(
oldpwd
), free(
pwd
));

51 
	}
}

53 static void 
	$print_chdir_error
(char *
arg
, char *
err
)

55 
	`ft_dprintf
(2, "minishell: cd: %s: ", 
arg
);

56 
	`ft_dprintf
(2, "%s\n", 
err
);

57 
g_shell
->
exit_status
 = 1;

58 
	}
}

60 static int 
	$change_dir
(char *
oldpwd
, char *
path
)

62 int 
res
;

64 
res
 = 
	`chdir
(
path
);

65 if (
res
 == -1)

67 
	`free
(
oldpwd
);

68 
	`print_chdir_error
(
path
, 
	`strerror
(
errno
));

71 
g_shell
->
exit_status
 = 0;

73 
	}
}

76 void 
	$_cd
(
t_cmd
 *
cmd
, t_cmd **
head
)

78 int 
res
;

79 char *
oldpwd
;

80 char *
pwd
;

82 
oldpwd
 = 
	`getcwd
(
NULL
, 0);

83 if (!
oldpwd
)

85 
	`print_getcwd_error
(
	`strerror
(
errno
));

88 if (
	`size_tab2d
(
cmd
->cmd) == 1)

89 
res
 = 
	`change_dir
(
oldpwd
, 
	`get_env_var_value
("HOME"));

91 
res
 = 
	`change_dir
(
oldpwd
, 
cmd
->cmd[1]);

92 if (!
res
)

94 
pwd
 = 
	`getcwd
(
NULL
, 0);

95 if (!
pwd
)

97 
	`free
(
oldpwd
);

98 
	`print_getcwd_error
(
	`strerror
(
errno
));

101 
	`change_env
(
oldpwd
, 
pwd
, 
head
);

102 
	}
}

	@builtins/echo.c

12 #include 
	~"minishell.h
"

14 static void 
	$print_echo
(char **
s
, int 
i
)

16 int 
size
;

18 
size
 = 
i
;

19 while (
s
[
size
])

20 
size
++;

21 if (
size
 == 
i
)

23 while (
s
[
i
])

25 
	`ft_printf
("%s", 
s
[
i
]);

26 if (
i
 != 
size
 - 1)

27 
	`ft_printf
(" ");

28 
i
++;

30 
	}
}

32 static int 
	$size_echo_cmd
(char **
s
)

34 int 
i
;

36 
i
 = 0;

37 while (
s
[
i
])

38 
i
++;

39 return (
i
);

40 
	}
}

42 int 
	$_echo
(
t_cmd
 *
cmd
)

44 if (
	`size_echo_cmd
(
cmd
->cmd) == 1)

46 
	`ft_printf
("\n");

47 
g_shell
->
exit_status
 = 0;

50 if (
	`ft_strncmp
(
cmd
->cmd[1], "-n", 3) != 0)

52 
	`print_echo
(
cmd
->cmd, 1);

53 
	`ft_printf
("\n");

56 
	`print_echo
(
cmd
->cmd, 2);

57 
g_shell
->
exit_status
 = 0;

59 
	}
}

	@builtins/env.c

12 #include 
	~"minishell.h
"

14 static int 
	$check_env
(
t_cmd
 *
cmd
)

16 int 
size
;

18 
size
 = 
	`size_tab2d
(
cmd
->cmd);

19 if (
size
 == 1)

21 
	`ft_dprintf
(2, "env: %s: ", 
cmd
->cmd[1]);

22 
	`ft_dprintf
(2, "No such file or directory\n");

23 
g_shell
->
exit_status
 = 127;

25 
	}
}

27 void 
	$_env
(
t_cmd
 *
cmd
, 
t_env
 *
env
)

29 int 
res
;

31 
res
 = 
	`check_env
(
cmd
);

32 if (!
res
)

34 if (!
env
)

36 
g_shell
->
exit_status
 = 0;

39 while (
env
 != 
NULL
)

41 if (
env
->
var_value
)

43 
	`ft_printf
("%s=", 
env
->
var_name
);

44 if (
env
->
var_value
)

45 
	`ft_printf
("%s\n", 
env
->
var_value
);

47 
env
 = env->
next
;

49 
g_shell
->
exit_status
 = 0;

51 
	}
}

	@builtins/exit.c

12 #include 
	~"minishell.h
"

14 static void 
	$first_argument_is_numeric
(
t_cmd
 **
head
, int 
size
)

16 int 
exit_status
;

18 
exit_status
 = 0;

19 if (
size
 == 2)

21 
	`printf
("exit\n");

22 
exit_status
 = 
	`ft_atoi
((*
head
)->
cmd
[1]);

23 
	`free_before_exit
(
head
);

24 
	`exit
 (
exit_status
 % 256);

26 else if (
size
 > 2)

28 
	`ft_dprintf
(2, "exit\n");

29 
	`ft_dprintf
(2, "minishell: exit: too many arguments\n");

30 
g_shell
->
exit_status
 = 1;

32 
	}
}

34 static int 
	$check_exit_arguments
(
t_cmd
 **
head
)

36 int 
size
;

38 
size
 = 
	`size_tab2d
((*
head
)->
cmd
);

39 if (
size
 == 1)

41 if (
	`is_numeric
((*
head
)->
cmd
[1]))

42 
	`first_argument_is_numeric
(
head
, 
size
);

45 
	`ft_dprintf
(2, "exit\n");

46 
	`ft_dprintf
(2, "minishell: exit: %s: ", (*
head
)->
cmd
[1]);

47 
	`ft_dprintf
(2, "numeric argument required\n");

48 
	`free_before_exit
(
head
);

49 
	`exit
 (255);

52 
	}
}

54 void 
	$ft_exit
(
t_cmd
 **
head
)

56 int 
res
;

57 int 
exit_status
;

59 
res
 = 
	`check_exit_arguments
(
head
);

60 if (!
res
)

62 
exit_status
 = 
g_shell
->exit_status;

63 
	`free_before_exit
(
head
);

64 
	`printf
("exit\n");

65 
	`exit
 (
exit_status
);

67 
	}
}

	@builtins/export.c

12 #include 
	~"minishell.h
"

14 static int 
	$change_env_var
(char *
s
, char *
var_name
, int 
i
)

16 
t_env
 *
env
;

18 
env
 = 
g_shell
->env;

19 while (
env
)

21 if (
	`ft_strncmp
(
var_name
, 
env
->var_name, 
	`ft_strlen
(var_name)) == 0)

23 
env
 = env->
next
;

25 
	`free
(
env
->
var_value
);

26 
env
->
var_value
 = 
NULL
;

27 
env
->
var_value
 = 
	`ft_substr
(
s
, 
i
 + 1, 
	`ft_strlen
(s) - (i + 1)) ;

28 if (!
env
->
var_value
)

30 
	`malloc_error_print_message
("ft_strdup failed");

34 
	}
}

36 static int 
	$export_with_args_helper
(char *
var_name
, char *
s
, int 
i
)

38 int 
res
;

39 
t_env
 *
new
;

41 
res
 = 
	`check_if_var_exists
(
var_name
);

42 if (!
res
)

44 
new
 = 
	`new_env
(
s
);

45 if (!
new
)

47 if (!
g_shell
->
env
)

48 
g_shell
->
env
 = 
new
;

50 
	`link_env
(&
g_shell
->
env
, 
new
);

52 else if (
res
 && 
s
[
i
] == '=')

54 if (!
	`change_env_var
(
s
, 
var_name
, 
i
))

58 
	}
}

60 static int 
	$export_with_args
(char *
s
)

62 int 
res
;

63 int 
i
;

64 char *
var_name
;

66 
i
 = 0;

67 
res
 = 
	`check_if_valid_identifier
(
s
, "export");

68 if (!
res
)

70 while (
s
[
i
] && s[i] != '=')

71 
i
++;

72 if (
s
[
i
] == '=' && (
	`is_blank
(s[i - 1]) || is_blank(s[i + 1])))

74 
	`print_export_unset_error
(
s
, "export");

77 
var_name
 = 
	`ft_substr
(
s
, 0, 
i
);

78 if (!
var_name
)

80 
	`malloc_error_print_message
("ft_substr failed");

81 return (
ERROR_EXIT
);

83 
res
 = 
	`export_with_args_helper
(
var_name
, 
s
, 
i
);

84 
	`free
(
var_name
);

85 return (
res
);

86 
	}
}

88 static void 
	$export_no_args
(void)

90 
t_env
 *
env
;

92 
env
 = 
g_shell
->env;

93 while (
env
)

95 if (
env
->
var_value
)

97 
	`ft_printf
("declare -x %s=", 
env
->
var_name
);

98 
	`ft_printf
("\"%s\"\n", 
env
->
var_value
);

101 
	`ft_printf
("declare -x %s\n", 
env
->
var_name
);

102 
env
 = env->
next
;

104 
	}
}

111 void 
	$_export
(
t_cmd
 *
cmd
, t_cmd **
head
)

113 int 
i
;

114 int 
res
;

115 int 
save
;

117 
save
 = 1;

118 
i
 = 
	`size_tab2d
(
cmd
->cmd);

119 if (
i
 == 1)

121 
	`export_no_args
();

124 
i
 = 1;

125 while (
cmd
->cmd[
i
])

127 
res
 = 
	`export_with_args
(
cmd
->cmd[
i
]);

128 if (
res
 == 
ERROR_EXIT
)

129 
	`free_and_exit_prog
(
head
, 1);

130 else if (!
res
)

131 
save
 = 
res
;

132 
i
++;

134 if (!
save
)

135 
g_shell
->
exit_status
 = 1;

137 
g_shell
->
exit_status
 = 0;

138 
	}
}

	@builtins/export_unset_helper.c

12 #include 
	~"minishell.h
"

14 void 
	$print_export_unset_error
(char *
identifier
, char *
command
)

16 
	`ft_printf
("minishell: %s: ", 
command
);

17 
	`ft_printf
("`%s': not a valid identifier\n", 
identifier
);

18 
g_shell
->
exit_status
 = 1;

19 
	}
}

26 int 
	$check_if_valid_identifier
(char *
s
, char *
command
)

28 if (
	`is_punct
(
s
[0]) || 
	`ft_isdigit
(s[0]) || s[0] == '_')

30 
	`print_export_unset_error
(
s
, 
command
);

34 
	}
}

42 int 
	$check_if_var_exists
(char *
s
)

44 
t_env
 *
env
;

46 
env
 = 
g_shell
->env;

47 while (
env
)

49 if (
	`ft_strncmp
(
s
, 
env
->
var_name
, 
	`ft_strlen
(s)) == 0)

51 
env
 = env->
next
;

54 
	}
}

	@builtins/pwd.c

12 #include 
	~"minishell.h
"

14 void 
	$print_getcwd_error
(char *
s
)

16 
	`ft_dprintf
(2, "minishell: cd: getcwd: %s\n", 
s
);

17 
g_shell
->
exit_status
 = 1;

18 
	}
}

20 void 
	$_pwd
(void)

22 char *
cwd
;

23 
cwd
 = 
	`getcwd
(
NULL
, 0);

24 if (!
cwd
)

26 
	`print_getcwd_error
(
	`strerror
(
errno
));

29 
	`ft_printf
("%s\n", 
cwd
);

30 
	`free
(
cwd
);

31 
g_shell
->
exit_status
 = 0;

33 
	}
}

	@builtins/unset.c

12 #include 
	~"minishell.h
"

14 static int 
	$env_list_size
(
t_env
 **
head
)

16 
t_env
 *
env
;

17 int 
i
;

19 
env
 = *
head
;

20 
i
 = 0;

21 while (
env
)

23 
env
 = env->
next
;

24 
i
++;

26 return (
i
);

27 
	}
}

29 static void 
	$free_env_var
(
t_env
 *
curr
)

31 
	`free
(
curr
->
var_name
);

32 if (
curr
->
var_value
)

33 
	`free
(
curr
->
var_value
);

34 
	`free
(
curr
);

35 
	}
}

37 static void 
delete_env_helper
(
t_env
 **
head
, t_env *
curr
, \

38 
t_env
 *
prev
, int 
i
)

40 int 
	gsize
;

42 
	gsize
 = 
env_list_size
(
head
);

43 if (
	gi
 == 0 && 
size
 == 1)

45 
free_env_var
(
curr
);

46 *
	ghead
 = 
NULL
;

49 else if (
	gi
 == 0 && 
size
 > 1)

51 *
head
 = 
curr
->
next
;

52 
	gprev
 = *
head
;

54 else if (
	gi
 == 
size
 - 1)

55 
prev
->
next
 = 
NULL
;

57 
	gprev
->
	gnext
 = 
curr
->
next
;

58 
free_env_var
(
curr
);

62 static void 
	$delete_env_var
(
t_env
 **
head
, char *
s
)

64 int 
i
;

65 
t_env
 *
curr
;

66 
t_env
 *
prev
;

68 
i
 = 0;

69 
curr
 = *
head
;

70 
prev
 = 
NULL
;

71 while (
curr
 && 
	`ft_strncmp
(
s
, curr->
var_name
, 
	`ft_strlen
(s)) != 0)

73 
prev
 = 
curr
;

74 
curr
 = curr->
next
;

75 
i
++;

77 if (!
curr
)

79 if (
	`ft_strncmp
(
s
, 
curr
->
var_name
, 
	`ft_strlen
(s)) == 0)

80 
	`delete_env_helper
(
head
, 
curr
, 
prev
, 
i
);

81 
g_shell
->
exit_status
 = 0;

82 
	}
}

84 void 
	$_unset
(
t_cmd
 *
cmd
)

86 int 
i
;

87 int 
res
;

88 int 
save
;

90 
i
 = 1;

91 
res
 = 0;

92 
save
 = 1;

93 while (
cmd
->cmd[
i
])

95 
res
 = 
	`check_if_valid_identifier
(
cmd
->cmd[
i
], "unset");

96 if (
res
)

97 
	`delete_env_var
(&
g_shell
->
env
, 
cmd
->cmd[
i
]);

98 else if (!
res
)

99 
save
 = 
res
;

100 
i
++;

102 if (!
save
)

103 
g_shell
->
exit_status
 = 1;

104 
	}
}

	@command_struct/free_cmd.c

12 #include 
	~"minishell.h
"

14 void 
	$free_tab2d
(char **
s
)

16 int 
i
;

18 if (!
s
 || !*s)

20 
i
 = 0;

21 while (
s
[
i
])

23 
	`free
 (
s
[
i
]);

24 
i
++;

26 
	`free
 (
s
);

27 
	}
}

29 void 
	$free_cmd
(
t_cmd
 **
head
)

31 
t_cmd
 *
ptr
;

32 
t_cmd
 *
tmp
;

34 if (!
head
 || !*head)

36 
ptr
 = *
head
;

37 while (
ptr
)

39 
tmp
 = 
ptr
;

40 
ptr
 = ptr->
next
;

41 
	`free_tab2d
(
tmp
->
cmd
);

42 
	`free_tab2d
(
tmp
->
redir
);

43 
tmp
->
cmd
 = 
NULL
;

44 
tmp
->
redir
 = 
NULL
;

45 
	`free
(
tmp
);

47 *
head
 = 
NULL
;

48 
	}
}

	@command_struct/init_cmd.c

12 #include 
	~"minishell.h
"

14 static void 
	$cmd_backadd
(
t_cmd
 **
head
, t_cmd *
new
)

16 
t_cmd
 *
ptr
;

18 if (!
head
 || !
new
)

20 if (!*
head
)

22 *
head
 = 
new
;

25 
ptr
 = *
head
;

26 while (
ptr
)

28 if (!
ptr
->
next
)

30 
ptr
 = ptr->
next
;

32 
ptr
->
next
 = 
new
;

33 
	}
}

35 static void 
	$init_fds
(
t_cmd
 *
cmd
)

37 
cmd
->
ffd_in
 = -1;

38 
cmd
->
ffd_out
 = -1;

39 
cmd
->
save_fdout
 = -1;

40 
cmd
->
save_fdin
 = -1;

41 
	}
}

56 static 
t_cmd
 *
	$init_cmd
(
t_token
 **
token
)

58 
t_cmd
 *
cmd
;

59 int 
res
;

61 
res
 = 0;

62 
cmd
 = 
	`ft_calloc
(1, sizeof(
t_cmd
));

63 if (!
cmd
)

65 
	`malloc_error_print_message
("ft_calloc failed");

66 return (
NULL
);

68 
cmd
->
next
 = 
NULL
;

69 
res
 = 
	`create_cmd
(
token
, 
cmd
);

70 if (!
res
)

72 
	`free_cmd
(&
cmd
);

73 return (
NULL
);

75 
res
 = 
	`create_redir
(
token
, 
cmd
);

76 if (!
res
)

78 
	`free_cmd
(&
cmd
);

79 return (
NULL
);

81 
	`init_fds
(
cmd
);

82 return (
cmd
);

83 
	}
}

85 static void 
	$create_cmd_linked_list
(
t_token
 **
token
, 
t_cmd
 *
head
)

87 
t_cmd
 *
new
;

88 
t_token
 *
ptr
;

90 
ptr
 = *
token
;

91 
new
 = 
NULL
;

92 while (
ptr
)

94 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

95 
ptr
 = ptr->
next
;

96 if (!
ptr
)

98 
ptr
 = ptr->
next
;

99 
new
 = 
	`init_cmd
(&
ptr
);

100 if (!
new
)

102 
	`free_cmd
(&
head
);

105 
	`cmd_backadd
(&
head
, 
new
);

107 
	}
}

126 
t_cmd
 *
	$cmd_linked_list
(
t_token
 **
token
)

128 
t_cmd
 *
head
;

129 
t_token
 *
ptr
;

131 if (!
token
 || !*token)

132 return (
NULL
);

133 
ptr
 = *
token
;

134 
head
 = 
NULL
;

135 
head
 = 
	`init_cmd
(&
ptr
);

136 if (!
head
)

137 return (
NULL
);

138 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

139 
ptr
 = ptr->
next
;

140 
	`create_cmd_linked_list
(&
ptr
, 
head
);

141 
	`free_token
(
token
);

142 if (!
head
)

143 return (
NULL
);

144 return (
head
);

145 
	}
}

	@command_struct/init_cmd_cmd.c

12 #include 
	~"minishell.h
"

14 static int 
	$copy_cmd_helper
(
t_token
 *
ptr
, 
t_cmd
 *
cmd
, int 
i
)

16 
cmd
->cmd[
i
] = 
	`ft_strdup
(
ptr
->
content
);

17 if (!
cmd
->cmd[
i
])

19 
	`malloc_error_print_message
("ft_strdup failed");

23 
	}
}

46 static int 
	$copy_cmd
(
t_token
 **
token
, 
t_cmd
 *
cmd
)

48 
t_token
 *
ptr
;

49 int 
i
;

51 
ptr
 = *
token
;

52 
i
 = 0;

53 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

55 if (
ptr
->
id
 == 
L_CHEVRON
 || ptr->id == 
R_CHEVRON
 || \

56 
ptr
->
id
 == 
APPEND
 || ptr->id == 
HERE_DOC
)

57 
ptr
 = ptr->
next
->next;

60 if (!
	`copy_cmd_helper
(
ptr
, 
cmd
, 
i
))

62 
ptr
 = ptr->
next
;

63 
i
++;

66 
cmd
->cmd[
i
] = 
NULL
;

68 
	}
}

70 static int 
	$get_cmd_size
(
t_token
 **
token
)

72 
t_token
 *
ptr
;

73 int 
i
;

75 
i
 = 0;

76 
ptr
 = *
token
;

77 if (!
token
 || !*token)

79 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

81 if (
ptr
->
id
 == 
L_CHEVRON
 || ptr->id == 
R_CHEVRON
 || \

82 
ptr
->
id
 == 
APPEND
 || ptr->id == 
HERE_DOC
)

84 
ptr
 = ptr->
next
->next;

88 
i
++;

89 
ptr
 = ptr->
next
;

92 return (
i
);

93 
	}
}

112 int 
	$create_cmd
(
t_token
 **
token
, 
t_cmd
 *
cmd
)

114 int 
i
;

115 int 
res
;

117 
i
 = 
	`get_cmd_size
(
token
);

118 if (
i
 == 0)

120 
cmd
->cmd = 
	`malloc
(sizeof(char *) * (
i
 + 1));

121 if (!
cmd
->cmd)

123 
	`malloc_error_print_message
(
	`strerror
(
errno
));

126 
res
 = 
	`copy_cmd
(
token
, 
cmd
);

127 if (!
res
)

130 
	}
}

	@command_struct/init_cmd_redir.c

12 #include 
	~"minishell.h
"

14 static int 
	$get_redir_size
(
t_token
 *
ptr
)

16 int 
i
;

18 
i
 = 0;

19 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

21 if (
ptr
->
id
 == 
L_CHEVRON
 || ptr->id == 
R_CHEVRON
 || \

22 
ptr
->
id
 == 
APPEND
 || ptr->id == 
HERE_DOC
)

23 
i
 = i + 2;

24 
ptr
 = ptr->
next
;

26 return (
i
);

27 
	}
}

29 static int 
	$copy_redir_helper
(
t_token
 *
ptr
, 
t_cmd
 *
cmd
, int 
i
)

31 
cmd
->
redir
[
i
] = 
	`ft_strdup
(
ptr
->
content
);

32 if (!
cmd
->
redir
[
i
])

34 
	`malloc_error_print_message
("ft_strdup failed");

37 
i
++;

38 
ptr
 = ptr->
next
;

39 
cmd
->
redir
[
i
] = 
	`ft_strdup
(
ptr
->
content
);

40 if (!
cmd
->
redir
[
i
])

42 
	`malloc_error_print_message
("ft_strdup failed");

45 return (
i
);

46 
	}
}

68 static int 
	$copy_redir
(
t_token
 **
token
, 
t_cmd
 *
cmd
)

70 
t_token
 *
ptr
;

71 int 
i
;

73 
ptr
 = *
token
;

74 
i
 = 0;

75 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

77 if (
ptr
->
id
 == 
L_CHEVRON
 || ptr->id == 
R_CHEVRON
 || \

78 
ptr
->
id
 == 
APPEND
 || ptr->id == 
HERE_DOC
)

80 
i
 = 
	`copy_redir_helper
(
ptr
, 
cmd
, i);

81 if (!
i
)

83 
i
++;

85 
ptr
 = ptr->
next
;

88 
	}
}

113 int 
	$create_redir
(
t_token
 **
token
, 
t_cmd
 *
cmd
)

115 
t_token
 *
ptr
;

116 int 
i
;

117 int 
res
;

119 
res
 = 0;

120 
ptr
 = *
token
;

121 
i
 = 
	`get_redir_size
(
ptr
);

122 if (
i
 == 0)

124 
cmd
->
redir
 = 
	`ft_calloc
(
i
 + 1, sizeof(char *));

125 if (!
cmd
->
redir
)

127 
	`malloc_error_print_message
("ft_calloc failed");

130 
res
 = 
	`copy_redir
(
token
, 
cmd
);

131 if (!
res
)

133 
	`free_tab2d
(
cmd
->
redir
);

137 
	}
}

	@environnement/envp_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_env
(
t_env
 **
head
)

16 
t_env
 *
ptr
;

17 
t_env
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 if (
tmp
->
var_name
)

27 
	`free
(
tmp
->
var_name
);

28 if (
tmp
->
var_value
)

29 
	`free
(
tmp
->
var_value
);

30 
	`free
(
tmp
);

32 *
head
 = 
NULL
;

33 
	}
}

43 int 
	$new_env_helper
(char *
envp
, int 
end
)

45 while (
envp
[
end
] != '=' && envp[end])

46 
end
++;

47 return (
end
);

48 
	}
}

50 
t_env
 *
	$new_env
(char *
envp
)

52 
t_env
 *
env
;

53 int 
end
;

54 int 
start
;

56 if (!
envp
)

57 return (
NULL
);

58 
start
 = 0;

59 
end
 = 0;

60 
env
 = 
	`ft_calloc
(1, sizeof(
t_env
));

61 if (!
env
)

62 return (
	`malloc_error_print_message
("ft_calloc failed"), 
NULL
);

63 
end
 = 
	`new_env_helper
(
envp
, end);

64 
env
->
var_name
 = 
	`ft_substr
(
envp
, 0, 
end
);

65 if (!
env
->
var_name
)

66 return (
NULL
);

67 if (
envp
[
end
++] == '\0')

68 return (
env
);

69 
start
 = 
end
;

70 while (
envp
[
end
] != '\0')

71 
end
++;

72 
env
->
var_value
 = 
	`ft_substr
(
envp
, 
start
, 
end
 - start);

73 if (!
env
->
var_value
)

74 return (
	`malloc_error_print_message
("ft stubstr failed"), 
NULL
);

75 
env
->
next
 = 
NULL
;

76 return (
env
);

77 
	}
}

82 int 
	$link_env
(
t_env
 **
head
, t_env *
last
)

84 
t_env
 *
ptr
;

86 if (!
last
)

88 
ptr
 = *
head
;

89 while (
ptr
)

91 if (!
ptr
->
next
)

93 
ptr
 = ptr->
next
;

95 
ptr
->
next
 = 
last
;

97 
	}
}

106 
t_env
 *
	$get_envp
(char **
envp
)

108 
t_env
 **
head
;

109 
t_env
 *
env
;

110 int 
i
;

112 
i
 = 0;

113 
head
 = 
NULL
;

114 if (!
envp
)

115 return (
NULL
);

116 
env
 = 
	`new_env
(
envp
[
i
]);

117 if (!
env
)

118 return (
NULL
);

119 
head
 = &
env
;

120 
i
++;

121 while (
envp
[
i
])

123 if (
	`link_env
(
head
, 
	`new_env
(
envp
[
i
])) < 0)

124 return (
	`free_env
(
head
), 
NULL
);

125 
i
++;

127 return (*
head
);

128 
	}
}

	@environnement/get_env.c

12 #include 
	~"minishell.h
"

14 char *
	$get_env_var_value
(char *
var_name
)

16 
t_env
 *
env
;

18 
env
 = 
g_shell
->env;

19 while (
env
 != 
NULL
)

21 if (
	`ft_strncmp
(
env
->
var_name
, var_name, 
	`ft_strlen
(var_name)) == 0)

22 return (
env
->
var_value
);

23 
env
 = env->
next
;

25 return (
NULL
);

26 
	}
}

	@execution/copy_env_tab.c

12 #include 
	~"minishell.h
"

14 int 
	$column_size
(
t_env
 **
head
)

16 
t_env
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

29 char *
	$name_plus_value
(char *
name
, char *
value
)

31 char *
joined
;

32 int 
len_name
;

33 int 
len_value
;

34 int 
i
;

35 int 
j
;

37 
i
 = 0;

38 
j
 = 0;

39 
len_name
 = 
	`ft_strlen
(
name
);

40 if (
value
)

41 
len_value
 = 
	`ft_strlen
(
value
);

43 
len_value
 = 0;

44 
joined
 = 
	`malloc
(sizeof(char) * (
len_name
 + 
len_value
 + 2));

45 if (!
joined
)

47 
	`malloc_error_print_message
(
	`strerror
(
errno
));

48 return (
NULL
);

50 while (
i
 < 
len_name
)

51 
joined
[
i
++] = 
name
[
j
++];

52 
joined
[
i
] = '=';

53 
j
 = 0;

54 
i
++;

55 while (
j
 < 
len_value
)

56 
joined
[
i
++] = 
value
[
j
++];

57 
joined
[
i
] = '\0';

58 return (
joined
);

59 
	}
}

61 int 
	$copy_env_tab
(void)

63 int 
column
;

64 int 
i
;

65 
t_env
 *
env
;

67 
env
 = 
g_shell
->env;

68 
i
 = 0;

69 
column
 = 
	`column_size
(&
env
);

70 if (
column
 == 0)

72 
g_shell
->
save_env
 = 
	`malloc
(sizeof(char *) * (
column
 + 1));

73 if (!
g_shell
->
save_env
)

75 
	`malloc_error_print_message
(
	`strerror
(
errno
));

78 while (
env
)

80 
g_shell
->
save_env
[
i
] = 
	`name_plus_value
(
env
->
var_name
, env->
var_value
);

81 if (!
g_shell
->
save_env
[
i
])

83 
i
++;

84 
env
 = env->
next
;

86 
g_shell
->
save_env
[
i
] = 
NULL
;

88 
	}
}

	@execution/exec_bin.c

12 #include 
	~"minishell.h
"

13 static int 
	$check_access
(
t_cmd
 *
cmd
)

15 int 
res
;

17 if (!
cmd
->
path
)

19 
	`printf
("access error: \n");

20 
	`ft_dprintf
(2, "minishell: %s: command not found\n", 
cmd
->cmd[0]);

21 
g_shell
->
exit_status
 = 127;

25 
res
 = 
	`access
(
cmd
->
path
, 
F_OK
 & 
X_OK
);

26 if (
res
)

28 
	`printf
("access error: \n");

29 
	`ft_dprintf
(2, "minishell: %s\n", 
	`strerror
(
errno
));

30 
g_shell
->
exit_status
 = 127;

34 
	}
}

36 static void 
	$check_execve
(
t_cmd
 *
cmd
)

38 int 
res
;

40 if (!
cmd
->cmd)

42 
	`printf
("execve error: \n");

43 
	`ft_dprintf
(2, "minishell: %s: is a directory\n", 
cmd
->
path
);

44 
g_shell
->
exit_status
 = 126;

47 
res
 = 
	`execve
(
cmd
->
path
, cmd->cmd, 
g_shell
->
save_env
);

48 if (
res
 < 0)

50 
	`printf
("execve error: \n");

51 if (
errno
 == 
ENOEXEC
)

53 
	`ft_dprintf
(2, "minishell: %s: Permission denied\n", 
cmd
->
path
);

54 
g_shell
->
exit_status
 = 126;

57 
	`ft_dprintf
(2, "minishell: %s: %s\n", 
cmd
->
path
, 
	`strerror
(
errno
));

58 if (
errno
 == 
EACCES
)

60 
g_shell
->
exit_status
 = 126;

63 
g_shell
->
exit_status
 = 127;

66 
g_shell
->
exit_status
 = 0;

67 
	}
}

69 void 
	$execute_bin
(
t_cmd
 *
cmd
)

71 int 
res
 = 0;

73 if (!
cmd
 || !cmd->cmd)

75 if (!
	`get_path
(
cmd
))

80 
res
 = 
	`check_access
(
cmd
);

81 if (
res
)

84 
	`check_execve
(
cmd
);

86 if (
cmd
->
path
)

87 
	`free
(
cmd
->
path
);

88 if (
cmd
->cmd)

89 
	`free_tab2d
(
cmd
->cmd);

91 
	}
}

	@execution/exec_builtins.c

12 #include 
	~"minishell.h
"

14 int 
	$cmd_is_builtin
(char *
s
)

16 if (
s
)

18 if (
	`ft_strncmp
(
s
, "echo", 5) == 0)

20 else if (
	`ft_strncmp
(
s
, "cd", 3) == 0)

22 else if (
	`ft_strncmp
(
s
, "pwd", 4) == 0)

24 else if (
	`ft_strncmp
(
s
, "export", 7) == 0)

26 else if (
	`ft_strncmp
(
s
, "unset", 6) == 0)

28 else if (
	`ft_strncmp
(
s
, "env", 4) == 0)

30 else if (
	`ft_strncmp
(
s
, "exit", 5) == 0)

34 
	}
}

36 void 
	$execute_builtin
(
t_cmd
 *
cmd
, t_cmd **
head
)

38 if (
	`ft_strncmp
(
cmd
->cmd[0], "exit", 6) == 0)

39 
	`ft_exit
(&
cmd
);

40 else if (
	`ft_strncmp
(
cmd
->cmd[0], "pwd", 4) == 0)

41 
	`_pwd
();

42 else if (
	`ft_strncmp
(
cmd
->cmd[0], "echo", 5) == 0)

43 
	`_echo
(
cmd
);

44 else if (
	`ft_strncmp
(
cmd
->cmd[0], "env", 4) == 0)

45 
	`_env
(
cmd
, 
g_shell
->
env
);

46 else if (
	`ft_strncmp
(
cmd
->cmd[0], "cd", 3) == 0)

47 
	`_cd
(
cmd
, 
head
);

48 else if (
	`ft_strncmp
(
cmd
->cmd[0], "export", 7) == 0)

49 
	`_export
(
cmd
, 
head
);

50 else if (
	`ft_strncmp
(
cmd
->cmd[0], "unset", 6) == 0)

51 
	`_unset
(
cmd
);

53 
	}
}

	@execution/exec_one_cmd.c

12 #include 
	~"minishell.h
"

14 void 
	$print_signal_message
(int 
sig_code
)

16 if (
sig_code
 == 
SIGTERM
)

18 
g_shell
->
terminated
++;

19 
	`ft_printf
("[%d]\t Terminated: 15\n", 
g_shell
->
terminated
);

21 else if (
sig_code
 == 
SIGQUIT
)

23 
	`printf
(" main QUIT: 3\n");

25 
	}
}

27 static void 
	$execute_one_bin
(
t_cmd
 *
cmd
)

29 int 
sig_code
;

30 
sig_code
 = 0;

31 
cmd
->
pid
 = 
	`fork
();

32 
	`child_signal_handler
(
g_shell
->
pid
);

33 if (
cmd
->
pid
 < 0)

34 return (
	`perror
("Fork: "));

35 if (
cmd
->
pid
 == 0)

37 
	`execute_bin
(
cmd
);

38 
cmd
->
status
 = 
g_shell
->
exit_status
;

39 
	`exit
(
g_shell
->
exit_status
);

43 
g_shell
->
pid
 = 
cmd
->pid;

44 
	`waitpid
(
cmd
->
pid
, &cmd->
status
, 0);

45 if (
	`WIFSIGNALED
(
cmd
->
status
))

47 
	`print_signal_message
(
	`WTERMSIG
(
cmd
->
status
));

48 
g_shell
->
exit_status
 = 
	`WTERMSIG
(
cmd
->
status
) + 128;

50 else if (
	`WIFEXITED
(
cmd
->
status
))

52 if (
g_shell
->
exit_status
 == 146)

53 
	`ft_printf
("\t\t\t%s\n", 
cmd
->cmd[0]);

56 
	}
}

58 void 
	$one_cmd
(
t_cmd
 *
cmd
, t_cmd **
head
)

60 int 
res
;

62 
res
 = 
	`make_redirections
(
cmd
);

63 if (
res
 == 
ERROR_EXIT
)

65 if (
	`cmd_is_builtin
(
cmd
->cmd[0]))

66 
	`execute_builtin
(
cmd
, 
head
);

68 
	`execute_one_bin
(
cmd
);

69 
	`restaure_fds
(
cmd
);

70 
	}
}

	@execution/execution.c

12 #include 
	~"minishell.h
"

14 static int 
	$count_nb_cmds
(
t_cmd
 **
head
)

16 
t_cmd
 *
cmd
;

17 int 
i
;

19 
i
 = 0;

20 
cmd
 = *
head
;

21 while (
cmd
)

23 
i
++;

24 
cmd
 = cmd->
next
;

26 return (
i
);

27 
	}
}

29 static int 
	$reset_env_tab
(void)

31 if (
g_shell
->
save_env
)

33 
	`free_tab2d
(
g_shell
->
save_env
);

34 
g_shell
->
save_env
 = 
NULL
;

36 if (!
	`copy_env_tab
())

39 
	}
}

41 void 
	$execution
(
t_cmd
 **
head
)

43 int 
nb_cmds
;

45 if (!
head
 || !*head)

47 
nb_cmds
 = 
	`count_nb_cmds
(
head
);

48 if (!
	`reset_env_tab
())

50 if (
nb_cmds
 == 1)

51 
	`one_cmd
(*
head
, head);

53 
	`pipex
(
head
, 
nb_cmds
);

54 
	}
}

	@execution/get_path.c

12 #include 
	~"minishell.h
"

14 static int 
	$is_dir
(char *
path
, 
t_cmd
 *
cmd
)

16 struct 
stat
 
buf
;

18 if (
	`stat
(
path
, &
buf
) == 0)

20 if(
	`S_ISDIR
(
buf
.
st_mode
))

22 
	`free_tab2d
(
cmd
->cmd);

23 
cmd
->cmd = 
NULL
;

28 
	}
}

30 static int 
	$extract_cmd_path
(char *
path
, 
t_cmd
 *
cmd
)

32 int 
start
;

33 int 
end
;

35 
start
 = 0;

36 
end
 = 0;

37 if (
	`is_dir
(
path
, 
cmd
))

39 while (
path
[
end
])

40 
end
++;

41 
start
 = 
end
--;

42 while (
path
[
start
] != '/')

43 
start
--;

44 
	`free
(
cmd
->cmd[0]);

45 
cmd
->cmd[0] = 
NULL
;

46 
cmd
->cmd[0] = 
	`ft_substr
(
path
, 
start
 + 1, 
end
 - start);

47 if (!
cmd
->cmd[0])

49 
	`malloc_error_print_message
("ft_substr failed");

53 
	}
}

55 int 
	$get_path
(
t_cmd
 *
cmd
)

57 if (
	`ft_strchr
(
cmd
->cmd[0], '/'))

59 
cmd
->
path
 = 
	`ft_strdup
(cmd->cmd[0]);

60 if (!
cmd
->
path
)

62 
	`malloc_error_print_message
("ft_strdup failed");

65 if (!
	`extract_cmd_path
(
cmd
->
path
, cmd))

69 if (!
	`search_path
(
cmd
, 
g_shell
->
save_env
))

73 
	}
}

	@execution/pipex.c

12 #include 
	~"minishell.h
"

15 void 
	$ft_exe
(int 
i
, int 
save_fdin
, 
t_cmd
 *
cmd
, t_cmd **
head
)

17 int 
res
;

19 if (
i
 != 0)

21 
	`dup2
(
save_fdin
, 
STDIN_FILENO
);

22 
	`close
(
save_fdin
);

24 
res
 = 
	`make_redirections
(
cmd
);

25 if (
res
 == 
ERROR_EXIT
)

27 if (!
cmd
->cmd)

29 if (
	`cmd_is_builtin
(
cmd
->cmd[0]))

30 
	`execute_builtin
(
cmd
, 
head
);

32 
	`execute_bin
(
cmd
);

33 
	`restaure_fds
(
cmd
);

35 
	}
}

38 void 
	$pipex
(
t_cmd
 **
head
, int 
nb_cmds
)

40 (void)
nb_cmds
;

41 int 
fd_pipe
[2];

42 int 
save_fdin
;

43 
t_cmd
 *
cmd
;

44 int 
i
;

46 
i
 = 0;

47 if (!
head
 || !*head)

49 
cmd
 = *
head
;

50 while (
cmd
)

52 
	`pipe
(
fd_pipe
);

53 
cmd
->
pid
= 
	`fork
();

54 
	`child_signal_handler
(
cmd
->
pid
);

55 if (
cmd
->
pid
 == 0)

57 if (
cmd
->
next
 != 
NULL
)

58 
	`dup2
(
fd_pipe
[1], 
STDOUT_FILENO
);

59 
	`close
(
fd_pipe
[0]);

60 
	`close
(
fd_pipe
[1]);

61 
	`ft_exe
(
i
, 
save_fdin
, 
cmd
, 
head
);

62 
	`exit
(
g_shell
->
exit_status
);

66 
	`close
(
fd_pipe
[1]);

67 
	`close
(
save_fdin
);

68 
save_fdin
 = 
fd_pipe
[0];

70 
cmd
 = cmd->
next
;

71 
i
++;

73 
cmd
 = *
head
;

74 while (
cmd
)

76 
	`waitpid
(
cmd
->
pid
, &cmd->
status
, 0);

78 if (
	`WIFEXITED
(
cmd
->
status
))

81 
g_shell
->
exit_status
 = 
cmd
->
status
 / 256;

83 
cmd
 = cmd->
next
;

85 
cmd
 = *
head
;

86 
	`close
(
save_fdin
);

87 
	}
}

	@execution/search_path_in_env_table.c

12 #include 
	~"minishell.h
"

14 static void 
	$copy_path
(int 
start
, int 
end
, char *
s
, 
t_cmd
 *
cmd
)

16 int 
i
;

18 
i
 = 0;

19 while (
start
 < 
end
)

21 
cmd
->
path
[
i
] = 
s
[
start
];

22 
i
++;

23 
start
++;

25 
cmd
->
path
[
i
] = '/';

26 
i
++;

27 
start
 = 0;

28 while (
cmd
->cmd[0][
start
])

30 
cmd
->
path
[
i
] = cmd->cmd[0][
start
];

31 
i
++;

32 
start
++;

34 
cmd
->
path
[
i
] = '\0';

35 
	}
}

37 static int 
	$check_access
(int 
start
, int 
end
, char *
s
, 
t_cmd
 *
cmd
)

39 int 
size
;

41 
size
 = 
end
 - 
start
 + 
	`ft_strlen
(
cmd
->cmd[0]) + 2;

42 
cmd
->
path
 = 
	`malloc
(sizeof(char) * 
size
);

43 if (!
cmd
->
path
)

45 
	`malloc_error_print_message
("ft_substr failed");

46 
g_shell
->
exit_status
 = 1;

47 return (
ERROR_EXIT
);

49 
	`copy_path
(
start
, 
end
, 
s
, 
cmd
);

50 if (
	`access
(
cmd
->
path
, 
F_OK
 & 
X_OK
) == 0)

52 
	`free
(
cmd
->
path
);

53 
cmd
->
path
 = 
NULL
;

55 
	}
}

57 static int 
	$check_each_path
(char *
s
, 
t_cmd
 *
cmd
)

59 int 
i
;

60 int 
start
;

61 int 
res
;

63 
i
 = 0;

64 
start
 = 0;

65 while (
s
[
i
])

67 if (
s
[
i
] == ':')

69 
res
 = 
	`check_access
(
start
, 
i
, 
s
, 
cmd
);

70 if (
res
 == 1)

72 else if (
res
 == 
ERROR_EXIT
)

74 
start
 = 
i
 + 1;

76 
i
++;

78 
res
 = 
	`check_access
(
start
, 
i
, 
s
, 
cmd
);

79 if (
res
 == 1 || res == 0)

82 
	}
}

84 int 
	$search_path
(
t_cmd
 *
cmd
, char **
env
)

86 int 
i
;

87 int 
res
;

89 
i
 = 0;

90 while (
env
[
i
] && 
	`ft_strncmp
("PATH=", env[i], 5) != 0)

91 
i
++;

92 if (!
env
[
i
])

94 
	`ft_dprintf
(2, "minishell: %s: No such file or directory\n", 
cmd
->cmd[0]);

95 
g_shell
->
exit_status
 = 127;

98 if (
cmd
->cmd[0][0] == 0)

100 
res
 = 
	`check_each_path
((
env
[
i
] + 5), 
cmd
);

101 return (
res
);

102 
	}
}

	@global_variable/init_global.c

12 #include 
	~"minishell.h
"

16 void 
	$free_shell
(void)

18 
	`free_env
(&
g_shell
->
env
);

19 if (
g_shell
->
save_env
)

20 
	`free_tab2d
(
g_shell
->
save_env
);

22 if (
g_shell
)

23 
	`free
(
g_shell
);

24 
	}
}

26 static int 
	$shell_no_env
(void)

28 
t_env
 *
env_no
;

29 
env_no
 = 
	`malloc
(sizeof(
t_env
));

30 if (!
env_no
)

32 
	`malloc_error_print_message
(
	`strerror
(
errno
));

35 
env_no
->
var_name
 = 
	`ft_strdup
("SHLVL");

36 
env_no
->
var_value
 = 
	`ft_strdup
("1");

37 
env_no
->
next
 = 
NULL
;

38 
g_shell
->
env
 = 
env_no
;

41 
	}
}

43 static int 
	$increment_shlvl
(void)

45 
t_env
 *
env
;

46 int 
i
;

48 
env
 = 
g_shell
->env;

49 while (
env
)

51 if (
	`ft_strncmp
(
env
->
var_name
, "SHLVL", 6) == 0)

53 if (!
	`is_numeric
(
env
->
var_value
))

55 
i
 = 
	`ft_atoi
(
env
->
var_value
) + 1;

56 
	`free
(
env
->
var_value
);

57 
env
->
var_value
 = 
NULL
;

58 
env
->
var_value
 = 
	`ft_itoa
(
i
);

59 if (!
env
->
var_value
)

61 
	`malloc_error_print_message
("ft_itoa failed");

66 
env
 = env->
next
;

69 
	}
}

71 int 
	$init_shell
(char **
envp
)

73 
g_shell
 = 
	`ft_calloc
(1, sizeof(
t_shell
));

74 if (!
g_shell
)

76 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

79 if (!*
envp
)

81 if (!
	`shell_no_env
())

86 
g_shell
->
env
 = 
	`get_envp
(
envp
);

87 if (!
g_shell
->
env
)

88 return (
	`free_shell
(), 0);

89 if (!
	`increment_shlvl
())

90 return (
	`free_shell
(), 0);

96 
	}
}

	@is_smth/is_dollar.c

12 #include 
	~"minishell.h
"

16 int 
	$is_dollar
(char 
c
)

18 if (
c
 == '$')

21 
	}
}

	@is_smth/is_numeric.c

12 #include 
	~"minishell.h
"

14 int 
	$is_numeric
(char *
s
)

16 int 
i
;

18 
i
 = 0;

19 while (
s
[
i
])

21 if (
	`ft_isdigit
(
s
[
i
]) == 0)

23 
i
++;

26 
	}
}

	@is_smth/is_operator.c

12 #include 
	~"minishell.h
"

16 int 
	$is_pipeline
(char 
c
)

18 if (
c
 == '|')

21 
	}
}

25 int 
	$is_lchevron
(char 
c
)

27 if (
c
 == '<')

30 
	}
}

32 int 
	$is_rchevron
(char 
c
)

34 if (
c
 == '>')

37 
	}
}

39 int 
	$is_chevron
(char 
c
)

41 if (
	`is_lchevron
(
c
) || 
	`is_rchevron
(c))

44 
	}
}

48 int 
	$is_operator
(char 
c
)

50 if (
	`is_pipeline
(
c
) || 
	`is_chevron
(c))

53 
	}
}

	@is_smth/is_question.c

12 #include 
	~"minishell.h
"

14 int 
	$is_question
(char 
c
)

16 if (
c
 == '?')

19 
	}
}

21 int 
	$is_punct
(char 
c
)

23 if ((
c
 >= 33 && c <= 47) || \

24 (
c
 >= 58 && c <= 64) || \

25 (
c
 >= 91 && c <= 94) || \

26 (
c
 == 96) || \

27 (
c
 >= 123 && c <= 126))

30 
	}
}

	@is_smth/is_quote.c

12 #include 
	~"minishell.h
"

16 int 
	$is_double_quote
(char 
c
)

18 if (
c
 == '\"')

21 
	}
}

23 int 
	$is_simple_quote
(char 
c
)

25 if (
c
 == '\'')

28 
	}
}

30 int 
	$is_quote
(char 
c
)

32 if (
	`is_double_quote
(
c
) || 
	`is_simple_quote
(c))

35 
	}
}

	@is_smth/is_token.c

12 #include 
	~"minishell.h
"

16 int 
	$is_metacharacter
(char 
c
)

18 if (
	`is_blank
(
c
) || 
	`is_newline
(c) || 
	`is_operator
(c))

21 
	}
}

25 int 
	$is_delimiter
(char 
c
)

27 if (
	`is_metacharacter
(
c
))

30 
	}
}

34 int 
	$is_word
(char 
c
)

36 if (!
	`is_delimiter
(
c
))

39 
	}
}

	@is_smth/is_white_space.c

12 #include 
	~"minishell.h
"

14 int 
	$is_blank
(char 
c
)

16 if (
c
 == ' ' || c == '\t')

19 
	}
}

21 int 
	$is_newline
(char 
c
)

23 if (
c
 == '\n')

26 
	}
}

28 int 
	$is_white_space
(char 
c
)

30 if (
	`is_blank
(
c
) || 
	`is_newline
(c))

33 
	}
}

	@libft/ft_printf/ft_count_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_int
(int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

	@libft/ft_printf/ft_count_unsigned_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_unsigned_int
(unsigned int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 else if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 return (
count
);

30 
	}
}

	@libft/ft_printf/ft_dprintf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 
fd
, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 
fd
, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 
fd
, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 
fd
, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 
fd
, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_dprintf
(int 
fd
, const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 
fd
, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 
fd
, &
count
);

50 
	`ft_format_specifier_fd
(
last
[
i
 + 1], 
ap
, &
count
, 
fd
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@libft/ft_printf/ft_printf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier
(char 
format
, 
va_list
 
ap
, int *
count
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 1, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 1, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 1, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 1, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 1, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 1, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 1, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_printf
(const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 1, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 1, &
count
);

50 
	`ft_format_specifier
(
last
[
i
 + 1], 
ap
, &
count
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@libft/ft_printf/ft_printf_address.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
);

16 void 
	$ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
)

18 
	`ft_printf_str
("0x", 
fd
, 
count
);

19 
	`ft_put_uintptr_fd
(
n
, 
fd
, 
count
);

20 
	}
}

22 void 
	$ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
)

24 if (
n
 > 15)

26 
	`ft_put_uintptr_fd
(
n
 / 16, 
fd
, 
count
);

27 
	`ft_put_uintptr_fd
(
n
 % 16, 
fd
, 
count
);

29 if (
n
 < 10)

30 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

31 else if (
n
 > 9 && n < 16)

32 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

33 
	}
}

	@libft/ft_printf/ft_printf_char.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_char
(char 
c
, int 
fd
, int *
count
)

16 
	`ft_putchar_fd
(
c
, 
fd
);

17 *
count
 += 1;

18 
	}
}

	@libft/ft_printf/ft_printf_hexa.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
)

16 if (
n
 > 15)

18 
	`ft_printf_hexa
(
n
 / 16, 
fd
, 
count
, 
c
);

19 
	`ft_printf_hexa
(
n
 % 16, 
fd
, 
count
, 
c
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

25 if (
c
 == 'x')

26 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

27 else if (
c
 == 'X')

28 
	`ft_printf_char
(
n
 + 55, 
fd
, 
count
);

30 
	}
}

	@libft/ft_printf/ft_printf_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_int
(int 
n
, int 
fd
, int *
count
)

16 
	`ft_putnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_int
(
n
);

18 
	}
}

	@libft/ft_printf/ft_printf_str.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_str
(char *
s
, int 
fd
, int *
count
)

16 int 
i
;

18 
i
 = 0;

19 if (
s
 != 
NULL
)

21 while (
s
[
i
] != '\0')

22 
i
++;

23 
	`ft_putstr_fd
(
s
, 
fd
);

27 
	`ft_putstr_fd
("(null)", 1);

28 
i
 = 6;

30 *
count
 += 
i
;

31 
	}
}

	@libft/ft_printf/ft_printf_unsint.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
)

16 
	`ft_put_unsnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_unsigned_int
(
n
);

18 
	}
}

	@libft/ft_printf/ft_put_hexanbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_hexanbr_fd
(unsigned int 
n
, int 
fd
, int *
count
)

16 if (
n
 > 15)

18 
	`ft_put_hexanbr_fd
(
n
 / 16, 
fd
, 
count
);

19 
	`ft_put_hexanbr_fd
(
n
 % 16, 
fd
, 
count
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

24 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

25 
	}
}

	@libft/ft_printf/ft_put_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_put_int
(int 
n
, int 
fd
, int *
count
)

16 int 
a
;

18 
a
 = *
count
;

19 
	`ft_putnbr_fd
(
n
, 
fd
);

20 
a
 += 
	`ft_count_int
(
n
);

21 return (
a
);

22 
	}
}

	@libft/ft_printf/ft_put_unsnbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
)

16 if (
n
 > 9)

18 
	`ft_put_unsnbr_fd
(
n
 / 10, 
fd
);

19 
	`ft_put_unsnbr_fd
((
n
 % 10), 
fd
);

22 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

23 
	}
}

	@libft/get_next_line/get_next_line.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$create_nextline
(char *
result
, char *
line
)

16 int 
start
;

17 int 
size
;

18 char *
nextline
;

20 
start
 = 
	`ft_strlen_int
(
result
);

21 
size
 = 
	`ft_strlen_int
(
line
);

22 
size
 = size - 
start
;

23 if (
size
 == 0)

25 
	`free
 (
line
);

26 return (
NULL
);

28 
nextline
 = 
	`malloc
((
size
 + 1) * sizeof(char));

29 if (!
nextline
)

30 return (
NULL
);

31 
size
 = 0;

32 while (
line
[
start
] != '\0')

34 
nextline
[
size
] = 
line
[
start
];

35 
size
++;

36 
start
++;

38 
nextline
[
size
] = '\0';

39 
	`free
(
line
);

40 return (
nextline
);

41 
	}
}

55 char *
	$create_result
(char *
line
)

57 int 
i
;

58 char *
result
;

60 
i
 = 
	`there_is_n
(
line
);

61 if (
i
 == -1 && *
line
)

62 
i
 = 
	`ft_strlen_int
(
line
);

63 else if (
i
 == -1 && !*
line
)

64 return (
NULL
);

65 
result
 = 
	`malloc
((
i
 + 1) * sizeof(char));

66 if (!
result
)

67 return (
NULL
);

68 
i
 = 0;

69 while (
line
[
i
] != '\0')

71 
result
[
i
] = 
line
[i];

72 if (
line
[
i
] == '\n')

74 
i
++;

77 
i
++;

79 
result
[
i
] = '\0';

80 return (
result
);

81 
	}
}

94 char *
	$read_fd
(char *
line
, int 
fd
, int *
error
)

96 char *
buffer
;

97 int 
ret
;

99 
ret
 = 1;

100 
	`prepare_forstash
(&
line
, &
buffer
);

101 while (
ret
 > 0 && 
	`there_is_n
(
buffer
) == -1 && there_is_n(
line
) == -1)

103 
ret
 = (int)
	`read
(
fd
, 
buffer
, 
BUFFER_SIZE
);

104 if (
ret
 < 0)

106 
	`free
(
buffer
);

107 *
error
 = -1;

108 return (
NULL
);

110 if (
ret
 == 0)

112 *
error
 = 0;

115 
buffer
[
ret
] = '\0';

116 
line
 = 
	`ft_join
(line, 
buffer
);

118 
	`free
(
buffer
);

119 return (
line
);

120 
	}
}

130 int 
	$check_errors
(int 
fd
, char **
line
)

132 if (
fd
 < 0 || 
BUFFER_SIZE
 <= 0 || 
	`read
(fd, 0, 0) < 0)

134 
	`free
(*
line
);

135 *
line
 = 0;

139 
	}
}

150 char *
	$get_next_line
(int 
fd
)

152 static char *
line
;

153 char *
result
;

154 int 
error
;

156 
error
 = 
	`check_errors
(
fd
, &
line
);

157 if (
error
 == 0)

158 return (
NULL
);

159 
line
 = 
	`read_fd
(line, 
fd
, &
error
);

160 if (
error
 == -1 || (error == 0 && !*
line
))

162 
	`free
(
line
);

163 
line
 = 0;

164 return (
NULL
);

166 if (!
line
)

167 return (
NULL
);

168 
result
 = 
	`create_result
(
line
);

169 if (!
result
)

171 
line
 = 0;

172 
	`free
(
line
);

174 
line
 = 
	`create_nextline
(
result
, line);

175 return (
result
);

176 
	}
}

	@libft/get_next_line/get_next_line_bonus.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$get_next_line_maxopen
(int 
fd
)

16 static char *
line
[
OPEN_MAX
];

17 char *
result
;

18 int 
error
;

20 
error
 = 
	`check_errors
(
fd
, &
line
[fd]);

21 if (
error
 == 0)

22 return (
NULL
);

23 
line
[
fd
] = 
	`read_fd
(line[fd], fd, &
error
);

24 if (
error
 == -1 || (error == 0 && !*
line
[
fd
]))

26 
	`free
(
line
[
fd
]);

27 
line
[
fd
] = 0;

28 return (
NULL
);

30 if (!
line
[
fd
])

31 return (
NULL
);

32 
result
 = 
	`create_result
(
line
[
fd
]);

33 if (!
result
)

35 
line
[
fd
] = 0;

36 
	`free
(
line
[
fd
]);

38 
line
[
fd
] = 
	`create_nextline
(
result
, line[fd]);

39 return (
result
);

40 
	}
}

	@libft/get_next_line/get_next_line_utils.c

12 #include 
	~"../includes/get_next_line.h
"

14 void 
	$prepare_forstash
(char **
line
, char **
buffer
)

16 *
buffer
 = 
	`ft_calloc_count
(
BUFFER_SIZE
);

17 if (*
line
 == 
NULL
)

18 *
line
 = 
	`ft_calloc_count
(0);

19 
	}
}

21 char *
	$ft_join
(char *
line
, char *
buffer
)

23 int 
i
;

24 int 
j
;

25 char *
stash
;

27 if (!
line
 || !
buffer
)

28 return (
NULL
);

29 
i
 = 
	`ft_strlen_int
(
line
);

30 
j
 = 
	`ft_strlen_int
(
buffer
);

31 
stash
 = 
	`malloc
((
i
 + 
j
 + 1) * sizeof(char));

32 if (!
stash
)

33 return (
NULL
);

34 
i
 = 0;

35 
j
 = 0;

36 while (
line
[
i
] != '\0')

38 
stash
[
i
] = 
line
[i];

39 
i
++;

41 while (
buffer
[
j
] != '\0')

42 
stash
[
i
++] = 
buffer
[
j
++];

43 
stash
[
i
] = '\0';

44 
	`free
(
line
);

45 return (
stash
);

46 
	}
}

48 char *
	$ft_calloc_count
(int 
count
)

50 char *
string
;

51 int 
i
;

53 
i
 = 0;

54 
string
 = 
	`malloc
((
count
 + 1) * sizeof(char));

55 if (!
string
)

56 return (
NULL
);

57 while (
i
 <= 
count
)

59 
string
[
i
] = '\0';

60 
i
++;

62 return (
string
);

63 
	}
}

65 int 
	$ft_strlen_int
(const char *
string
)

67 int 
i
;

69 
i
 = 0;

70 while (
string
[
i
] != '\0')

71 
i
++;

72 return (
i
);

73 
	}
}

75 int 
	$there_is_n
(char *
line
)

77 int 
i
;

79 
i
 = 0;

80 while (
line
[
i
] != '\0')

82 if (
line
[
i
] == '\n')

83 return (
i
 + 1);

84 
i
++;

87 
	}
}

	@libft/includes/ft_printf.h

12 #ifndef 
FT_PRINTF_H


13 #define 
	#FT_PRINTF_H


	)

15 #include 
	~"libft.h
"

16 #include 
	~<stdarg.h
>

18 int 
ft_printf
(const char *
last
, ...);

19 void 
ft_printf_char
(char 
c
, int 
fd
, int *
count
);

20 void 
ft_printf_str
(char *
s
, int 
fd
, int *
count
);

21 void 
ft_printf_int
(int 
n
, int 
fd
, int *
count
);

22 int 
ft_count_int
(int 
n
);

23 void 
ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
);

24 void 
ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
);

25 int 
ft_count_unsigned_int
(unsigned int 
n
);

26 void 
ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
);

27 void 
ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
);

31 void 
ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
);

32 int 
ft_dprintf
(int 
fd
, const char *
last
, ...);

	@libft/includes/get_next_line.h

12 #ifndef 
GET_NEXT_LINE_H


13 #define 
	#GET_NEXT_LINE_H


	)

15 #include 
	~<unistd.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<limits.h
>

19 #ifndef 
BUFFER_SIZE


20 #define 
	#BUFFER_SIZE
 42

	)

23 char *
ft_calloc_count
(int 
count
);

24 int 
ft_strlen_int
(const char *
string
);

25 char *
ft_join
(char *
nextline
, char *
buffer
);

26 int 
there_is_n
(char *
line
);

27 char *
read_fd
(char *
nextline
, int 
fd
, int *
error
);

28 char *
create_result
(char *
line
);

29 char *
create_nextline
(char *
result
, char *
line
);

30 char *
get_next_line
(int 
fd
);

31 char *
get_next_line_maxopen
(int 
fd
);

32 int 
check_errors
(int 
fd
, char **
line
);

33 void 
prepare_forstash
(char **
line
, char **
buffer
);

	@libft/includes/libft.h

12 #ifndef 
LIBFT_H


13 #define 
	#LIBFT_H


	)

15 #include 
	~<stddef.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<unistd.h
>

18 #include 
	~"ft_printf.h
"

19 #include 
	~"get_next_line.h
"

21 typedef struct 
	ss_list


23 void *
	mcontent
;

24 struct 
s_list
 *
	mnext
;

25 } 
	tt_list
;

27 void *
ft_memset
(void *
b
, int 
c
, 
size_t
 
len
);

28 void 
ft_bzero
(void *
s
, 
size_t
 
n
);

29 void *
ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
);

30 void *
ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
);

31 void *
ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
);

32 int 
ft_isalpha
(int 
c
);

33 int 
ft_isdigit
(int 
c
);

34 int 
ft_isalnum
(int 
c
);

35 int 
ft_isascii
(int 
c
);

36 int 
ft_isprint
(int 
c
);

37 
size_t
 
ft_strlen
(const char *
s
);

38 int 
ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
);

39 char *
ft_strcpy
(char *
dst
, const char *
src
);

40 
size_t
 
ft_strlcpy
(char *
dst
, const char *
src
, size_t 
dstsize
);

41 
size_t
 
ft_strlcat
(char *
dst
, const char *
src
, size_t 
dstsize
);

42 char *
ft_strchr
(const char *
s
, int 
c
);

43 char *
ft_strrchr
(const char *
s
, int 
c
);

44 char *
ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
);

45 int 
ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
);

46 int 
ft_toupper
(int 
c
);

47 int 
ft_tolower
(int 
c
);

48 int 
ft_atoi
(const char *
str
);

49 void *
ft_calloc
(
size_t
 
count
, size_t 
size
);

50 char *
ft_strdup
(const char *
s1
);

51 char *
ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
);

52 char *
ft_strjoin
(char const *
s1
, char const *
s2
);

53 char *
ft_strtrim
(char const *
s1
, char const *
set
);

54 char **
ft_split
(char const *
s
, char 
c
);

55 char *
ft_itoa
(int 
n
);

56 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char));

57 void 
	`ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*));

58 void 
	`ft_putchar_fd
(char 
c
, int 
fd
);

59 void 
	`ft_putstr_fd
(char *
s
, int 
fd
);

60 void 
	`ft_putendl_fd
(char *
s
, int 
fd
);

61 void 
	`ft_putnbr_fd
(int 
n
, int 
fd
);

64 
t_list
 *
	`ft_lstnew
(void *
content
);

65 void 
	`ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
);

66 int 
	`ft_lstsize
(
t_list
 *
lst
);

67 
t_list
 *
	`ft_lstlast
(t_list *
lst
);

68 void 
	`ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
);

69 void 
	`ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*));

70 void 
	`ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*));

71 void 
	`ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *));

72 
t_list
 *
	`ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *));

73 void 
	`delete_first_el
(
t_list
 **
a
);

74 void 
	`delete_last_el
(
t_list
 **
a
);

75 void 
	`del
(void *
content
);

78 int 
	`power
(int 
str_base
, int 
power
);

79 int 
	`ft_atoi_base
(const char *
str
, int 
str_base
);

80 int 
	`transform
(char 
c
);

81 
size_t
 
	`ft_strcspn
(const char *
s
, const char *
reject
);

82 char *
	`ft_strpbrk
(const char *
s1
, const char *
s2
);

83 
size_t
 
	`ft_strspn
(const char *
s
, const char *
accept
);

84 char *
	`str_lowercase
(char *
str
);

	@libft/libft/del.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$del
(void *
content
)

16 if (
content
)

17 
	`free
(
content
);

18 
	}
}

	@libft/libft/ft_atoi.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_atoi
(const char *
str
)

16 int 
i
;

17 int 
result
;

18 int 
sign
;

20 
i
 = 0;

21 
result
 = 0;

22 
sign
 = 1;

23 while (
str
[
i
] == 32 || (str[i] >= 9 && str[i] <= 13))

24 
i
++;

25 if (
str
[
i
] == '-')

27 
sign
 *= (-1);

28 
i
++;

30 else if (
str
[
i
] == '+')

31 
i
++;

32 while (
str
[
i
] >= '0' && str[i] <= '9')

34 
result
 *= 10;

35 
result
 += 
str
[
i
] - 48;

36 
i
++;

38 return (
sign
 * 
result
);

39 
	}
}

	@libft/libft/ft_atoi_base.c

12 #include 
	~"../includes/libft.h
"

13 #include 
	~"../includes/get_next_line.h
"

15 int 
	$transform
(char 
c
)

17 int 
i
;

18 char 
c2
;

20 
i
 = 10;

21 if (
c
 >= 'A' && c <= 'F')

22 
c2
 = 'A';

23 if (
c
 >= 'a' && c <= 'f')

24 
c2
 = 'a';

25 while (
c
 != 
c2
)

27 
c2
++;

28 
i
++;

30 return (
i
);

31 
	}
}

33 int 
	$ft_atoi_base
(const char *
str
, int 
str_base
)

35 int 
i
;

36 int 
count
;

37 int 
result
;

38 int 
sign
;

40 
i
 = 0;

41 
result
 = 0;

42 
count
 = 
	`ft_strlen_int
(
str
) - 1;

43 
sign
 = 1;

44 if (
str
[
i
] == '-')

46 
i
++;

47 
sign
 = -1;

48 
count
--;

50 while (
str
[
i
++] != 0)

52 if (
str
[
i
] >= '0' && str[i] <= '9')

53 
result
 = result + (
str
[
i
] - '0') * 
	`power
(
str_base
, 
count
);

54 if ((
str
[
i
] >= 'A' && str[i] <= 'F') || \

55 (
str
[
i
] >= 'a' && str[i] <= 'f'))

56 
result
 = result + 
	`transform
(
str
[
i
]) * 
	`power
(
str_base
, 
count
);

57 
count
--;

59 return (
result
 * 
sign
);

60 
	}
}

	@libft/libft/ft_bzero.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_bzero
(void *
s
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (
n
 == 0)

21 while (
i
 < 
n
)

23 *(char *)(
s
 + 
i
) = 0;

24 
i
++;

26 
	}
}

	@libft/libft/ft_calloc.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_calloc
(
size_t
 
count
, size_t 
size
)

16 void *
ptr
;

18 
ptr
 = (void *)
	`malloc
(
count
 * 
size
);

19 if (!
ptr
)

20 return (
NULL
);

21 
	`ft_bzero
(
ptr
, (
count
 * 
size
));

22 return (
ptr
);

23 
	}
}

	@libft/libft/ft_isalnum.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalnum
(int 
c
)

16 if (
	`ft_isalpha
(
c
) == 1 || 
	`ft_isdigit
(c) == 1)

20 
	}
}

	@libft/libft/ft_isalpha.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalpha
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

18 else if (
c
 >= 'a' && c <= 'z')

22 
	}
}

	@libft/libft/ft_isascii.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isascii
(int 
c
)

16 if (
c
 >= 0 && c <= 127)

20 
	}
}

	@libft/libft/ft_isdigit.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isdigit
(int 
c
)

16 if (
c
 >= '0' && c <= '9')

20 
	}
}

	@libft/libft/ft_isprint.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isprint
(int 
c
)

16 if (
c
 >= 32 && c <= 126)

20 
	}
}

	@libft/libft/ft_itoa.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbchar
(int 
n
)

16 
size_t
 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

41 char *
	$ft_nb_is_negative
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

43 int 
result
;

45 
result
 = 0;

46 if (
n
 == -2147483648)

48 
n
 = -214748364;

49 
itoa_str
[
nb_char
 - 1] = (char)(8 + 48);

50 
nb_char
--;

52 
n
 *= (-1);

53 while (
n
 > 0)

55 
result
 = (
n
 % 10);

56 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

57 
n
 = n / 10;

58 
nb_char
--;

60 
itoa_str
[--
nb_char
] = '-';

61 return (
itoa_str
);

62 
	}
}

64 char *
	$ft_nb_is_positive
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

66 int 
result
;

68 
result
 = 0;

69 while (
n
 > 0)

71 
result
 = 
n
 % 10;

72 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

73 
n
 = n / 10;

74 
nb_char
--;

76 return (
itoa_str
);

77 
	}
}

79 char *
	$ft_itoa
(int 
n
)

81 
size_t
 
nb_char
;

82 
size_t
 
buff
;

83 char *
itoa_str
;

85 
buff
 = 0;

86 
nb_char
 = 
	`ft_count_nbchar
(
n
);

87 
itoa_str
 = (char *)
	`ft_calloc
((
nb_char
 + 1), sizeof(char));

88 if (!
itoa_str
)

89 return (
NULL
);

90 while (
buff
 < 
nb_char
)

92 
itoa_str
[
buff
] = '0';

93 
buff
++;

95 if (
n
 == 0)

96 
itoa_str
[0] = (char)(0 + 48);

97 else if (
n
 < 0)

98 
itoa_str
 = 
	`ft_nb_is_negative
(
n
, itoa_str, 
nb_char
);

99 else if (
n
 > 0)

100 
itoa_str
 = 
	`ft_nb_is_positive
(
n
, itoa_str, 
nb_char
);

101 return (
itoa_str
);

102 
	}
}

	@libft/libft/ft_lstadd_back.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
)

16 
t_list
 *
lstlast
;

18 if (*
lst
 == 
NULL
)

19 *
lst
 = 
new
;

20 else if (!
lst
 || !
new
)

24 
lstlast
 = 
	`ft_lstlast
(*
lst
);

25 
lstlast
->
next
 = 
new
;

27 
	}
}

	@libft/libft/ft_lstadd_front.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
)

16 if (*
lst
 == 
NULL
)

18 
new
->
next
 = 
NULL
;

19 *
lst
 = 
new
;

21 else if (*
lst
 != 
NULL
)

23 
new
->
next
 = *
lst
;

24 *
lst
 = 
new
;

26 
	}
}

	@libft/libft/ft_lstclear.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*))

16 
t_list
 *
temp
;

17 
t_list
 *
ptr
;

19 
ptr
 = *
lst
;

20 if (!
del
)

22 while (
ptr
 != 
NULL
)

24 
temp
 = 
ptr
->
next
;

25 
	`ft_lstdelone
(
ptr
, 
del
);

26 
ptr
 = 
temp
;

28 *
lst
 = 
NULL
;

29 
	}
}

	@libft/libft/ft_lstdel_first_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_first_el
(
t_list
 **
a
)

16 
t_list
 *
tmp
;

18 
tmp
 = (*
a
)->
next
;

19 
	`free
 (*
a
);

20 *
a
 = 
tmp
;

21 
	}
}

	@libft/libft/ft_lstdel_last_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_last_el
(
t_list
 **
a
)

16 
t_list
 *
end
;

17 
t_list
 *
prev
;

19 
end
 = *
a
;

20 
prev
 = 
NULL
;

21 while (
end
->
next
)

23 
prev
 = 
end
;

24 
end
 = end->
next
;

26 
prev
->
next
 = 
NULL
;

27 
	`free
 (
end
);

28 
	}
}

	@libft/libft/ft_lstdelone.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*))

16 if (!
lst
 || !
del
)

18 
	`del
(
lst
->
content
);

19 
	`free
(
lst
);

20 
	}
}

	@libft/libft/ft_lstiter.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *))

16 
t_list
 *
ptr
;

18 
ptr
 = 
lst
;

19 while (
ptr
 != 
NULL
)

21 
	`f
(
ptr
->
content
);

22 
ptr
 = ptr->
next
;

24 
	}
}

	@libft/libft/ft_lstlast.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstlast
(
t_list
 *
lst
)

16 while (
lst
 != 
NULL
 && lst->
next
 != NULL)

18 
lst
 = lst->
next
;

20 return (
lst
);

21 
	}
}

	@libft/libft/ft_lstmap.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *))

16 
t_list
 *
new_list
;

17 
t_list
 *
head
;

19 if (!
lst
 || !
f
)

20 return (
NULL
);

21 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

22 if (!
new_list
)

23 return (
NULL
);

24 
head
 = 
new_list
;

25 
lst
 = lst->
next
;

26 while (
lst
 != 
NULL
)

28 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

29 if (!
new_list
)

31 
	`ft_lstclear
(&
head
, 
del
);

32 return (
NULL
);

34 
	`ft_lstadd_back
(&
head
, 
new_list
);

35 
lst
 = lst->
next
;

37 return (
head
);

38 
	}
}

	@libft/libft/ft_lstnew.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstnew
(void *
content
)

16 
t_list
 *
lstnew
;

18 
lstnew
 = (
t_list
 *)
	`malloc
(sizeof(t_list));

19 if (!
lstnew
)

20 return (
NULL
);

21 
lstnew
->
next
 = 
NULL
;

22 
lstnew
->
content
 = (void *)content;

23 return (
lstnew
);

24 
	}
}

	@libft/libft/ft_lstsize.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_lstsize
(
t_list
 *
lst
)

16 int 
i
;

17 
t_list
 *
ptr
;

19 
i
 = 0;

20 
ptr
 = 
NULL
;

21 
ptr
 = 
lst
;

22 while (
ptr
 != 
NULL
)

24 
ptr
 = ptr->
next
;

25 
i
++;

27 return (
i
);

28 
	}
}

	@libft/libft/ft_memchr.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s
 + 
i
) == (unsigned char) 
c
)

23 return ((unsigned char *)(
s
 + 
i
));

26 
i
++;

28 return (
NULL
);

29 
	}
}

	@libft/libft/ft_memcmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s1
 + 
i
) != *(unsigned char *)(
s2
 + i))

23 return (*(unsigned char *)(
s1
 + 
i
) - *(unsigned char *)(
s2
 + i));

26 
i
++;

29 
	}
}

	@libft/libft/ft_memcpy.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 while (
i
 < 
n
)

23 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

24 
i
++;

26 return (
dst
);

27 
	}
}

	@libft/libft/ft_memmove.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 if (
dst
 > 
src
)

23 while (
len
--)

25 *(char *)(
dst
 + 
len
) = *(char *)(
src
 + len);

27 return (
dst
);

29 while (
i
 < 
len
)

31 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

32 
i
++;

34 return (
dst
);

35 
	}
}

	@libft/libft/ft_memset.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memset
(void *
b
, int 
c
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
len
)

21 *(unsigned char *)(
b
 + 
i
) = (unsigned char)
c
;

22 
i
++;

24 return (
b
);

25 
	}
}

	@libft/libft/ft_putchar_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putchar_fd
(char 
c
, int 
fd
)

16 
	`write
(
fd
, &
c
, 1);

17 
	}
}

	@libft/libft/ft_putendl_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putendl_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

26 
	`write
(
fd
, "\n", 1);

28 
	}
}

	@libft/libft/ft_putnbr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putnbr_fd
(int 
n
, int 
fd
)

16 if (
n
 == -2147483648)

18 
	`ft_putstr_fd
("-2147483648", 
fd
);

20 else if (
n
 < 0)

22 
	`ft_putchar_fd
('-', 
fd
);

23 
n
 = n * (-1);

24 
	`ft_putnbr_fd
(
n
, 
fd
);

26 else if (
n
 > 9)

28 
	`ft_putnbr_fd
(
n
 / 10, 
fd
);

29 
	`ft_putnbr_fd
((
n
 % 10), 
fd
);

32 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

33 
	}
}

	@libft/libft/ft_putstr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putstr_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

27 
	}
}

	@libft/libft/ft_split.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbsubstr
(const char *
s
, char 
c
)

16 unsigned int 
i
;

17 
size_t
 
count
;

19 
i
 = 0;

20 
count
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] != 
c
)

25 while (
s
[
i
] != 
c
 && s[i] != '\0')

26 
i
++;

27 
count
++;

29 while (
s
[
i
] == 
c
)

30 
i
++;

32 return (
count
);

33 
	}
}

35 unsigned int 
	$ft_start_index_substr
(char const *
s
, char 
c
, unsigned int 
start
)

37 while (
s
[
start
] == 
c
 && s[start] != '\0')

38 
start
++;

39 return (
start
);

40 
	}
}

42 unsigned int 
	$ft_nb_char_substr
(char const *
s
, char 
c
, unsigned int 
start
)

44 unsigned int 
nb_char_substr
;

46 
nb_char_substr
 = 0;

47 while (
s
[
start
] != 
c
 && s[start] != '\0')

49 
start
++;

50 
nb_char_substr
++;

52 return (
nb_char_substr
);

53 
	}
}

55 char *
ft_create_substr
(\

56 char const *
s
, char 
c
, unsigned int 
start
, unsigned int 
nb_char_substr
)

58 unsigned int 
	gi
;

59 char *
	gsubstr
;

61 
	gi
 = 0;

62 
	gsubstr
 = (char *)
ft_calloc
((
nb_char_substr
 + 1), sizeof(char));

63 if (!
	gsubstr
)

64 return (
	gNULL
);

65 while (
	gs
[
start
] != 
c
 && 
s
[start] != '\0' && 
i
 < 
nb_char_substr
)

66 
substr
[
i
++] = 
s
[
start
++];

67 return (
	gsubstr
);

70 char **
	$ft_split
(char const *
s
, char 
c
)

72 
size_t
 
nb_substr
;

73 
size_t
 
i
;

74 char **
tab2d
;

75 unsigned int 
start
;

76 unsigned int 
nb_char_substr
;

78 
i
 = 0;

79 
start
 = 0;

80 
nb_substr
 = 
	`ft_count_nbsubstr
(
s
, 
c
);

81 
tab2d
 = (char **)
	`ft_calloc
((
nb_substr
 + 1), sizeof(char *));

82 if (!
tab2d
)

83 return (
NULL
);

84 while (
s
[
start
] != '\0' && 
i
 < 
nb_substr
)

86 
start
 = 
	`ft_start_index_substr
(
s
, 
c
, start);

87 
nb_char_substr
 = 
	`ft_nb_char_substr
(
s
, 
c
, 
start
);

88 
tab2d
[
i
] = 
	`ft_create_substr
(
s
, 
c
, 
start
, 
nb_char_substr
);

89 
start
 = start + 
nb_char_substr
;

90 
i
++;

92 return (
tab2d
);

93 
	}
}

	@libft/libft/ft_strchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strchr
(const char *
s
, int 
c
)

16 int 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 if ((char)
c
 == 
s
[
i
])

22 return ((char *)(
s
 + 
i
));

23 
i
++;

25 if ((char)
c
 == '\0')

26 return ((char *)(
s
 + 
i
));

28 return (
NULL
);

29 
	}
}

	@libft/libft/ft_strcpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strcpy
(char *
dst
, const char *
src
)

16 int 
i
;

18 
i
 = 0;

19 while (
src
[
i
])

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 
dst
[
i
] = '\0';

25 return (
dst
);

26 
	}
}

	@libft/libft/ft_strcspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strcspn
(const char *
s
, const char *
reject
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
])

21 if (
	`ft_strchr
(
reject
, 
s
[
i
]) != 
NULL
)

22 return (
i
);

23 
i
++;

25 return (
i
);

26 
	}
}

	@libft/libft/ft_strdup.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strdup
(const char *
s1
)

16 int 
size
;

17 char *
s1_copie
;

19 
size
 = 
	`ft_strlen
(
s1
) + 1;

20 
s1_copie
 = (char *)
	`malloc
(
size
 * sizeof(char));

21 if (!
s1_copie
)

22 return (
NULL
);

23 
	`ft_strlcpy
(
s1_copie
, 
s1
, 
size
);

24 return (
s1_copie
);

25 
	}
}

	@libft/libft/ft_striteri.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*))

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`f
(
i
, &
s
[i]);

24 
i
++;

27 
	}
}

	@libft/libft/ft_strjoin.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strjoin
(char const *
s1
, char const *
s2
)

16 
size_t
 
size_s1
;

17 
size_t
 
size_s2
;

18 char *
strjoin
;

20 
size_s1
 = 
	`ft_strlen
(
s1
);

21 
size_s2
 = 
	`ft_strlen
(
s2
);

22 
strjoin
 = (char *)
	`malloc
((
size_s1
 + 
size_s2
 + 1) * sizeof(char));

23 if (!
strjoin
)

24 return (
NULL
);

25 
	`ft_memcpy
(
strjoin
, 
s1
, 
size_s1
);

26 
	`ft_memcpy
((
strjoin
 + 
size_s1
), 
s2
, 
size_s2
);

27 
	`ft_memset
((
strjoin
 + 
size_s1
 + 
size_s2
), 0, 1);

28 return (
strjoin
);

29 
	}
}

	@libft/libft/ft_strlcat.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcat
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
strlen_src
;

18 
size_t
 
strlen_dst
;

19 
size_t
 
temp
;

21 
i
 = 0;

22 
strlen_src
 = 
	`ft_strlen
(
src
);

23 
strlen_dst
 = 
	`ft_strlen
(
dst
);

24 
temp
 = 
strlen_dst
;

25 if (
dstsize
 < 
strlen_dst
)

26 return (
dstsize
 + 
strlen_src
);

27 if (
dstsize
 > 
strlen_dst
 + 1)

29 while (
src
[
i
] && 
strlen_dst
 != (
dstsize
 - 1))

31 
dst
[
strlen_dst
++] = 
src
[
i
++];

33 
dst
[
strlen_dst
] = '\0';

35 return (
temp
 + 
strlen_src
);

36 
	}
}

	@libft/libft/ft_strlcpy.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcpy
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
j
;

19 
i
 = 0;

20 
j
 = 0;

21 while (
src
[
i
] != '\0')

23 
i
++;

25 if (
dstsize
 > 0)

27 while (
j
 < (
dstsize
 - 1) && 
src
[j] != '\0')

29 
dst
[
j
] = 
src
[j];

30 
j
++;

32 
dst
[
j
] = '\0';

34 return (
i
);

35 
	}
}

	@libft/libft/ft_strlen.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlen
(const char *
s
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 
i
++;

23 return (
i
);

24 
	}
}

	@libft/libft/ft_strmapi.c

12 #include 
	~"../includes/libft.h
"

14 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char))

16 unsigned int 
i
;

17 
size_t
 
size
;

18 char *
strmapi
;

20 
i
 = 0;

21 
size
 = 
	`ft_strlen
(
s
);

22 
strmapi
 = (char *)
	`malloc
((
size
 + 1) * sizeof(char));

23 if (!
strmapi
)

24 return (
NULL
);

25 while (
s
[
i
] != '\0')

27 
strmapi
[
i
] = 
	`f
(i, 
s
[i]);

28 
i
++;

30 
strmapi
[
i
] = '\0';

31 return (
strmapi
);

32 
	}
}

	@libft/libft/ft_strncmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (((unsigned char)
s1
[
i
] || (unsigned char)
s2
[i]) && i < 
n
)

21 if (
s1
[
i
] != 
s2
[i])

22 return ((unsigned char)
s1
[
i
] - (unsigned char)
s2
[i]);

23 
i
++;

26 
	}
}

	@libft/libft/ft_strncpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strncpy
(char *
dst
, const char *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
src
[
i
] && i < 
len
)

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 while (
i
 < 
len
)

26 
dst
[
i
] = '\0';

27 
i
++;

29 return (
dst
);

30 
	}
}

	@libft/libft/ft_strnstr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
)

16 
size_t
 
len_needle
;

17 
size_t
 
len_haystack
;

19 
len_needle
 = 
	`ft_strlen
(
needle
);

20 
len_haystack
 = 
	`ft_strlen
(
haystack
);

21 if (
needle
[0] == '\0')

22 return ((char *)(
haystack
));

23 if (
len_needle
 > 
len_haystack
 || 
len
 < len_needle)

24 return (
NULL
);

25 if (
len
 > 
len_haystack
)

26 
len
 = 
len_haystack
;

27 while (
len
 >= 
len_needle
 && 
haystack
)

29 if (
	`ft_memcmp
(
haystack
, 
needle
, 
len_needle
) == 0)

30 return ((char *)(
haystack
));

33 
haystack
++;

34 
len
--;

37 return (
NULL
);

38 
	}
}

	@libft/libft/ft_strpbrk.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strpbrk
(const char *
s1
, const char *
s2
)

16 int 
i
;

18 
i
 = 0;

19 while (
s1
[
i
] != '\0')

21 if (
	`ft_strchr
(
s2
, 
s1
[
i
]) != 0)

23 return ((char *) &
s1
[
i
]);

25 ++
i
;

28 
	}
}

	@libft/libft/ft_strrchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strrchr
(const char *
s
, int 
c
)

16 int 
i
;

17 int 
k
;

19 
i
 = 0;

20 
k
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] == (char)
c
)

24 
k
 = 
i
;

25 
i
++;

27 if (
s
[
k
] == (char)
c
)

28 return ((char *)(
s
 + 
k
));

29 else if ((char)
c
 == 
s
[
i
])

30 return ((char *)(
s
 + 
i
));

32 return (
NULL
);

33 
	}
}

	@libft/libft/ft_strspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strspn
(const char *
s
, const char *
accept
)

16 
size_t
 
count
;

17 
size_t
 
i
;

19 
count
 = 0;

20 
i
 = 0;

21 while (
s
[
i
] && 
	`ft_strchr
(
accept
, s[i]) != 0)

23 
count
++;

24 
i
++;

26 return (
count
);

27 
	}
}

	@libft/libft/ft_strtrim.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strtrim
(char const *
s1
, char const *
set
)

16 unsigned int 
front
;

17 unsigned int 
end
;

18 unsigned int 
i
;

19 char *
strtrim
;

21 
front
 = 0;

22 
i
 = 0;

23 
end
 = (unsigned int)(
	`ft_strlen
(
s1
));

24 while (
s1
[
front
] != '\0' && 
	`ft_strchr
(
set
, *(s1 + front)) != 
NULL
)

25 
front
++;

26 while (
front
 < 
end
 && 
	`ft_strrchr
(
set
, *(
s1
 + end - 1)) != 
NULL
)

27 
end
--;

28 
strtrim
 = (char *)
	`malloc
((
end
 - 
front
 + 1) * sizeof(char));

29 if (!
strtrim
)

30 return (
NULL
);

31 
i
 = 0;

32 while (
front
 < 
end
)

33 
strtrim
[
i
++] = 
s1
[
front
++];

34 
strtrim
[
i
] = 0;

35 return (
strtrim
);

36 
	}
}

	@libft/libft/ft_substr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
)

16 char *
substr
;

17 unsigned int 
i
;

18 
size_t
 
size
;

20 
i
 = 0;

21 if (!
s
)

22 return (
NULL
);

23 
size
 = 
	`ft_strlen
(
s
);

24 if (
len
 > 
size
)

25 
len
 = 
size
;

26 if (
start
 >= (unsigned int)
size
)

28 
substr
 = (char *)
	`malloc
(1 * sizeof(char));

29 if (!
substr
)

30 return (
NULL
);

31 
substr
[0] = '\0';

32 return (
substr
);

34 
substr
 = (char *)
	`malloc
((
len
 + 1) * sizeof(char));

35 if (!
substr
)

36 return (
NULL
);

37 while (
i
 < (unsigned int)
len
 && 
s
[
start
] != '\0' )

38 
substr
[
i
++] = 
s
[
start
++];

39 
substr
[
i
] = '\0';

40 return (
substr
);

41 
	}
}

	@libft/libft/ft_tolower.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_tolower
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

17 return (
c
 + 32);

19 return (
c
);

20 
	}
}

	@libft/libft/ft_toupper.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_toupper
(int 
c
)

16 if (
c
 >= 'a' && c <= 'z')

17 return (
c
 - 32);

19 return (
c
);

20 
	}
}

	@libft/libft/power.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$power
(int 
str_base
, int 
power
)

16 int 
result
;

18 
result
 = 1;

19 if (
power
 < 0 || 
str_base
 == 0)

23 while (
power
 > 0)

25 
result
 = result * 
str_base
;

26 
power
--;

28 return (
result
);

29 
	}
}

	@libft/libft/str_lowercase.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$str_lowercase
(char *
str
)

16 int 
i
;

18 
i
 = 0;

19 while (
str
[
i
])

21 if (
str
[
i
] >= 'A' && str[i] <= 'Z')

22 
str
[
i
] += 32;

23 
i
++;

25 return (
str
);

26 
	}
}

	@main.c

13 #include 
	~"minishell.h
"

15 
t_shell
 *
	gg_shell
;

19 char *
	$readline_routine
(void)

21 char *
line
;

23 
line
 = 
NULL
;

24 
line
 = 
	`readline
(
BLU_2
"minishell$ "
RESET
);

25 if (!
line
)

27 
	`rl_clear_history
();

28 return (
NULL
) ;

30 if (
line
[0])

31 
	`add_history
(
line
);

32 return (
line
);

33 
	}
}

35 void 
	$print_cmd
(
t_cmd
 **
head
)

37 
t_cmd
 *
ptr
;

38 int 
i
 = 0;

39 int 
j
 = 0;

41 
	`ft_printf
("command print\n");

42 if (!
head
 || !*head)

44 
ptr
 = *
head
;

45 while (
ptr
)

47 if (
ptr
->
cmd
)

49 while(
ptr
->
cmd
[
j
])

51 
	`ft_printf
("cmd[%d] = ", 
i
);

52 
	`ft_printf
("%s\n", 
ptr
->
cmd
[
j
]);

53 
j
++;

56 
j
 = 0;

57 if (
ptr
->
redir
)

59 while (
ptr
->
redir
[
j
])

61 
	`ft_printf
("redir[%d] = ", 
i
);

62 
	`ft_printf
("%s\n", 
ptr
->
redir
[
j
]);

63 
j
++;

66 if (
ptr
->
path
)

68 
	`ft_printf
("path[%d] = ", 
i
);

69 
	`ft_printf
("%s\n", 
ptr
->
path
);

71 
j
 = 0;

72 
i
++;

73 
ptr
 = ptr->
next
;

75 
	}
}

96 void 
	$check_for_malloc_error
(
t_cmd
 **
head
)

98 if (
g_shell
->
error_exit
 == 1)

100 
	`free_and_exit_prog
(
head
, 1);

102 
	}
}

105 int 
	$main
(int 
ac
, char **
av
, char **
envp
)

107 (void)
av
;

108 (void)
ac
;

109 char *
line
;

110 
t_token
 *
token
;

111 
t_cmd
 *
cmd
;

112 int 
exit_status
;

114 if (!
	`init_shell
(
envp
))

118 
	`parent_signal_handler
();

119 
line
 = 
	`readline_routine
();

120 if (!
line
)

122 
token
 = 
	`parsing
(
line
);

123 
cmd
 = 
	`cmd_linked_list
(&
token
);

125 
	`execution
(&
cmd
);

127 
	`check_for_malloc_error
(&
cmd
);

128 
	`free_cmd
(&
cmd
);

130 
exit_status
 = 
g_shell
->exit_status;

131 
	`free_shell
();

132 
	`printf
("exit\n");

133 return (
exit_status
);

134 
	}
}

	@malloc_error/malloc_error_print_message.c

12 #include 
	~"minishell.h
"

14 void 
	$malloc_error_print_message
(char *
s
)

16 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
s
);

17 
g_shell
->
error_exit
 = 1;

18 
g_shell
->
exit_status
 = 1;

19 
	}
}

	@minishell.h

13 #ifndef 
MINISHELL_H


14 #define 
	#MINISHELL_H


	)

16 #include 
	~<stdio.h
>

17 #include 
	~<string.h
>

18 #include 
	~<stdlib.h
>

19 #include 
	~<errno.h
>

20 #include 
	~<curses.h
>

21 #include 
	~<term.h
>

22 #include 
	~<signal.h
>

23 #include 
	~<unistd.h
>

24 #include 
	~<fcntl.h
>

25 #include 
	~<stdarg.h
>

26 #include 
	~<sys/wait.h
>

27 #include 
	~<sys/stat.h
>

28 #include 
	~<sys/types.h
>

29 #include 
	~<readline/readline.h
>

30 #include 
	~<readline/history.h
>

31 #include 
	~"libft/includes/libft.h
"

34 #define 
	#RED
 "\x1b[31m"

	)

35 #define 
	#BLU
 "\x1B[34m"

	)

36 #define 
	#BLU_2
 "\e[1;34m"

	)

37 #define 
	#GRN
 "\x1B[32m"

	)

38 #define 
	#YEL
 "\x1B[33m"

	)

39 #define 
	#MAG
 "\e[1;35m"

	)

40 #define 
	#CYN
 "\x1B[36m"

	)

41 #define 
	#WHT
 "\x1B[37m"

	)

42 #define 
	#RESET
 "\x1B[0m"

	)

44 #define 
	#WORD
 1

	)

45 #define 
	#PIPELINE
 2

	)

46 #define 
	#L_CHEVRON
 3

	)

47 #define 
	#R_CHEVRON
 4

	)

48 #define 
	#APPEND
 5

	)

49 #define 
	#HERE_DOC
 6

	)

50 #define 
	#DOLLAR
 7

	)

51 #define 
	#QUESTION
 8

	)

52 #define 
	#EXPAND
 9

	)

53 #define 
	#DELETE
 10

	)

54 #define 
	#EXPANDED
 11

	)

55 #define 
	#ERROR_EXIT
 -1

	)

60 typedef struct 
	ss_env


62 char *
	mvar_name
;

63 char *
	mvar_value
;

64 struct 
s_env
 *
	mnext
;

65 } 
	tt_env
;

67 typedef struct 
	ss_token


69 char *
	mcontent
;

70 int 
	mid
;

71 struct 
s_token
 *
	mnext
;

72 } 
	tt_token
;

75 typedef struct 
	ss_cmd


77 
pid_t
 
	mpid
;

78 char **
	mcmd
;

79 char **
	mredir
;

80 char *
	mpath
;

81 int 
	mstatus
;

82 int 
	mffd_in
;

83 int 
	mffd_out
;

85 int 
	msave_fdout
;

86 int 
	msave_fdin
;

87 int 
	mfd
[2];

88 struct 
s_cmd
 *
	mnext
;

89 } 
	tt_cmd
;

91 typedef struct 
	ss_shell


93 
t_env
 *
	menv
;

94 volatile int 
	mexit_status
;

95 int 
	merror_exit
;

96 char **
	msave_env
;

97 struct 
sigaction
 
	msig_quit
;

98 struct 
sigaction
 
	msig_tstp
;

99 struct 
sigaction
 
	msig_int
;

100 struct 
sigaction
 
	msig_term
;

101 struct 
sigaction
 
	msig_stop
;

102 volatile int 
	msuspended
;

103 volatile int 
	mterminated
;

104 int 
	mpid
;

105 } 
	tt_shell
;

107 extern 
t_shell
 *
g_shell
;

110 int 
make_redirections
(
t_cmd
 *
cmd
);

111 void 
restaure_fds
(
t_cmd
 *
cmd
);

112 int 
redir_fdout
(
t_cmd
 *
cmd
, char *
redir_op
, char *
file_path
);

113 int 
redir_fdin
(
t_cmd
 *
cmd
,char *
file_path
);

114 int 
here_doc
(
t_cmd
 *
cmd
, char *
key_word
);

115 int 
append
(
t_cmd
 *
cmd
, char *
file_path
);

118 void 
free_before_exit
(
t_cmd
 **
head
);

119 void 
free_and_exit_prog
(
t_cmd
 **
head
, int 
exit_code
);

120 int 
size_tab2d
(char **
s
);

123 void 
execution
(
t_cmd
 **
head
);

124 int 
copy_env_tab
(void);

125 void 
one_cmd
(
t_cmd
 *
cmd
, t_cmd **
head
);

126 void 
pipex
(
t_cmd
 **
head
, int 
nb_cmds
);

129 int 
cmd_is_builtin
(char *
s
);

130 void 
execute_builtin
(
t_cmd
 *
cmd
, t_cmd **
head
);

131 void 
_pwd
(void);

132 void 
_env
(
t_cmd
 *
cmd
, 
t_env
 *
env
);

133 void 
print_getcwd_error
(char *
s
);

134 int 
_echo
(
t_cmd
 *
cmd
);

135 void 
ft_exit
(
t_cmd
 **
head
);

136 void 
_cd
(
t_cmd
 *
cmd
, t_cmd **
head
);

137 void 
_export
(
t_cmd
 *
cmd
, t_cmd **
head
);

138 int 
check_if_var_exists
(char *
s
);

139 int 
check_if_valid_identifier
(char *
s
, char *
command
);

140 void 
print_export_unset_error
(char *
identifier
, char *
command
);

141 void 
_unset
(
t_cmd
 *
cmd
);

144 void 
execute_bin
(
t_cmd
 *
cmd
);

145 int 
search_path
(
t_cmd
 *
cmd
, char **
env
);

146 int 
get_path
(
t_cmd
 *
cmd
);

149 
t_cmd
 *
cmd_linked_list
(
t_token
 **
token
);

150 void 
free_tab2d
(char **
s
);

151 void 
free_cmd
(
t_cmd
 **
head
);

154 int 
create_redir
(
t_token
 **
token
, 
t_cmd
 *
cmd
);

157 int 
create_cmd
(
t_token
 **
token
, 
t_cmd
 *
cmd
);

160 int 
expansion
(
t_token
 **
token
, t_token *
curr
, int 
pos
);

161 int 
check_dollar
(
t_token
 *
curr
, int 
i
);

162 int 
trim_dollar
(
t_token
 *
curr
, int 
pos
);

165 int 
is_dollar_to_expand
(
t_token
 *
curr
, int 
i
);

166 int 
not_within_squotes
(
t_token
 *
curr
, int 
pos
);

169 int 
trim_dollar
(
t_token
 *
curr
, int 
pos
);

172 int 
loop_dollars
(char *
s
, int 
i
);

173 int 
loop_through
(char *
s
, int 
i
);

176 int 
size_var
(char *
s
);

177 int 
check_var_exist
(
t_token
 *
tmp
);

180 int 
join_tokens
(
t_token
 **
new
, t_token *
curr
);

183 int 
prepare_expand
(
t_token
 *
tmp
, int 
i
);

184 int 
set_id_expansion
(
t_token
 *
token
);

187 int 
quote_removing
(
t_token
 **
head
, t_token *
curr
, int 
pos
);

189 
t_token
 *
delete_token
(t_token **
head
);

190 int 
token_list_size
(
t_token
 **
head
);

193 
t_token
 *
parsing
(char *
line
);

194 int 
syntax_error_check
(char *
s
);

195 int 
check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
);

196 int 
check_quotes_errors
(char *
s
, char 
c
, int *
i
);

197 int 
count_metachar
(char *
s
, char 
c
, int 
num
);

198 int 
check_multiple_operators_error
(int 
i
, int 
num
, char 
c
);

199 void 
print_syntax_error_char
(char 
c
);

200 void 
print_syntax_error_dchar
(char 
c
);

201 void 
print_syntax_error_str
(char *
s
);

204 int 
character_extraction
(char *
line
, int 
ind
);

205 int 
token_extraction
(char *
line
, int 
ind
);

206 
t_token
 *
get_tokens
(char *
line
);

207 int 
get_tokens_size
(char *
line
, int *
i
);

208 
t_token
 *
create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
);

211 void 
malloc_error_print_message
(char *
s
);

214 
t_token
 *
new_token
(char *
line
, int 
start
, int 
len
);

215 void 
set_id
(
t_token
 *
token
);

216 int 
token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
);

217 int 
link_token
(
t_token
 **
head
, t_token *
new
);

218 void 
free_token
(
t_token
 **
head
);

221 int 
is_dollar
(char 
c
);

222 int 
is_pipeline
(char 
c
);

223 int 
is_chevron
(char 
c
);

224 int 
is_lchevron
(char 
c
);

225 int 
is_rchevron
(char 
c
);

226 int 
is_operator
(char 
c
);

227 int 
is_newline
(char 
c
);

228 int 
is_white_space
(char 
c
);

229 int 
is_blank
(char 
c
);

230 int 
is_metacharacter
(char 
c
);

231 int 
is_delimiter
(char 
c
);

232 int 
is_word
(char 
c
);

233 int 
is_double_quote
(char 
c
);

234 int 
is_simple_quote
(char 
c
);

235 int 
is_quote
(char 
c
);

236 int 
is_question
(char 
c
);

237 int 
is_punct
(char 
c
);

238 int 
is_numeric
(char *
s
);

241 
t_env
 *
new_env
(char *
envp
);

242 int 
link_env
(
t_env
 **
head
, t_env *
last
);

243 char *
get_env_var_value
(char *
var_name
);

246 int 
init_shell
(char **
envp
);

247 void 
free_shell
(void);

250 void 
signals_init
(
sigset_t
 *
set
);

251 void 
parent_signal_handler
(void);

252 void 
child_signal_handler
(int 
pid
);

255 char **
ft_splitpath
(char *
s
, char 
c
);

259 
t_env
 *
get_envp
(char **
envp
);

260 void 
free_env
(
t_env
 **
head
);

	@parsing/expansion.c

12 #include 
	~"minishell.h
"

41 int 
	$check_dollar
(
t_token
 *
curr
, int 
i
)

43 int 
res
;

45 while (
curr
->
content
[
i
])

47 if (
	`is_dollar
(
curr
->
content
[
i
]) && 
	`not_within_squotes
(curr, i))

49 if (
	`is_dollar_to_expand
(
curr
, 
i
))

50 return (
	`prepare_expand
(
curr
, 
i
));

51 else if (
	`is_dollar
(
curr
->
content
[
i
 + 1]))

52 
i
 = 
	`loop_dollars
(
curr
->
content
, i);

53 else if (
	`is_quote
(
curr
->
content
[
i
 + 1]))

55 
res
 = 
	`trim_dollar
(
curr
, 
i
);

56 if (
res
 == 
ERROR_EXIT
)

57 return (
ERROR_EXIT
);

58 
i
 += 
res
;

60 else if (
curr
->
content
[
i
 + 1] == '\0')

63 
i
++;

66 
i
++;

68 
curr
->
id
 = 
WORD
;

69 return (
i
);

70 
	}
}

72 static void 
	$expansion_next_token
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

74 
pos
 = 0;

75 if (
curr
->
next
)

77 
curr
 = curr->
next
;

78 
	`expansion
(
head
, 
curr
, 
pos
);

80 
	}
}

106 int 
	$expansion
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

108 if (
curr
)

110 if (
curr
->
id
 == 
DOLLAR
)

112 
pos
 = 
	`check_dollar
(
curr
, pos);

113 if (
pos
 == 
ERROR_EXIT
)

114 return (
	`free_token
(
head
), 0);

115 if (
curr
->
id
 == 
DELETE
)

117 
curr
 = 
	`delete_token
(
head
);

118 if (!
curr
)

120 
head
 = 
NULL
;

123 
pos
 = 0;

125 
	`expansion
(
head
, 
curr
, 
pos
);

128 
	`expansion_next_token
(
head
, 
curr
, 
pos
);

131 
	}
}

	@parsing/expansion_dollar_conditions.c

12 #include 
	~"minishell.h
"

14 int 
	$not_within_squotes
(
t_token
 *
curr
, int 
pos
)

16 int 
i
;

17 int 
start
;

19 
i
 = 0;

20 
start
 = 0;

21 if (!
	`is_dollar
(
curr
->
content
[
pos
]))

23 while (
curr
->
content
[
i
])

25 if (
	`is_double_quote
(
curr
->
content
[
i
]))

26 
i
 = 
	`loop_through
(
curr
->
content
, i);

27 else if (
	`is_simple_quote
(
curr
->
content
[
i
]))

29 
start
 = 
i
;

30 
i
 = 
	`loop_through
(
curr
->
content
, i);

31 if (
pos
 > 
start
 && pos < 
i
)

34 
i
++;

37 
	}
}

39 int 
	$is_dollar_to_expand
(
t_token
 *
curr
, int 
i
)

41 if (
	`is_question
(
curr
->
content
[
i
 + 1]) || \

42 (!
	`is_dollar
(
curr
->
content
[
i
 + 1]) && \

43 !
	`is_quote
(
curr
->
content
[
i
 + 1]) && \

44 !
	`is_punct
(
curr
->
content
[
i
 + 1]) && \

45 !
	`is_white_space
(
curr
->
content
[
i
 + 1]) && \

46 
curr
->
content
[
i
 + 1] != '\0'))

51 
	}
}

	@parsing/expansion_expand_var_helper.c

12 #include 
	~"minishell.h
"

14 static int 
	$replace_content
(
t_token
 *
tmp
, char *
s
)

16 
	`free
(
tmp
->
content
);

17 
tmp
->
content
 = 
NULL
;

18 
tmp
->
content
 = 
	`ft_strdup
(
s
);

19 if (!
tmp
->
content
)

21 
	`malloc_error_print_message
("ft_strdup failed");

22 return (
ERROR_EXIT
);

25 
	}
}

27 int 
	$check_var_exist
(
t_token
 *
tmp
)

29 if (
	`ft_strncmp
(&
tmp
->
content
[1], "?", 1) == 0)

31 return (
	`replace_content
(
tmp
, 
	`ft_itoa
(
g_shell
->
exit_status
)));

33 else if (
g_shell
 && g_shell->
env
 && g_shell->env->
var_name
)

35 if (
	`ft_strncmp
(
g_shell
->
env
->
var_name
, &
tmp
->
content
[1], \

36 
	`ft_strlen
(
tmp
->
content
)) == 0)

38 return (
	`replace_content
(
tmp
, 
g_shell
->
env
->
var_value
));

42 
	}
}

44 int 
	$size_var
(char *
s
)

46 int 
i
;

47 int 
count
;

49 
i
 = 0;

50 
count
 = 0;

51 while (
s
[
i
] && 
	`is_white_space
(s[i]))

52 
i
++;

53 while (
s
[
i
] && !
	`is_white_space
(s[i]))

55 
count
++;

56 
i
++;

58 return (
count
);

59 
	}
}

	@parsing/expansion_helper.c

12 #include 
	~"minishell.h
"

14 int 
	$expand_var
(
t_token
 **
new
)

16 
t_token
 *
tmp
;

17 
t_env
 *
save
;

18 int 
res
;

20 
tmp
 = *
new
;

21 
save
 = 
g_shell
->
env
;

22 while (
tmp
->
id
 != 
EXPAND
)

23 
tmp
 = tmp->
next
;

24 while (
g_shell
->
env
)

26 
res
 = 
	`check_var_exist
(
tmp
);

27 if (
res
 == 
ERROR_EXIT
)

28 return (
ERROR_EXIT
);

29 else if (
res
 == 1)

31 
tmp
->
id
 = 
EXPANDED
;

32 
g_shell
->
env
 = 
save
;

33 return (
	`size_var
(
tmp
->
content
));

35 
g_shell
->
env
 = g_shell->env->
next
;

37 
tmp
->
id
 = 
DELETE
;

38 
g_shell
->
env
 = 
save
;

40 
	}
}

42 int 
	$split_tokens
(
t_token
 **
new
, char *
s
, int 
start
, int 
len
)

44 if (
start
 != 0)

46 *
new
 = 
	`new_token
(
s
, 0, 
start
);

47 if (!*
new
)

48 return (
ERROR_EXIT
);

49 (*
new
)->
id
 = 
WORD
;

50 if (!
	`token_linked_list
(
new
, 
s
, 
start
, 
len
))

51 return (
ERROR_EXIT
);

52 (*
new
)->
next
->
id
 = 
EXPAND
;

56 *
new
 = 
	`new_token
(
s
, 
start
, 
len
);

57 if (!*
new
)

58 return (
ERROR_EXIT
);

59 (*
new
)->
id
 = 
EXPAND
;

61 
start
 += 
len
;

62 
len
 = 
start
;

63 while (
s
[
len
])

64 
len
++;

65 if (
len
 != 
start
)

66 if (!
	`token_linked_list
(
new
, 
s
, 
start
, 
len
))

67 return (
ERROR_EXIT
);

69 
	}
}

71 static int 
	$var_len
(char *
s
, int 
i
)

73 int 
len
;

75 
len
 = 0;

76 
i
++;

77 if (
	`is_question
(
s
[
i
]))

81 while (
s
[
i
] && \

82 !
	`is_white_space
(
s
[
i
]) && \

83 !
	`is_quote
(
s
[
i
]) && \

84 !
	`is_question
(
s
[
i
]) && \

85 !
	`is_dollar
(
s
[
i
]) && \

86 !
	`is_punct
(
s
[
i
]))

88 
i
++;

89 
len
++;

92 return (
len
);

93 
	}
}

95 int 
	$new_id
(
t_token
 **
new
)

97 
t_token
 *
ptr
;

99 
ptr
 = *
new
;

100 while (
ptr
)

102 if (
ptr
->
id
 == 
DELETE
 || ptr->id == 
EXPANDED
)

104 
ptr
 = ptr->
next
;

106 if (
ptr
->
next
 == 
NULL
)

107 return (
WORD
);

108 return (
	`set_id_expansion
(
ptr
->
next
));

109 
	}
}

116 int 
	$prepare_expand
(
t_token
 *
curr
, int 
i
)

118 
t_token
 *
new
;

119 int 
len
;

120 int 
id
;

122 
new
 = 
NULL
;

123 
len
 = 
	`var_len
(
curr
->
content
, 
i
);

124 if (
	`split_tokens
(&
new
, 
curr
->
content
, 
i
, 
len
 + 1) == 
ERROR_EXIT
)

125 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

126 
len
 = 
	`expand_var
(&
new
);

127 if (
len
 == 
ERROR_EXIT
)

128 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

129 
id
 = 
	`new_id
 (&
new
);

130 if (
	`join_tokens
(&
new
, 
curr
) == 
ERROR_EXIT
)

131 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

132 if (
curr
->
id
 == 
DELETE
)

134 
curr
->
id
 = id ;

135 return (
len
 + 
i
);

136 
	}
}

	@parsing/expansion_join_tokens.c

12 #include 
	~"minishell.h
"

14 static int 
	$get_expanded_size
(char *
s
, int 
i
)

16 int 
size
;

18 
size
 = 0;

19 while (
	`is_white_space
(
s
[
i
]))

20 
i
++;

21 while (
s
[
i
] && !
	`is_white_space
(s[i]))

23 
i
++;

24 
size
++;

26 return (
size
);

27 
	}
}

29 static int 
	$get_new_size
(
t_token
 **
new
)

31 
t_token
 *
ptr
;

32 int 
size
;

33 int 
i
;

35 
size
 = 0;

36 
ptr
 = *
new
;

37 while (
ptr
)

39 
i
 = 0;

40 if (
ptr
->
id
 == 
EXPANDED
)

41 
size
 += 
	`get_expanded_size
(
ptr
->
content
, 
i
);

42 else if (
ptr
->
id
 != 
DELETE
)

44 while (
ptr
->
content
[
i
])

46 
size
++;

47 
i
++;

50 
ptr
 = ptr->
next
;

52 return (
size
);

53 
	}
}

55 static void 
	$copy_helper
(
t_token
 **
new
, t_token *
curr
)

57 int 
i
;

58 int 
j
;

59 
t_token
 *
ptr
;

61 
i
 = 0;

62 
j
 = 0;

63 
ptr
 = *
new
;

64 while (
ptr
)

66 if (
ptr
->
id
 == 
EXPANDED
)

68 while (
ptr
->
content
[
j
] && 
	`is_white_space
(ptr->content[j]))

69 
j
++;

70 while (
ptr
->
content
[
j
] && !
	`is_white_space
(ptr->content[j]))

71 
curr
->
content
[
i
++] = 
ptr
->content[
j
++];

73 else if (
ptr
->
id
 != 
DELETE
)

74 while (
ptr
->
content
[
j
])

75 
curr
->
content
[
i
++] = 
ptr
->content[
j
++];

76 
ptr
 = ptr->
next
;

77 
j
 = 0;

79 
curr
->
content
[
i
] = '\0';

80 
	}
}

82 static int 
	$copy_join_tokens
(
t_token
 **
new
, t_token *
curr
, int 
size
)

84 
	`free
(
curr
->
content
);

85 
curr
->
content
 = 
NULL
;

86 
curr
->
content
 = 
	`malloc
((
size
 + 1) * sizeof(char));

87 if (!
curr
->
content
)

89 
	`malloc_error_print_message
(
	`strerror
(
errno
));

90 return (
ERROR_EXIT
);

92 
	`copy_helper
(
new
, 
curr
);

93 
	`free_token
(
new
);

95 
	}
}

97 int 
	$join_tokens
(
t_token
 **
new
, t_token *
curr
)

99 int 
size
;

101 
size
 = 
	`get_new_size
(
new
);

102 if (
size
 == 0)

104 
	`free_token
(
new
);

105 
curr
->
id
 = 
DELETE
;

108 if (
	`copy_join_tokens
(
new
, 
curr
, 
size
) == 
ERROR_EXIT
)

109 return (
ERROR_EXIT
);

111 
	}
}

	@parsing/expansion_looping.c

12 #include 
	~"minishell.h
"

53 int 
	$loop_dollars
(char *
s
, int 
i
)

55 while (
	`is_dollar
(
s
[
i
]) && s[i])

56 
i
++;

57 if (
s
[
i
] != '\0' && !
	`is_white_space
(s[i]))

58 
i
--;

59 return (
i
);

60 
	}
}

68 int 
	$loop_through
(char *
s
, int 
i
)

70 char 
c
;

72 
c
 = 
s
[
i
];

73 
i
++;

74 while (
s
[
i
] != 
c
)

75 
i
++;

76 return (
i
);

77 
	}
}

	@parsing/expansion_trim_dollar.c

12 #include 
	~"minishell.h
"

17 static int 
	$copy_string
(
t_token
 *
curr
, char **
s
, int 
pos
)

19 int 
i
;

20 int 
j
;

22 
i
 = 0;

23 
j
 = 0;

24 *
s
 = 
	`malloc
(sizeof(char) * 
	`ft_strlen
(
curr
->
content
));

25 if (!*
s
)

27 
i
 = 0;

28 while (
curr
->
content
[
i
])

30 if (
i
 == 
pos
)

31 
i
++;

32 (*
s
)[
j
] = 
curr
->
content
[
i
];

33 
i
++;

34 
j
++;

36 (*
s
)[
j
] = '\0';

37 
	`free
(
curr
->
content
);

38 
curr
->
content
 = *
s
;

40 
	}
}

46 int 
	$trim_dollar
(
t_token
 *
curr
, int 
pos
)

48 int 
i
;

49 int 
start
;

50 char *
s
;

52 
s
 = 
NULL
;

53 
i
 = 0;

54 
start
 = 0;

55 while (
curr
->
content
[
i
])

57 if (
	`is_double_quote
(
curr
->
content
[
i
]))

59 
start
 = 
i
;

60 
i
 = 
	`loop_through
(
curr
->
content
, i);

61 if (
pos
 > 
start
 && pos < 
i
)

64 
i
++;

66 if (!
	`copy_string
(
curr
, &
s
, 
pos
))

67 return (
ERROR_EXIT
);

69 
	}
}

	@parsing/parsing.c

12 #include 
	~"minishell.h
"

16 void 
	$print_token
(
t_token
 **
head
)

18 int 
i
;

19 
t_token
 *
tmp
;

21 
i
 = 0;

22 if (!*
head
 || !head)

24 
tmp
 = *
head
;

25 
	`printf
("----PARSING---\n");

26 while (
tmp
)

28 if (
tmp
->
id
 == 
L_CHEVRON
)

29 
	`printf
("L_CHEVRON :");

30 else if (
tmp
->
id
 == 
R_CHEVRON
)

31 
	`printf
("R_CHEVRON :");

32 else if (
tmp
->
id
 == 
PIPELINE
)

33 
	`printf
("PIPELINE :");

34 else if (
tmp
->
id
 == 
WORD
)

35 
	`printf
("WORD :");

36 else if (
tmp
->
id
 == 
APPEND
)

37 
	`printf
("APPEND :");

38 else if (
tmp
->
id
 == 
HERE_DOC
)

39 
	`printf
("HERE_DOC :");

40 else if (
tmp
->
id
 == 
DOLLAR
)

41 
	`printf
("DOLLAR :");

42 while (
tmp
->
content
[
i
])

44 
	`printf
 ("%c", 
tmp
->
content
[
i
]);

45 
i
++;

47 
	`printf
 ("%c", 
tmp
->
content
[
i
]);

48 
	`printf
 ("\n");

49 
i
 = 0;

50 
tmp
 = tmp->
next
;

52 
	`printf
("----END----\n");

53 
	}
}

91 
t_token
 *
	$parsing
(char *
line
)

93 
t_token
 *
token
;

95 if (!
	`syntax_error_check
(
line
))

96 return (
NULL
);

97 
token
 = 
	`get_tokens
(
line
);

98 if (!
token
)

99 return (
NULL
);

100 if (!
	`expansion
(&
token
, token, 0))

101 return (
NULL
);

102 if (!
	`quote_removing
(&
token
, token, 0))

103 return (
NULL
);

105 return (
token
);

106 
	}
}

	@parsing/quote_removing.c

12 #include 
	~"minishell.h
"

14 static int 
copy_string_unquoted
(
t_token
 *
curr
, char *
new_str
, \

15 int 
start
, int 
pos
)

17 int 
	gj
;

18 int 
	gi
;

19 int 
	gsave
;

21 
	gj
 = 0;

22 
	gi
 = 0;

23 
	gsave
 = 0;

24 while (
	gcurr
->
	gcontent
[
i
])

26 if (
	gi
 == 
start
)

27 
i
++;

28 else if (
	gi
 == 
pos
)

30 
i
++;

31 
	gsave
 = 
j
;

35 
	gnew_str
[
j
] = 
curr
->
content
[
i
];

36 
	gi
++;

37 
	gj
++;

40 
	gnew_str
[
j
] = '\0';

41 return (
	gsave
);

44 int 
	$string_replace
(
t_token
 *
curr
, int 
start
, int 
pos
)

46 int 
save
;

47 char *
new_str
;

49 
new_str
 = 
	`malloc
(sizeof(char) * (
	`ft_strlen
(
curr
->
content
) - 2 + 1));

50 if (!
new_str
)

52 
	`malloc_error_print_message
(
	`strerror
(
errno
));

53 return (
ERROR_EXIT
);

55 
save
 = 
	`copy_string_unquoted
(
curr
, 
new_str
, 
start
, 
pos
);

56 
	`free
(
curr
->
content
);

57 
curr
->
content
 = 
NULL
;

58 
curr
->
content
 = 
new_str
;

59 return (
save
);

60 
	}
}

62 int 
	$remove_q
(
t_token
 *
curr
, int 
pos
)

64 int 
start
;

66 
start
 = 
pos
;

67 
pos
 = 
	`loop_through
(
curr
->
content
, pos);

68 
pos
 = 
	`string_replace
(
curr
, 
start
, pos);

69 if (
pos
 == 
ERROR_EXIT
)

70 return (
ERROR_EXIT
);

71 return (
pos
++);

72 
	}
}

74 int 
	$quote_removing
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

76 if (!
head
 || !*head)

78 if (
curr
->
content
[
pos
] == '\0')

80 if (
curr
->
next
)

82 
pos
 = 0;

83 
curr
 = curr->
next
;

84 
	`quote_removing
(
head
, 
curr
, 
pos
);

88 else if (
	`is_quote
(
curr
->
content
[
pos
]))

90 
pos
 = 
	`remove_q
(
curr
, pos);

91 if (
pos
 == 
ERROR_EXIT
)

92 return (
	`free_token
(
head
), 0);

93 
	`quote_removing
(
head
, 
curr
, 
pos
);

97 
pos
++;

98 
	`quote_removing
(
head
, 
curr
, 
pos
);

101 
	}
}

	@parsing/syntax_errors.c

12 #include 
	~"minishell.h
"

14 int 
	$check_multiple_operators_error
(int 
i
, int 
num
, char 
c
)

16 if (
i
 > 
num
)

18 if (
	`is_chevron
(
c
))

19 
	`print_syntax_error_dchar
(
c
);

20 else if (
	`is_pipeline
(
c
))

21 
	`print_syntax_error_char
(
c
);

25 
	}
}

27 int 
	$count_metachar
(char *
s
, char 
c
, int 
num
)

29 int 
i
;

31 
i
 = 1;

32 while (
s
[
i
] && s[i] == 
c
)

33 
i
++;

34 if (!
	`check_multiple_operators_error
(
i
, 
num
, 
c
))

36 while (
s
[
i
] && 
	`is_blank
(s[i]))

37 
i
++;

38 if (
	`is_operator
(
s
[
i
]) && !
	`is_pipeline
(
c
))

40 
c
 = 
s
[
i
];

41 if (
	`is_chevron
(
c
) && is_chevron(
s
[
i
 + 1]))

42 return (
	`print_syntax_error_dchar
(
c
), 0);

44 
	`print_syntax_error_char
(
c
);

47 else if (
s
[
i
] == '\0')

48 return (
	`print_syntax_error_str
("newline"), 0);

50 
	}
}

52 int 
	$check_quotes_errors
(char *
s
, char 
c
, int *
i
)

54 int 
j
;

56 
j
 = *
i
 + 1;

57 while (
s
[
j
] && s[j] != 
c
)

58 
j
++;

59 if (
s
[
j
] != 
c
)

61 
	`print_syntax_error_char
(
c
);

64 (*
i
)++;

65 while (
s
[*
i
] && s[*i] != 
c
)

66 (*
i
)++;

68 
	}
}

70 int 
	$check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
)

72 int 
j
;

74 
j
 = 0;

75 while (
s
[
j
] && 
	`is_blank
(s[j]))

76 
j
++;

77 if (
s
[
j
] == 
c
)

79 
	`print_syntax_error_char
(
c
);

82 if (!
	`count_metachar
(&
s
[
i
], 
c
, 
num
))

85 
	}
}

132 int 
	$syntax_error_check
(char *
s
)

134 int 
i
;

136 
i
 = 0;

137 while (
s
[
i
])

139 if (
	`is_quote
(
s
[
i
]))

141 if (!
	`check_quotes_errors
(
s
, s[
i
], &i))

142 return (
	`free
(
s
), 0);

144 else if ((
	`is_lchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '<', 2)) || \

145 (
	`is_rchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '>', 2)))

146 return (
	`free
(
s
), 0);

147 else if (
	`is_pipeline
(
s
[
i
]) && !
	`check_pipeline_errors
(s, i, '|', 1))

148 return (
	`free
(
s
), 0);

149 
i
++;

152 
	}
}

	@parsing/syntax_errors_print_message.c

12 #include 
	~"minishell.h
"

19 void 
	$print_syntax_error_char
(char 
c
)

21 
	`ft_dprintf
(2, "minishell: ");

22 
	`ft_dprintf
(2, "syntax error near unexpected token ");

23 
	`ft_dprintf
(2, "\'%c\'\n", 
c
);

24 
g_shell
->
exit_status
 = 258;

25 
	}
}

27 void 
	$print_syntax_error_dchar
(char 
c
)

29 
	`ft_dprintf
(2, "minishell: ");

30 
	`ft_dprintf
(2, "syntax error near unexpected token ");

31 
	`ft_dprintf
(2, "\'%c%c\'\n", 
c
, c);

32 
g_shell
->
exit_status
 = 258;

33 
	}
}

35 void 
	$print_syntax_error_str
(char *
s
)

37 
	`ft_dprintf
(2, "minishell: ");

38 
	`ft_dprintf
(2, "syntax error near unexpected token ");

39 
	`ft_dprintf
(2, "\'%s\'\n", 
s
);

40 
g_shell
->
exit_status
 = 258;

41 
	}
}

	@parsing/token_extraction.c

12 #include 
	~"minishell.h
"

21 int 
	$character_extraction
(char *
line
, int 
ind
)

23 if ((
line
[
ind
] == '>' && line[ind + 1] == '>') || \

24 (
line
[
ind
] == '<' && line[ind + 1] == '<'))

27 
	}
}

43 int 
	$word_extraction
(char *
line
, int 
ind
)

45 int 
start
;

46 char 
c
;

48 
start
 = 
ind
;

49 while (
	`is_word
(
line
[
ind
]) && line[ind])

51 if (
	`is_quote
(
line
[
ind
]))

53 
c
 = 
line
[
ind
];

54 
ind
++;

55 while (
line
[
ind
] && line[ind] != 
c
)

56 
ind
++;

58 
ind
++;

60 return (
ind
 - 
start
);

61 
	}
}

64 int 
	$get_tokens_size
(char *
line
, int *
i
)

66 int 
len
;

68 
len
 = 0;

69 while (
	`is_blank
(
line
[*
i
]))

70 (*
i
)++;

71 if (
	`is_word
(
line
[*
i
]))

72 
len
 = 
	`word_extraction
(
line
, *
i
);

73 else if (
	`is_operator
(
line
[*
i
]))

74 
len
 = 
	`character_extraction
(
line
, *
i
);

75 return (
len
);

76 
	}
}

83 
t_token
 *
	$create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
)

85 
t_token
 *
head
;

87 
head
 = 
	`new_token
(
line
, 
i
, 
len
);

88 if (!
head
)

89 return (
NULL
);

90 *
flag
 = 1;

91 return (
head
);

92 
	}
}

122 
t_token
 *
	$get_tokens
(char *
line
)

124 int 
i
;

125 int 
len
;

126 int 
flag
;

127 
t_token
 *
head
;

129 
i
 = 0;

130 
flag
 = 0;

131 
head
 = 
NULL
;

132 while (
line
[
i
])

134 
len
 = 
	`get_tokens_size
(
line
, &
i
);

135 if (
len
 == 0)

137 if (!
flag
)

139 
head
 = 
	`create_token_head
(
line
, 
i
, 
len
, &
flag
);

140 if (!
head
)

141 return (
	`free
(
line
), 
NULL
);

144 if (!
	`token_linked_list
(&
head
, 
line
, 
i
, 
len
))

145 return (
	`free_token
(&
head
), 
	`free
(
line
), 
NULL
);

146 
i
 += 
len
;

148 return (
	`free
(
line
), 
head
);

149 
	}
}

	@redirections/double_chevron.c

12 #include 
	~"minishell.h
"

14 void 
	$sigint
(int 
key
)

16 (void)
key
;

17 
	`exit
(0);

18 
	}
}

20 void 
	$sig_handler
(void)

22 
sigset_t
 
set
;

24 
	`signals_init
(&
set
);

25 
	`signal
(
SIGQUIT
, 
SIG_IGN
);

26 
	`signal
(
SIGINT
, 
sigint
);

27 
	}
}

29 void 
	$child_process
(char *
key_word
)

31 char *
doc
 = ".here_doc";

32 char *
line
;

33 int 
fd
;

35 
line
 = 
NULL
;

36 
	`sig_handler
();

37 
fd
 = 
	`open
(
doc
, 
O_WRONLY
 | 
O_CREAT
 | 
O_TRUNC
, 0644);

38 if (
fd
 < 0)

40 
	`ft_dprintf
(2, "minishell: open: %s\n", 
	`strerror
(
errno
));

41 
	`exit
(0);

45 if (
line
)

47 
	`free
(
line
);

48 
line
 = 
NULL
;

50 
line
 = 
	`readline
(
MAG
"> "
RESET
);

51 if (!
line
)

53 else if (
	`ft_strncmp
(
line
, 
key_word
, 
	`ft_strlen
(key_word)) == 0)

55 
	`free
(
line
);

59 
	`ft_dprintf
(
fd
,"%s\n", 
line
);

61 
	`close
(
fd
);

62 
	`exit
(1);

63 
	}
}

66 int 
	$here_doc
(
t_cmd
 *
cmd
, char *
key_word
)

68 (void)
cmd
;

69 int 
pid
;

70 int 
status
;

72 if (
cmd
->
save_fdin
 != -1)

74 
	`dup2
(
cmd
->
save_fdin
, 
STDIN_FILENO
);

75 
	`close
(
cmd
->
save_fdin
);

76 
cmd
->
save_fdin
 = -1;

78 if (
cmd
->
ffd_in
 != -1)

80 
	`close
(
cmd
->
ffd_in
);

81 
cmd
->
ffd_in
 = -1;

83 
pid
 = 
	`fork
();

84 if (
pid
 == 0)

86 
	`child_process
(
key_word
);

90 
	`waitpid
(
pid
, &
status
, 0);

91 if (
	`WIFEXITED
(
status
) && 
	`WEXITSTATUS
(status) == 0)

93 
g_shell
->
exit_status
 = 1;

96 else if(
	`WIFSIGNALED
(
status
) && 
	`WTERMSIG
(status) == 
SIGINT
)

98 
g_shell
->
exit_status
 = 1;

101 else if(
	`WIFSIGNALED
(
status
) && 
	`WTERMSIG
(status) == 
SIGTERM
)

103 
g_shell
->
exit_status
 = 1;

107 
cmd
->
save_fdin
 = 
	`dup
(
STDIN_FILENO
);

108 
cmd
->
ffd_in
 = 
	`open
(".here_doc", 
O_RDONLY
);

109 if (
cmd
->
ffd_in
 < 0)

111 
	`ft_dprintf
(2, "minishell: open: %s\n", 
	`strerror
(
errno
));

112 
g_shell
->
exit_status
 = 1;

113 return (
ERROR_EXIT
);

115 
	`dup2
(
cmd
->
ffd_in
, 
STDIN_FILENO
);

116 
	`close
(
cmd
->
ffd_in
);

117 
cmd
->
ffd_in
 = -1;

119 
	}
}

	@redirections/make_redirection.c

12 #include 
	~"minishell.h
"

14 void 
	$restaure_fds
(
t_cmd
 *
cmd
)

16 if (
cmd
->
save_fdout
 != -1)

18 
	`dup2
(
cmd
->
save_fdout
, 
STDOUT_FILENO
);

19 
	`close
(
cmd
->
save_fdout
);

20 
cmd
->
save_fdout
 = -1;

22 if (
cmd
->
save_fdin
 != -1)

24 
	`dup2
(
cmd
->
save_fdin
, 
STDIN_FILENO
);

25 
	`close
(
cmd
->
save_fdin
);

26 
cmd
->
save_fdin
 = -1;

28 if (
	`access
(".here_doc", 
F_OK
) == 0)

30 
	`unlink
(".here_doc");

34 
	}
}

36 int 
	$make_redirections
(
t_cmd
 *
cmd
)

38 int 
i
;

39 int 
res
;

41 
i
 = 0;

42 if (!
cmd
->
redir
)

44 while (
cmd
->
redir
[
i
])

46 if (
	`ft_strncmp
(
cmd
->
redir
[
i
], ">", 2) == 0 || \

47 
	`ft_strncmp
(
cmd
->
redir
[
i
], ">>", 3) == 0)

49 
res
 = 
	`redir_fdout
(
cmd
, cmd->
redir
[
i
], cmd->redir[i + 1]);

50 if (
res
 == 
ERROR_EXIT
)

51 return (
ERROR_EXIT
);

52 
i
++;

54 else if (
	`ft_strncmp
(
cmd
->
redir
[
i
], "<", 2) == 0)

56 
res
 = 
	`redir_fdin
(
cmd
, cmd->
redir
[
i
 + 1]);

57 if (
res
 == 
ERROR_EXIT
)

58 return (
ERROR_EXIT
);

59 
i
++;

61 else if (
	`ft_strncmp
(
cmd
->
redir
[
i
], "<<", 3) == 0)

63 
i
++;

64 
res
 = 
	`here_doc
(
cmd
, cmd->
redir
[
i
]);

65 if (
res
 == 
ERROR_EXIT
 || res == 0)

67 return (
ERROR_EXIT
);

71 
i
++;

73 return (
res
);

74 
	}
}

	@redirections/single_chevron.c

12 #include 
	~"minishell.h
"

14 int 
	$redir_fdin
(
t_cmd
 *
cmd
, char *
file_path
)

16 if (
cmd
->
save_fdin
 != -1)

18 
	`dup2
(
cmd
->
save_fdin
, 
STDIN_FILENO
);

19 
	`close
(
cmd
->
save_fdin
);

20 
cmd
->
save_fdin
 = -1;

22 if (
cmd
->
ffd_in
 != -1)

24 
	`close
(
cmd
->
ffd_in
);

25 
cmd
->
ffd_in
 = -1;

27 
cmd
->
save_fdin
 = 
	`dup
(
STDIN_FILENO
);

28 
cmd
->
ffd_in
 = 
	`open
(
file_path
, 
O_RDONLY
);

29 if (
cmd
->
ffd_in
 < 0)

31 
	`ft_dprintf
(2, "minishell: open: %s\n", 
	`strerror
(
errno
));

32 
g_shell
->
exit_status
 = 1;

33 return (
ERROR_EXIT
);

35 
	`dup2
(
cmd
->
ffd_in
, 
STDIN_FILENO
);

36 
	`close
(
cmd
->
ffd_in
);

37 
cmd
->
ffd_in
 = -1;

39 
	}
}

41 int 
	$redir_fdout
(
t_cmd
 *
cmd
, char *
redir_op
, char *
file_path
)

43 if (
cmd
->
save_fdout
 != -1)

45 
	`dup2
(
cmd
->
save_fdout
, 
STDOUT_FILENO
);

46 
	`close
(
cmd
->
save_fdout
);

48 if (
cmd
->
ffd_out
 != -1)

49 
	`close
(
cmd
->
ffd_out
);

50 
cmd
->
save_fdout
 = 
	`dup
(
STDOUT_FILENO
);

51 if (
	`ft_strlen
(
redir_op
) == 1)

52 
cmd
->
ffd_out
 = 
	`open
(
file_path
, 
O_WRONLY
 | 
O_CREAT
 | 
O_TRUNC
, 0644);

53 else if (
	`ft_strlen
(
redir_op
) == 2)

54 
cmd
->
ffd_out
 = 
	`open
(
file_path
, 
O_WRONLY
 | 
O_CREAT
 | 
O_APPEND
, 0644);

55 if (
cmd
->
ffd_out
 < 0)

57 
	`ft_dprintf
(2, "minishell: open: %s\n", 
	`strerror
(
errno
));

58 
g_shell
->
exit_status
 = 1;

59 return (
ERROR_EXIT
);

61 
	`dup2
(
cmd
->
ffd_out
, 
STDOUT_FILENO
);

62 
	`close
(
cmd
->
ffd_out
);

63 
cmd
->
ffd_out
 = -1;

65 
	}
}

	@sauvegarde/builtins.c

13 #include 
	~"minishell.h
"

15 int 
	$_pwd
(
t_cmd
 *
cmd
)

17 char *
cwd
;

18 (void)
cmd
;

22 
cwd
 = 
	`getcwd
(
NULL
, 0);

25 
	`ft_printf
("%s\n", 
cwd
);

26 
	`free
(
cwd
);

28 
	}
}

30 void 
	$print_echo
(char **
s
, int 
i
)

32 int 
size
;

34 
size
 = 
i
;

35 while (
s
[
size
])

36 
size
++;

37 if (
size
 == 
i
)

39 while (
s
[
i
])

41 
	`ft_printf
("%s", 
s
[
i
]);

42 if (
i
 != 
size
 - 1)

43 
	`ft_printf
(" ");

44 
i
++;

46 
	}
}

48 int 
	$_echo
(
t_cmd
 *
cmd
)

50 if (
	`ft_strncmp
(
cmd
->cmd[1], "-n", 3) != 0)

52 
	`print_echo
(
cmd
->cmd, 1);

53 
	`printf
("\n");

56 
	`print_echo
(
cmd
->cmd, 2);

58 
	}
}

60 int 
	$_env
(
t_env
 *
env
)

62 if (!
env
)

64 while (
env
 != 
NULL
)

66 
	`printf
("%s=", 
env
->
var_name
);

67 
	`printf
("%s\n", 
env
->
var_value
);

68 
env
 = env->
next
;

71 
	}
}

	@sauvegarde/cmd_is_bin.c

1 #include 
	~"minishell.h
"

4 void 
	$free_tab
(char **
table
)

6 int 
i
;

8 
i
 = 0;

9 while (
table
 && table[
i
])

10 
	`free
(
table
[
i
++]);

11 
	`free
(
table
);

12 
	}
}

14 int 
	$path_index
(
t_bin
 *
bin
, char **
table
)

16 int 
i
;

18 
i
 = 0;

19 
bin
->
path
 = 
NULL
;

20 while (
table
[
i
] != 0)

22 if (
	`ft_strncmp
("PATH=", 
table
[
i
], 5) == 0)

24 
bin
->
path
 = 
table
[
i
] + 5;

27 
i
++;

29 if (!
bin
->
path
)

32 
	}
}

35 int 
	$split_path
(
t_bin
 *
bin
)

37 char *
tmp
;

38 int 
j
;

40 
bin
->
splitted_path
 = 
	`ft_split
(bin->
path
, ':');

41 if (!
bin
->
splitted_path
)

43 
j
 = 0;

44 while (
bin
->
splitted_path
[
j
])

46 
tmp
 = 
	`ft_strjoin
(
bin
->
splitted_path
[
j
], "/");

47 if (!
bin
->
splitted_path
)

49 
	`free
(
bin
->
splitted_path
[
j
]);

50 
bin
->
splitted_path
[
j
] = 
tmp
;

51 
j
++;

54 
	}
}

57 int 
	$find_cmd_in_path
(
t_bin
 *
bin
, char *
token
)

59 int 
j
;

61 
j
 = 0;

62 while (
bin
->
splitted_path
[
j
])

64 
bin
->
cmd
 = 
	`ft_strjoin
(bin->
splitted_path
[
j
], 
token
);

65 if (!
bin
->
cmd
)

67 
bin
->
ok
 = 
	`access
(bin->
cmd
, 
F_OK
 & 
X_OK
);

68 if (
bin
->
ok
 == 0)

71 
j
++;

73 
	`free_tab
(
bin
->
splitted_path
);

74 if (
bin
->
ok
 == -1)

77 
	}
}

79 int 
	$cmd_is_bin
(
t_token
 *
token
, 
t_bin
 *
bin
)

81 if (!
	`path_index
(
bin
, 
g_shell
->
save_env
))

83 if (!
	`split_path
(
bin
))

85 if (!
	`find_cmd_in_path
(
bin
, 
token
->
content
))

88 
	}
}

	@sauvegarde/cmd_is_builtin.c

1 #include 
	~"minishell.h
"

5 int 
	$cmd_is_builtin
(
t_token
 *
token
)

7 if (
token
 && token->
id
 == 
WORD
)

9 if (
	`ft_strncmp
(
token
->
content
, "echo", 5) == 0)

11 else if (
	`ft_strncmp
(
token
->
content
, "cd", 3) == 0)

13 else if (
	`ft_strncmp
(
token
->
content
, "pwd", 4) == 0)

15 else if (
	`ft_strncmp
(
token
->
content
, "export", 7) == 0)

17 else if (
	`ft_strncmp
(
token
->
content
, "unset", 6) == 0)

19 else if (
	`ft_strncmp
(
token
->
content
, "env", 4) == 0)

21 else if (
	`ft_strncmp
(
token
->
content
, "exit", 5) == 0)

25 
	}
}

	@sauvegarde/complicated_split.c

13 #include 
	~"minishell.h
"

15 static int 
	$ft_n_words
(char *
str
, char 
c
, int 
count
)

17 while (*
str
)

19 if (*
str
 != 
c
)

21 if (*
str
 == '\'' && str++)

23 
count
++;

24 while (*
str
 && *str != '\'')

25 
str
++;

26 
str
++;

30 
count
++;

31 while (*
str
 && *str != 
c
)

32 
str
++;

36 
str
++;

38 return (
count
);

39 
	}
}

41 static int *
	$ft_len_strs
(char *
str
, char 
c
, int 
count
, int 
index
)

43 int *
len_strs
;

44 int 
len
;

46 
len_strs
 = 
	`malloc
(sizeof(int) * 
count
);

47 if (
len_strs
 == 0)

49 while (*
str
)

51 
len
 = 0;

52 if (*
str
 == '\'' && str++)

53 while (*
str
 != '\'' && ++
len
)

54 
str
++;

56 while (*
str
 && *str != 
c
 && ++
len
)

57 
str
++;

58 if (*
str
 == '\'')

59 
str
++;

60 if (*
str
 == 
c
)

61 
str
++;

62 
len_strs
[
index
++] = 
len
 + 1;

64 return (
len_strs
);

65 
	}
}

67 static char **
	$ft_free_split
(char **
dst
, 
size_t
 
i
)

69 
size_t
 
k
;

71 
k
 = 0;

72 while (
k
 < 
i
)

73 
	`free
(
dst
[
k
++]);

74 
	`free
(
dst
);

75 return (
NULL
);

76 
	}
}

78 static char **
	$ft_fill_big_table
(char *
src
, char 
c
, char **
dst
, int *
lens
)

80 int 
j
;

81 int 
count
;

83 
count
 = 0;

84 while (*
src
)

86 
dst
[
count
] = 
	`malloc
(sizeof(char) * 
lens
[count]);

87 if (
dst
[
count
] == 
NULL
)

88 return (
	`ft_free_split
(
dst
, 
count
));

89 
j
 = 0;

90 if (*
src
 == '\'' && src++)

91 while (*
src
 != '\'')

92 
dst
[
count
][
j
++] = *
src
++;

94 while (*
src
 && *src != 
c
)

95 
dst
[
count
][
j
++] = *
src
++;

96 
dst
[
count
++][
j
] = '\0';

97 if (*
src
 == '\'')

98 
src
++;

99 if (*
src
 == 
c
)

100 
src
++;

102 
dst
[
count
] = 
NULL
;

103 
	`free
(
lens
);

104 return (
dst
);

105 
	}
}

107 char **
	$ft_splitpath
(char *
s
, char 
c
)

109 char **
dst
;

110 int *
lens
;

111 int 
count
;

112 int 
index
;

114 
index
 = 0;

115 
count
 = 
	`ft_n_words
(
s
, 
c
, 0);

116 
lens
 = 
	`ft_len_strs
(
s
, 
c
, 
count
, 
index
);

117 
dst
 = 
	`malloc
(sizeof(char *) * (
count
 + 1));

118 if (
dst
 == 
NULL
)

119 return (
NULL
);

120 return (
	`ft_fill_big_table
(
s
, 
c
, 
dst
, 
lens
));

121 
	}
}

	@sauvegarde/copy_env_tab.c

12 #include 
	~"minishell.h
"

14 int 
	$column_size
(
t_env
 **
head
)

16 
t_env
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

29 char *
	$name_plus_value
(char *
name
, char *
value
)

31 char *
joined
;

32 int 
len_name
;

33 int 
len_value
;

34 int 
i
;

35 int 
j
;

37 
i
 = 0;

38 
j
 = 0;

39 
len_name
 = 
	`ft_strlen
(
name
);

40 
len_value
 = 
	`ft_strlen
(
value
);

41 
joined
 = 
	`malloc
(sizeof(char) * (
len_name
 + 
len_value
 + 2));

42 if (!
joined
)

43 return (
NULL
);

44 while (
i
 < 
len_name
)

45 
joined
[
i
++] = 
name
[
j
++];

46 
joined
[
i
] = '=';

47 
j
 = 0;

48 
i
++;

49 while (
j
 < 
len_value
)

50 
joined
[
i
++] = 
value
[
j
++];

51 
joined
[
i
] = '\0';

52 return (
joined
);

53 
	}
}

55 char **
	$copy_env_tab
(
t_env
 *
env
)

57 char **
res
;

58 int 
column
;

59 int 
i
;

61 
i
 = 0;

62 
column
 = 
	`column_size
(&
env
);

63 
res
 = 
	`malloc
(sizeof(char *) * (
column
 + 1));

64 if (!
res
)

65 return (
NULL
);

66 while (
env
)

68 
res
[
i
] = 
	`name_plus_value
(
env
->
var_name
, env->
var_value
);

69 if (!
res
[
i
])

70 return (
NULL
);

71 
i
++;

72 
env
 = env->
next
;

74 
res
[
i
] = 
NULL
;

76 return (
res
);

77 
	}
}

	@sauvegarde/environnement/envp_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_env
(
t_env
 **
head
)

16 
t_env
 *
ptr
;

17 
t_env
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
var_name
);

27 
	`free
(
tmp
->
var_value
);

28 
	`free
(
tmp
);

30 *
head
 = 
NULL
;

31 
	}
}

40 
t_env
 *
	$new_env
(char *
envp
)

42 
t_env
 *
env
;

43 int 
end
;

44 int 
start
;

46 if (!
envp
)

47 return (
NULL
);

48 
start
 = 0;

49 
end
 = 0;

50 
env
 = 
	`malloc
(sizeof(
t_env
));

51 if (!
env
)

52 return (
	`malloc_error_print_message
(
	`strerror
(
errno
)), 
NULL
);

53 while (
envp
[
end
] != '=')

54 
end
++;

55 
env
->
var_name
 = 
	`ft_substr
(
envp
, 0, 
end
);

56 if (!
env
->
var_name
)

57 return (
NULL
);

58 
end
++;

59 
start
 = 
end
;

60 while (
envp
[
end
] != '\0')

61 
end
++;

62 
env
->
var_value
 = 
	`ft_substr
(
envp
, 
start
, 
end
 - start);

63 if (!
env
->
var_value
)

64 return (
	`malloc_error_print_message
("ft stubstr failed"), 
NULL
);

65 
env
->
next
 = 
NULL
;

66 return (
env
);

67 
	}
}

72 int 
	$link_env
(
t_env
 **
head
, t_env *
last
)

74 
t_env
 *
ptr
;

76 if (!
last
)

78 
ptr
 = *
head
;

79 while (
ptr
)

81 if (!
ptr
->
next
)

83 
ptr
 = ptr->
next
;

85 
ptr
->
next
 = 
last
;

87 
	}
}

96 
t_env
 *
	$get_envp
(char **
envp
)

98 
t_env
 **
head
;

99 
t_env
 *
env
;

100 int 
i
;

102 
i
 = 0;

103 
head
 = 
NULL
;

104 if (!
envp
)

105 return (
NULL
);

106 
env
 = 
	`new_env
(
envp
[
i
]);

107 if (!
env
)

108 return (
NULL
);

109 
head
 = &
env
;

110 
i
++;

111 while (
envp
[
i
])

113 if (
	`link_env
(
head
, 
	`new_env
(
envp
[
i
])) < 0)

114 return (
	`free_env
(
head
), 
NULL
);

115 
i
++;

117 return (*
head
);

118 
	}
}

	@sauvegarde/execution.c

12 #include 
	~"minishell.h
"

14 void 
	$execution_bin
(
t_cmd
 *
cmd
, 
t_bin
 *
bin
)

16 int 
status
;

17 int 
res
 = 0;

19 
status
 = 0;

20 
bin
->
child
 = 
	`fork
();

21 if (!
cmd
->cmd)

23 if (
bin
->
child
 < 0)

24 return (
	`perror
("Fork: "));

25 if (
bin
->
child
 == 0)

27 
res
 = 
	`execve
(
bin
->
cmd
, cmd->cmd, 
g_shell
->
save_env
);

28 if (
res
 < 0)

30 
	`ft_dprintf
(2, "minishell: %s\n", 
	`strerror
(
errno
));

31 
	`printf
("res = %d\n", 
res
);

32 
	`exit
(127);

34 
	`exit
 (0);

38 
	`waitpid
(
bin
->
child
, &
status
, 0);

39 
g_shell
->
exit_status
 = 
	`WEXITSTATUS
(
status
);

40 
	}
}

44 void 
	$builtin
(
t_bin
 *
bin
, 
t_cmd
 *
cmd
)

46 int 
status
;

47 int 
res
 = 0;

49 
status
 = 0;

50 
bin
->
child
 = 
	`fork
();

51 if (!
cmd
->cmd)

53 if (
bin
->
child
 < 0)

54 return (
	`perror
("Fork: "));

55 if (
bin
->
child
 == 0)

57 if (
	`ft_strncmp
(
cmd
->cmd[0], "pwd", 4) == 0 )

58 
	`_pwd
(
cmd
);

59 else if (
	`ft_strncmp
(
cmd
->cmd[0], "echo", 5) == 0)

60 
	`_echo
(
cmd
);

61 else if (
	`ft_strncmp
(
cmd
->cmd[0], "env", 4) == 0)

62 
	`_env
(
g_shell
->
env
);

63 else if (
	`ft_strncmp
(
cmd
->cmd[0], "exit", 5) == 0)

64 
	`exit
 (0);

65 if (
res
 < 0)

67 
	`ft_dprintf
(2, "minishell: %s\n", 
	`strerror
(
errno
));

68 
	`exit
(127);

70 
	`exit
 (0);

74 
	`waitpid
(
bin
->
child
, &
status
, 0);

75 
g_shell
->
exit_status
 = 
	`WEXITSTATUS
(
status
) % 256;

76 
	}
}

78 void 
	$check_then_execute
(
t_token
 *
token
, 
t_cmd
 **
cmd
)

80 
t_bin
 *
bin
;

81 
t_cmd
 *
ptr
;

83 
ptr
 = *
cmd
;

84 
bin
 = 
	`malloc
(sizeof(
t_bin
));

85 
g_shell
->
save_env
 = 
	`copy_env_tab
(g_shell->
env
);

86 if (
token
 && token->
id
 == 
WORD
)

88 if (
	`ft_strncmp
(
token
->
content
, "exit", 5) == 0)

90 
	`printf
("exit\n");

91 
	`exit
 (0);

93 else if (
	`cmd_is_builtin
(
token
) == 1)

95 
	`builtin
(
bin
, *
cmd
);

98 else if (
	`cmd_is_bin
(
token
, 
bin
))

100 
	`execution_bin
(*
cmd
, 
bin
);

106 
	}
}

	@sauvegarde/execution_test/cmd_is_bin.c

1 #include 
	~"minishell.h
"

4 void 
	$free_tab
(char **
table
)

6 int 
i
;

8 
i
 = 0;

9 while (
table
 && table[
i
])

10 
	`free
(
table
[
i
++]);

11 
	`free
(
table
);

12 
	}
}

14 int 
	$path_index
(
t_bin
 *
bin
, char **
table
)

16 int 
i
;

18 
i
 = 0;

19 
bin
->
path
 = 
NULL
;

20 while (
table
[
i
] != 0)

22 if (
	`ft_strncmp
("PATH=", 
table
[
i
], 5) == 0)

24 
bin
->
path
 = 
table
[
i
] + 5;

27 
i
++;

29 if (!
bin
->
path
)

32 
	}
}

35 int 
	$split_path
(
t_bin
 *
bin
)

37 char *
tmp
;

38 int 
j
;

40 
bin
->
splitted_path
 = 
	`ft_split
(bin->
path
, ':');

41 if (!
bin
->
splitted_path
)

43 
j
 = 0;

44 while (
bin
->
splitted_path
[
j
])

46 
tmp
 = 
	`ft_strjoin
(
bin
->
splitted_path
[
j
], "/");

47 if (!
bin
->
splitted_path
)

49 
	`free
(
bin
->
splitted_path
[
j
]);

50 
bin
->
splitted_path
[
j
] = 
tmp
;

51 
j
++;

54 
	}
}

57 int 
	$find_cmd_in_path
(
t_bin
 *
bin
, char *
token
)

59 int 
j
;

61 
j
 = 0;

62 while (
bin
->
splitted_path
[
j
])

64 
bin
->
cmd
 = 
	`ft_strjoin
(bin->
splitted_path
[
j
], 
token
);

65 if (!
bin
->
cmd
)

67 
bin
->
ok
 = 
	`access
(bin->
cmd
, 
F_OK
 & 
X_OK
);

68 if (
bin
->
ok
 == 0)

71 
j
++;

73 
	`free_tab
(
bin
->
splitted_path
);

74 if (
bin
->
ok
 == -1)

77 
	}
}

79 int 
	$cmd_is_bin
(
t_token
 *
token
, 
t_bin
 *
bin
)

81 if (!
	`path_index
(
bin
, 
g_shell
->
save_env
))

83 if (!
	`split_path
(
bin
))

85 if (!
	`find_cmd_in_path
(
bin
, 
token
->
content
))

88 
	}
}

	@sauvegarde/execution_test/copy_env_tab.c

12 #include 
	~"minishell.h
"

14 int 
	$column_size
(
t_env
 **
head
)

16 
t_env
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

29 char *
	$name_plus_value
(char *
name
, char *
value
)

31 char *
joined
;

32 int 
len_name
;

33 int 
len_value
;

34 int 
i
;

35 int 
j
;

37 
i
 = 0;

38 
j
 = 0;

39 
len_name
 = 
	`ft_strlen
(
name
);

40 
len_value
 = 
	`ft_strlen
(
value
);

41 
joined
 = 
	`malloc
(sizeof(char) * (
len_name
 + 
len_value
 + 2));

42 if (!
joined
)

43 return (
NULL
);

44 while (
i
 < 
len_name
)

45 
joined
[
i
++] = 
name
[
j
++];

46 
joined
[
i
] = '=';

47 
j
 = 0;

48 
i
++;

49 while (
j
 < 
len_value
)

50 
joined
[
i
++] = 
value
[
j
++];

51 
joined
[
i
] = '\0';

52 return (
joined
);

53 
	}
}

55 char **
	$copy_env_tab
(
t_env
 *
env
)

57 char **
res
;

58 int 
column
;

59 int 
i
;

61 
i
 = 0;

62 
column
 = 
	`column_size
(&
env
);

63 
res
 = 
	`malloc
(sizeof(char *) * (
column
 + 1));

64 if (!
res
)

65 return (
NULL
);

66 while (
env
)

68 
res
[
i
] = 
	`name_plus_value
(
env
->
var_name
, env->
var_value
);

69 if (!
res
[
i
])

70 return (
NULL
);

71 
i
++;

72 
env
 = env->
next
;

74 
res
[
i
] = 
NULL
;

76 return (
res
);

77 
	}
}

	@sauvegarde/execution_test/envp_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_env
(
t_env
 **
head
)

16 
t_env
 *
ptr
;

17 
t_env
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
var_name
);

27 
	`free
(
tmp
->
var_value
);

28 
	`free
(
tmp
);

30 *
head
 = 
NULL
;

31 
	}
}

40 
t_env
 *
	$new_env
(char *
envp
)

42 
t_env
 *
env
;

43 int 
end
;

44 int 
start
;

46 if (!
envp
)

47 return (
NULL
);

48 
start
 = 0;

49 
end
 = 0;

50 
env
 = 
	`malloc
(sizeof(
t_env
));

51 if (!
env
)

52 return (
	`malloc_error_print_message
(
	`strerror
(
errno
)), 
NULL
);

53 while (
envp
[
end
] != '=')

54 
end
++;

55 
env
->
var_name
 = 
	`ft_substr
(
envp
, 0, 
end
);

56 if (!
env
->
var_name
)

57 return (
NULL
);

58 
end
++;

59 
start
 = 
end
;

60 while (
envp
[
end
] != '\0')

61 
end
++;

62 
env
->
var_value
 = 
	`ft_substr
(
envp
, 
start
, 
end
 - start);

63 if (!
env
->
var_value
)

64 return (
	`malloc_error_print_message
("ft stubstr failed"), 
NULL
);

65 
env
->
next
 = 
NULL
;

66 return (
env
);

67 
	}
}

72 int 
	$link_env
(
t_env
 **
head
, t_env *
last
)

74 
t_env
 *
ptr
;

76 if (!
last
)

78 
ptr
 = *
head
;

79 while (
ptr
)

81 if (!
ptr
->
next
)

83 
ptr
 = ptr->
next
;

85 
ptr
->
next
 = 
last
;

87 
	}
}

100 
t_env
 *
	$get_envp
(char **
envp
)

102 
t_env
 **
head
;

103 
t_env
 *
env
;

104 int 
i
;

106 
i
 = 0;

107 
head
 = 
NULL
;

108 if (!
envp
)

109 return (
NULL
);

110 
env
 = 
	`new_env
(
envp
[
i
]);

111 if (!
env
)

112 return (
NULL
);

113 
head
 = &
env
;

114 
i
++;

115 while (
envp
[
i
])

117 if (
	`link_env
(
head
, 
	`new_env
(
envp
[
i
])) < 0)

118 return (
	`free_env
(
head
), 
NULL
);

119 
i
++;

121 return (*
head
);

122 
	}
}

	@sauvegarde/execution_test/execution.c

1 #include 
	~"minishell.h
"

3 void 
	$exec_bin
(
t_token
 *
token
, 
t_bin
 *
bin
)

5 int 
status
;

7 char **
test
;

8 (void)
token
;

9 
test
 = 
	`malloc
(sizeof(char *) * 3);

10 
test
[0] = 
	`ft_strdup
("ls");

11 
test
[1] = 
	`ft_strdup
("-la");

12 
test
[2] = 
NULL
;

14 
bin
->
child
 = 
	`fork
();

15 if (
bin
->
child
 < 0)

16 return (
	`perror
("Fork: "));

17 if (
bin
->
child
 == 0)

19 
	`printf
("cmd = %s\n", 
bin
->
cmd
);

20 int 
res
 = 0;

21 
res
 = 
	`execve
(
bin
->
cmd
, 
test
 , 
g_shell
->
save_env
);

22 
	`printf
("res = %d\n", 
res
);

26 
	`waitpid
(
bin
->
child
, &
status
, 0);

27 
	}
}

29 void 
	$check_then_execute
(
t_token
 *
token
)

31 
t_bin
 *
bin
;

33 
bin
 = 
	`malloc
(sizeof(
t_bin
));

34 
g_shell
->
save_env
 = 
	`copy_env_tab
(g_shell->
env
);

35 if (
token
 && token->
id
 == 
WORD
)

37 if (
	`cmd_is_bin
(
token
, 
bin
))

38 
	`exec_bin
(
token
, 
bin
);

44 
	}
}

	@sauvegarde/execution_test/handler_ctr_c.c

12 #include 
	~"minishell.h
"

14 void 
	$handler_ctr_c
(int 
code
)

16 (void)
code
;

17 
	`printf
("\n");

18 
	`rl_replace_line
("", 0);

19 
	`rl_on_new_line
();

20 
	`rl_redisplay
();

21 
g_shell
->
exit_status
 = 1;

22 
	}
}

	@sauvegarde/execution_test/is_dollar.c

12 #include 
	~"minishell.h
"

16 int 
	$is_dollar
(char 
c
)

18 if (
c
 == '$')

21 
	}
}

	@sauvegarde/execution_test/is_operator.c

12 #include 
	~"minishell.h
"

16 int 
	$is_pipeline
(char 
c
)

18 if (
c
 == '|')

21 
	}
}

25 int 
	$is_lchevron
(char 
c
)

27 if (
c
 == '<')

30 
	}
}

32 int 
	$is_rchevron
(char 
c
)

34 if (
c
 == '>')

37 
	}
}

39 int 
	$is_chevron
(char 
c
)

41 if (
	`is_lchevron
(
c
) || 
	`is_rchevron
(c))

44 
	}
}

48 int 
	$is_operator
(char 
c
)

50 if (
	`is_pipeline
(
c
) || 
	`is_chevron
(c))

53 
	}
}

	@sauvegarde/execution_test/is_question.c

12 #include 
	~"minishell.h
"

14 int 
	$is_question
(char 
c
)

16 if (
c
 == '?')

19 
	}
}

21 int 
	$is_punct
(char 
c
)

23 if ((
c
 >= 33 && c <= 47) || \

24 (
c
 >= 58 && c <= 64) || \

25 (
c
 >= 91 && c <= 94) || \

26 (
c
 == 96) || \

27 (
c
 >= 123 && c <= 126))

30 
	}
}

	@sauvegarde/execution_test/is_quote.c

12 #include 
	~"minishell.h
"

16 int 
	$is_double_quote
(char 
c
)

18 if (
c
 == '\"')

21 
	}
}

23 int 
	$is_simple_quote
(char 
c
)

25 if (
c
 == '\'')

28 
	}
}

30 int 
	$is_quote
(char 
c
)

32 if (
	`is_double_quote
(
c
) || 
	`is_simple_quote
(c))

35 
	}
}

	@sauvegarde/execution_test/is_token.c

12 #include 
	~"minishell.h
"

16 int 
	$is_metacharacter
(char 
c
)

18 if (
	`is_blank
(
c
) || 
	`is_newline
(c) || 
	`is_operator
(c))

21 
	}
}

25 int 
	$is_delimiter
(char 
c
)

27 if (
	`is_metacharacter
(
c
))

30 
	}
}

34 int 
	$is_word
(char 
c
)

36 if (!
	`is_delimiter
(
c
))

39 
	}
}

	@sauvegarde/execution_test/is_white_space.c

12 #include 
	~"minishell.h
"

14 int 
	$is_blank
(char 
c
)

16 if (
c
 == ' ' || c == '\t')

19 
	}
}

21 int 
	$is_newline
(char 
c
)

23 if (
c
 == '\n')

26 
	}
}

28 int 
	$is_white_space
(char 
c
)

30 if (
	`is_blank
(
c
) || 
	`is_newline
(c))

33 
	}
}

	@sauvegarde/execution_test/launch_setup.c

12 #include 
	~"minishell.h
"

24 int 
	$sig_handler
(void)

26 
	`signal
(
SIGINT
, 
handler_ctr_c
);

27 
	`signal
(
SIGQUIT
, 
SIG_IGN
);

29 
	}
}

	@sauvegarde/execution_test/libft/ft_printf/ft_count_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_int
(int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

	@sauvegarde/execution_test/libft/ft_printf/ft_count_unsigned_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_unsigned_int
(unsigned int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 else if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 return (
count
);

30 
	}
}

	@sauvegarde/execution_test/libft/ft_printf/ft_dprintf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 
fd
, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 
fd
, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 
fd
, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 
fd
, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 
fd
, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_dprintf
(int 
fd
, const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 
fd
, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 
fd
, &
count
);

50 
	`ft_format_specifier_fd
(
last
[
i
 + 1], 
ap
, &
count
, 
fd
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@sauvegarde/execution_test/libft/ft_printf/ft_printf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier
(char 
format
, 
va_list
 
ap
, int *
count
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 1, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 1, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 1, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 1, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 1, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 1, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 1, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_printf
(const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 1, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 1, &
count
);

50 
	`ft_format_specifier
(
last
[
i
 + 1], 
ap
, &
count
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@sauvegarde/execution_test/libft/ft_printf/ft_printf_address.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
);

16 void 
	$ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
)

18 
	`ft_printf_str
("0x", 
fd
, 
count
);

19 
	`ft_put_uintptr_fd
(
n
, 
fd
, 
count
);

20 
	}
}

22 void 
	$ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
)

24 if (
n
 > 15)

26 
	`ft_put_uintptr_fd
(
n
 / 16, 
fd
, 
count
);

27 
	`ft_put_uintptr_fd
(
n
 % 16, 
fd
, 
count
);

29 if (
n
 < 10)

30 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

31 else if (
n
 > 9 && n < 16)

32 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

33 
	}
}

	@sauvegarde/execution_test/libft/ft_printf/ft_printf_char.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_char
(char 
c
, int 
fd
, int *
count
)

16 
	`ft_putchar_fd
(
c
, 
fd
);

17 *
count
 += 1;

18 
	}
}

	@sauvegarde/execution_test/libft/ft_printf/ft_printf_hexa.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
)

16 if (
n
 > 15)

18 
	`ft_printf_hexa
(
n
 / 16, 
fd
, 
count
, 
c
);

19 
	`ft_printf_hexa
(
n
 % 16, 
fd
, 
count
, 
c
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

25 if (
c
 == 'x')

26 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

27 else if (
c
 == 'X')

28 
	`ft_printf_char
(
n
 + 55, 
fd
, 
count
);

30 
	}
}

	@sauvegarde/execution_test/libft/ft_printf/ft_printf_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_int
(int 
n
, int 
fd
, int *
count
)

16 
	`ft_putnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_int
(
n
);

18 
	}
}

	@sauvegarde/execution_test/libft/ft_printf/ft_printf_str.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_str
(char *
s
, int 
fd
, int *
count
)

16 int 
i
;

18 
i
 = 0;

19 if (
s
 != 
NULL
)

21 while (
s
[
i
] != '\0')

22 
i
++;

23 
	`ft_putstr_fd
(
s
, 
fd
);

27 
	`ft_putstr_fd
("(null)", 1);

28 
i
 = 6;

30 *
count
 += 
i
;

31 
	}
}

	@sauvegarde/execution_test/libft/ft_printf/ft_printf_unsint.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
)

16 
	`ft_put_unsnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_unsigned_int
(
n
);

18 
	}
}

	@sauvegarde/execution_test/libft/ft_printf/ft_put_hexanbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_hexanbr_fd
(unsigned int 
n
, int 
fd
, int *
count
)

16 if (
n
 > 15)

18 
	`ft_put_hexanbr_fd
(
n
 / 16, 
fd
, 
count
);

19 
	`ft_put_hexanbr_fd
(
n
 % 16, 
fd
, 
count
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

24 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

25 
	}
}

	@sauvegarde/execution_test/libft/ft_printf/ft_put_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_put_int
(int 
n
, int 
fd
, int *
count
)

16 int 
a
;

18 
a
 = *
count
;

19 
	`ft_putnbr_fd
(
n
, 
fd
);

20 
a
 += 
	`ft_count_int
(
n
);

21 return (
a
);

22 
	}
}

	@sauvegarde/execution_test/libft/ft_printf/ft_put_unsnbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
)

16 if (
n
 > 9)

18 
	`ft_put_unsnbr_fd
(
n
 / 10, 
fd
);

19 
	`ft_put_unsnbr_fd
((
n
 % 10), 
fd
);

22 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

23 
	}
}

	@sauvegarde/execution_test/libft/get_next_line/get_next_line.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$create_nextline
(char *
result
, char *
line
)

16 int 
start
;

17 int 
size
;

18 char *
nextline
;

20 
start
 = 
	`ft_strlen_int
(
result
);

21 
size
 = 
	`ft_strlen_int
(
line
);

22 
size
 = size - 
start
;

23 if (
size
 == 0)

25 
	`free
 (
line
);

26 return (
NULL
);

28 
nextline
 = 
	`malloc
((
size
 + 1) * sizeof(char));

29 if (!
nextline
)

30 return (
NULL
);

31 
size
 = 0;

32 while (
line
[
start
] != '\0')

34 
nextline
[
size
] = 
line
[
start
];

35 
size
++;

36 
start
++;

38 
nextline
[
size
] = '\0';

39 
	`free
(
line
);

40 return (
nextline
);

41 
	}
}

55 char *
	$create_result
(char *
line
)

57 int 
i
;

58 char *
result
;

60 
i
 = 
	`there_is_n
(
line
);

61 if (
i
 == -1 && *
line
)

62 
i
 = 
	`ft_strlen_int
(
line
);

63 else if (
i
 == -1 && !*
line
)

64 return (
NULL
);

65 
result
 = 
	`malloc
((
i
 + 1) * sizeof(char));

66 if (!
result
)

67 return (
NULL
);

68 
i
 = 0;

69 while (
line
[
i
] != '\0')

71 
result
[
i
] = 
line
[i];

72 if (
line
[
i
] == '\n')

74 
i
++;

77 
i
++;

79 
result
[
i
] = '\0';

80 return (
result
);

81 
	}
}

94 char *
	$read_fd
(char *
line
, int 
fd
, int *
error
)

96 char *
buffer
;

97 int 
ret
;

99 
ret
 = 1;

100 
	`prepare_forstash
(&
line
, &
buffer
);

101 while (
ret
 > 0 && 
	`there_is_n
(
buffer
) == -1 && there_is_n(
line
) == -1)

103 
ret
 = (int)
	`read
(
fd
, 
buffer
, 
BUFFER_SIZE
);

104 if (
ret
 < 0)

106 
	`free
(
buffer
);

107 *
error
 = -1;

108 return (
NULL
);

110 if (
ret
 == 0)

112 *
error
 = 0;

115 
buffer
[
ret
] = '\0';

116 
line
 = 
	`ft_join
(line, 
buffer
);

118 
	`free
(
buffer
);

119 return (
line
);

120 
	}
}

130 int 
	$check_errors
(int 
fd
, char **
line
)

132 if (
fd
 < 0 || 
BUFFER_SIZE
 <= 0 || 
	`read
(fd, 0, 0) < 0)

134 
	`free
(*
line
);

135 *
line
 = 0;

139 
	}
}

150 char *
	$get_next_line
(int 
fd
)

152 static char *
line
;

153 char *
result
;

154 int 
error
;

156 
error
 = 
	`check_errors
(
fd
, &
line
);

157 if (
error
 == 0)

158 return (
NULL
);

159 
line
 = 
	`read_fd
(line, 
fd
, &
error
);

160 if (
error
 == -1 || (error == 0 && !*
line
))

162 
	`free
(
line
);

163 
line
 = 0;

164 return (
NULL
);

166 if (!
line
)

167 return (
NULL
);

168 
result
 = 
	`create_result
(
line
);

169 if (!
result
)

171 
line
 = 0;

172 
	`free
(
line
);

174 
line
 = 
	`create_nextline
(
result
, line);

175 return (
result
);

176 
	}
}

	@sauvegarde/execution_test/libft/get_next_line/get_next_line_bonus.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$get_next_line_maxopen
(int 
fd
)

16 static char *
line
[
OPEN_MAX
];

17 char *
result
;

18 int 
error
;

20 
error
 = 
	`check_errors
(
fd
, &
line
[fd]);

21 if (
error
 == 0)

22 return (
NULL
);

23 
line
[
fd
] = 
	`read_fd
(line[fd], fd, &
error
);

24 if (
error
 == -1 || (error == 0 && !*
line
[
fd
]))

26 
	`free
(
line
[
fd
]);

27 
line
[
fd
] = 0;

28 return (
NULL
);

30 if (!
line
[
fd
])

31 return (
NULL
);

32 
result
 = 
	`create_result
(
line
[
fd
]);

33 if (!
result
)

35 
line
[
fd
] = 0;

36 
	`free
(
line
[
fd
]);

38 
line
[
fd
] = 
	`create_nextline
(
result
, line[fd]);

39 return (
result
);

40 
	}
}

	@sauvegarde/execution_test/libft/get_next_line/get_next_line_utils.c

12 #include 
	~"../includes/get_next_line.h
"

14 void 
	$prepare_forstash
(char **
line
, char **
buffer
)

16 *
buffer
 = 
	`ft_calloc_count
(
BUFFER_SIZE
);

17 if (*
line
 == 
NULL
)

18 *
line
 = 
	`ft_calloc_count
(0);

19 
	}
}

21 char *
	$ft_join
(char *
line
, char *
buffer
)

23 int 
i
;

24 int 
j
;

25 char *
stash
;

27 if (!
line
 || !
buffer
)

28 return (
NULL
);

29 
i
 = 
	`ft_strlen_int
(
line
);

30 
j
 = 
	`ft_strlen_int
(
buffer
);

31 
stash
 = 
	`malloc
((
i
 + 
j
 + 1) * sizeof(char));

32 if (!
stash
)

33 return (
NULL
);

34 
i
 = 0;

35 
j
 = 0;

36 while (
line
[
i
] != '\0')

38 
stash
[
i
] = 
line
[i];

39 
i
++;

41 while (
buffer
[
j
] != '\0')

42 
stash
[
i
++] = 
buffer
[
j
++];

43 
stash
[
i
] = '\0';

44 
	`free
(
line
);

45 return (
stash
);

46 
	}
}

48 char *
	$ft_calloc_count
(int 
count
)

50 char *
string
;

51 int 
i
;

53 
i
 = 0;

54 
string
 = 
	`malloc
((
count
 + 1) * sizeof(char));

55 if (!
string
)

56 return (
NULL
);

57 while (
i
 <= 
count
)

59 
string
[
i
] = '\0';

60 
i
++;

62 return (
string
);

63 
	}
}

65 int 
	$ft_strlen_int
(const char *
string
)

67 int 
i
;

69 
i
 = 0;

70 while (
string
[
i
] != '\0')

71 
i
++;

72 return (
i
);

73 
	}
}

75 int 
	$there_is_n
(char *
line
)

77 int 
i
;

79 
i
 = 0;

80 while (
line
[
i
] != '\0')

82 if (
line
[
i
] == '\n')

83 return (
i
 + 1);

84 
i
++;

87 
	}
}

	@sauvegarde/execution_test/libft/includes/ft_printf.h

12 #ifndef 
FT_PRINTF_H


13 #define 
	#FT_PRINTF_H


	)

15 #include 
	~"libft.h
"

16 #include 
	~<stdarg.h
>

18 int 
ft_printf
(const char *
last
, ...);

19 void 
ft_printf_char
(char 
c
, int 
fd
, int *
count
);

20 void 
ft_printf_str
(char *
s
, int 
fd
, int *
count
);

21 void 
ft_printf_int
(int 
n
, int 
fd
, int *
count
);

22 int 
ft_count_int
(int 
n
);

23 void 
ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
);

24 void 
ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
);

25 int 
ft_count_unsigned_int
(unsigned int 
n
);

26 void 
ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
);

27 void 
ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
);

31 void 
ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
);

32 int 
ft_dprintf
(int 
fd
, const char *
last
, ...);

	@sauvegarde/execution_test/libft/includes/get_next_line.h

12 #ifndef 
GET_NEXT_LINE_H


13 #define 
	#GET_NEXT_LINE_H


	)

15 #include 
	~<unistd.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<limits.h
>

19 #ifndef 
BUFFER_SIZE


20 #define 
	#BUFFER_SIZE
 42

	)

23 char *
ft_calloc_count
(int 
count
);

24 int 
ft_strlen_int
(const char *
string
);

25 char *
ft_join
(char *
nextline
, char *
buffer
);

26 int 
there_is_n
(char *
line
);

27 char *
read_fd
(char *
nextline
, int 
fd
, int *
error
);

28 char *
create_result
(char *
line
);

29 char *
create_nextline
(char *
result
, char *
line
);

30 char *
get_next_line
(int 
fd
);

31 char *
get_next_line_maxopen
(int 
fd
);

32 int 
check_errors
(int 
fd
, char **
line
);

33 void 
prepare_forstash
(char **
line
, char **
buffer
);

	@sauvegarde/execution_test/libft/includes/libft.h

12 #ifndef 
LIBFT_H


13 #define 
	#LIBFT_H


	)

15 #include 
	~<stddef.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<unistd.h
>

18 #include 
	~"ft_printf.h
"

19 #include 
	~"get_next_line.h
"

21 typedef struct 
	ss_list


23 void *
	mcontent
;

24 struct 
s_list
 *
	mnext
;

25 } 
	tt_list
;

27 void *
ft_memset
(void *
b
, int 
c
, 
size_t
 
len
);

28 void 
ft_bzero
(void *
s
, 
size_t
 
n
);

29 void *
ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
);

30 void *
ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
);

31 void *
ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
);

32 int 
ft_isalpha
(int 
c
);

33 int 
ft_isdigit
(int 
c
);

34 int 
ft_isalnum
(int 
c
);

35 int 
ft_isascii
(int 
c
);

36 int 
ft_isprint
(int 
c
);

37 
size_t
 
ft_strlen
(const char *
s
);

38 int 
ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
);

39 char *
ft_strcpy
(char *
dst
, const char *
src
);

40 
size_t
 
ft_strlcpy
(char *
dst
, const char *
src
, size_t 
dstsize
);

41 
size_t
 
ft_strlcat
(char *
dst
, const char *
src
, size_t 
dstsize
);

42 char *
ft_strchr
(const char *
s
, int 
c
);

43 char *
ft_strrchr
(const char *
s
, int 
c
);

44 char *
ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
);

45 int 
ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
);

46 int 
ft_toupper
(int 
c
);

47 int 
ft_tolower
(int 
c
);

48 int 
ft_atoi
(const char *
str
);

49 void *
ft_calloc
(
size_t
 
count
, size_t 
size
);

50 char *
ft_strdup
(const char *
s1
);

51 char *
ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
);

52 char *
ft_strjoin
(char const *
s1
, char const *
s2
);

53 char *
ft_strtrim
(char const *
s1
, char const *
set
);

54 char **
ft_split
(char const *
s
, char 
c
);

55 char *
ft_itoa
(int 
n
);

56 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char));

57 void 
	`ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*));

58 void 
	`ft_putchar_fd
(char 
c
, int 
fd
);

59 void 
	`ft_putstr_fd
(char *
s
, int 
fd
);

60 void 
	`ft_putendl_fd
(char *
s
, int 
fd
);

61 void 
	`ft_putnbr_fd
(int 
n
, int 
fd
);

64 
t_list
 *
	`ft_lstnew
(void *
content
);

65 void 
	`ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
);

66 int 
	`ft_lstsize
(
t_list
 *
lst
);

67 
t_list
 *
	`ft_lstlast
(t_list *
lst
);

68 void 
	`ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
);

69 void 
	`ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*));

70 void 
	`ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*));

71 void 
	`ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *));

72 
t_list
 *
	`ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *));

73 void 
	`delete_first_el
(
t_list
 **
a
);

74 void 
	`delete_last_el
(
t_list
 **
a
);

75 void 
	`del
(void *
content
);

78 int 
	`power
(int 
str_base
, int 
power
);

79 int 
	`ft_atoi_base
(const char *
str
, int 
str_base
);

80 int 
	`transform
(char 
c
);

81 
size_t
 
	`ft_strcspn
(const char *
s
, const char *
reject
);

82 char *
	`ft_strpbrk
(const char *
s1
, const char *
s2
);

83 
size_t
 
	`ft_strspn
(const char *
s
, const char *
accept
);

84 char *
	`str_lowercase
(char *
str
);

	@sauvegarde/execution_test/libft/libft/del.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$del
(void *
content
)

16 if (
content
)

17 
	`free
(
content
);

18 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_atoi.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_atoi
(const char *
str
)

16 int 
i
;

17 int 
result
;

18 int 
sign
;

20 
i
 = 0;

21 
result
 = 0;

22 
sign
 = 1;

23 while (
str
[
i
] == 32 || (str[i] >= 9 && str[i] <= 13))

24 
i
++;

25 if (
str
[
i
] == '-')

27 
sign
 *= (-1);

28 
i
++;

30 else if (
str
[
i
] == '+')

31 
i
++;

32 while (
str
[
i
] >= '0' && str[i] <= '9')

34 
result
 *= 10;

35 
result
 += 
str
[
i
] - 48;

36 
i
++;

38 return (
sign
 * 
result
);

39 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_atoi_base.c

12 #include 
	~"../includes/libft.h
"

13 #include 
	~"../includes/get_next_line.h
"

15 int 
	$transform
(char 
c
)

17 int 
i
;

18 char 
c2
;

20 
i
 = 10;

21 if (
c
 >= 'A' && c <= 'F')

22 
c2
 = 'A';

23 if (
c
 >= 'a' && c <= 'f')

24 
c2
 = 'a';

25 while (
c
 != 
c2
)

27 
c2
++;

28 
i
++;

30 return (
i
);

31 
	}
}

33 int 
	$ft_atoi_base
(const char *
str
, int 
str_base
)

35 int 
i
;

36 int 
count
;

37 int 
result
;

38 int 
sign
;

40 
i
 = 0;

41 
result
 = 0;

42 
count
 = 
	`ft_strlen_int
(
str
) - 1;

43 
sign
 = 1;

44 if (
str
[
i
] == '-')

46 
i
++;

47 
sign
 = -1;

48 
count
--;

50 while (
str
[
i
++] != 0)

52 if (
str
[
i
] >= '0' && str[i] <= '9')

53 
result
 = result + (
str
[
i
] - '0') * 
	`power
(
str_base
, 
count
);

54 if ((
str
[
i
] >= 'A' && str[i] <= 'F') || \

55 (
str
[
i
] >= 'a' && str[i] <= 'f'))

56 
result
 = result + 
	`transform
(
str
[
i
]) * 
	`power
(
str_base
, 
count
);

57 
count
--;

59 return (
result
 * 
sign
);

60 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_bzero.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_bzero
(void *
s
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (
n
 == 0)

21 while (
i
 < 
n
)

23 *(char *)(
s
 + 
i
) = 0;

24 
i
++;

26 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_calloc.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_calloc
(
size_t
 
count
, size_t 
size
)

16 void *
ptr
;

18 
ptr
 = (void *)
	`malloc
(
count
 * 
size
);

19 if (!
ptr
)

20 return (
NULL
);

21 
	`ft_bzero
(
ptr
, (
count
 * 
size
));

22 return (
ptr
);

23 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_isalnum.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalnum
(int 
c
)

16 if (
	`ft_isalpha
(
c
) == 1 || 
	`ft_isdigit
(c) == 1)

20 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_isalpha.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalpha
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

18 else if (
c
 >= 'a' && c <= 'z')

22 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_isascii.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isascii
(int 
c
)

16 if (
c
 >= 0 && c <= 127)

20 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_isdigit.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isdigit
(int 
c
)

16 if (
c
 >= '0' && c <= '9')

20 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_isprint.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isprint
(int 
c
)

16 if (
c
 >= 32 && c <= 126)

20 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_itoa.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbchar
(int 
n
)

16 
size_t
 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

41 char *
	$ft_nb_is_negative
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

43 int 
result
;

45 
result
 = 0;

46 if (
n
 == -2147483648)

48 
n
 = -214748364;

49 
itoa_str
[
nb_char
 - 1] = (char)(8 + 48);

50 
nb_char
--;

52 
n
 *= (-1);

53 while (
n
 > 0)

55 
result
 = (
n
 % 10);

56 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

57 
n
 = n / 10;

58 
nb_char
--;

60 
itoa_str
[--
nb_char
] = '-';

61 return (
itoa_str
);

62 
	}
}

64 char *
	$ft_nb_is_positive
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

66 int 
result
;

68 
result
 = 0;

69 while (
n
 > 0)

71 
result
 = 
n
 % 10;

72 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

73 
n
 = n / 10;

74 
nb_char
--;

76 return (
itoa_str
);

77 
	}
}

79 char *
	$ft_itoa
(int 
n
)

81 
size_t
 
nb_char
;

82 
size_t
 
buff
;

83 char *
itoa_str
;

85 
buff
 = 0;

86 
nb_char
 = 
	`ft_count_nbchar
(
n
);

87 
itoa_str
 = (char *)
	`ft_calloc
((
nb_char
 + 1), sizeof(char));

88 if (!
itoa_str
)

89 return (
NULL
);

90 while (
buff
 < 
nb_char
)

92 
itoa_str
[
buff
] = '0';

93 
buff
++;

95 if (
n
 == 0)

96 
itoa_str
[0] = (char)(0 + 48);

97 else if (
n
 < 0)

98 
itoa_str
 = 
	`ft_nb_is_negative
(
n
, itoa_str, 
nb_char
);

99 else if (
n
 > 0)

100 
itoa_str
 = 
	`ft_nb_is_positive
(
n
, itoa_str, 
nb_char
);

101 return (
itoa_str
);

102 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_lstadd_back.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
)

16 
t_list
 *
lstlast
;

18 if (*
lst
 == 
NULL
)

19 *
lst
 = 
new
;

20 else if (!
lst
 || !
new
)

24 
lstlast
 = 
	`ft_lstlast
(*
lst
);

25 
lstlast
->
next
 = 
new
;

27 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_lstadd_front.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
)

16 if (*
lst
 == 
NULL
)

18 
new
->
next
 = 
NULL
;

19 *
lst
 = 
new
;

21 else if (*
lst
 != 
NULL
)

23 
new
->
next
 = *
lst
;

24 *
lst
 = 
new
;

26 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_lstclear.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*))

16 
t_list
 *
temp
;

17 
t_list
 *
ptr
;

19 
ptr
 = *
lst
;

20 if (!
del
)

22 while (
ptr
 != 
NULL
)

24 
temp
 = 
ptr
->
next
;

25 
	`ft_lstdelone
(
ptr
, 
del
);

26 
ptr
 = 
temp
;

28 *
lst
 = 
NULL
;

29 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_lstdel_first_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_first_el
(
t_list
 **
a
)

16 
t_list
 *
tmp
;

18 
tmp
 = (*
a
)->
next
;

19 
	`free
 (*
a
);

20 *
a
 = 
tmp
;

21 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_lstdel_last_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_last_el
(
t_list
 **
a
)

16 
t_list
 *
end
;

17 
t_list
 *
prev
;

19 
end
 = *
a
;

20 
prev
 = 
NULL
;

21 while (
end
->
next
)

23 
prev
 = 
end
;

24 
end
 = end->
next
;

26 
prev
->
next
 = 
NULL
;

27 
	`free
 (
end
);

28 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_lstdelone.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*))

16 if (!
lst
 || !
del
)

18 
	`del
(
lst
->
content
);

19 
	`free
(
lst
);

20 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_lstiter.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *))

16 
t_list
 *
ptr
;

18 
ptr
 = 
lst
;

19 while (
ptr
 != 
NULL
)

21 
	`f
(
ptr
->
content
);

22 
ptr
 = ptr->
next
;

24 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_lstlast.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstlast
(
t_list
 *
lst
)

16 while (
lst
 != 
NULL
 && lst->
next
 != NULL)

18 
lst
 = lst->
next
;

20 return (
lst
);

21 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_lstmap.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *))

16 
t_list
 *
new_list
;

17 
t_list
 *
head
;

19 if (!
lst
 || !
f
)

20 return (
NULL
);

21 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

22 if (!
new_list
)

23 return (
NULL
);

24 
head
 = 
new_list
;

25 
lst
 = lst->
next
;

26 while (
lst
 != 
NULL
)

28 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

29 if (!
new_list
)

31 
	`ft_lstclear
(&
head
, 
del
);

32 return (
NULL
);

34 
	`ft_lstadd_back
(&
head
, 
new_list
);

35 
lst
 = lst->
next
;

37 return (
head
);

38 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_lstnew.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstnew
(void *
content
)

16 
t_list
 *
lstnew
;

18 
lstnew
 = (
t_list
 *)
	`malloc
(sizeof(t_list));

19 if (!
lstnew
)

20 return (
NULL
);

21 
lstnew
->
next
 = 
NULL
;

22 
lstnew
->
content
 = (void *)content;

23 return (
lstnew
);

24 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_lstsize.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_lstsize
(
t_list
 *
lst
)

16 int 
i
;

17 
t_list
 *
ptr
;

19 
i
 = 0;

20 
ptr
 = 
NULL
;

21 
ptr
 = 
lst
;

22 while (
ptr
 != 
NULL
)

24 
ptr
 = ptr->
next
;

25 
i
++;

27 return (
i
);

28 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_memchr.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s
 + 
i
) == (unsigned char) 
c
)

23 return ((unsigned char *)(
s
 + 
i
));

26 
i
++;

28 return (
NULL
);

29 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_memcmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s1
 + 
i
) != *(unsigned char *)(
s2
 + i))

23 return (*(unsigned char *)(
s1
 + 
i
) - *(unsigned char *)(
s2
 + i));

26 
i
++;

29 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_memcpy.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 while (
i
 < 
n
)

23 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

24 
i
++;

26 return (
dst
);

27 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_memmove.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 if (
dst
 > 
src
)

23 while (
len
--)

25 *(char *)(
dst
 + 
len
) = *(char *)(
src
 + len);

27 return (
dst
);

29 while (
i
 < 
len
)

31 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

32 
i
++;

34 return (
dst
);

35 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_memset.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memset
(void *
b
, int 
c
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
len
)

21 *(unsigned char *)(
b
 + 
i
) = (unsigned char)
c
;

22 
i
++;

24 return (
b
);

25 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_putchar_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putchar_fd
(char 
c
, int 
fd
)

16 
	`write
(
fd
, &
c
, 1);

17 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_putendl_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putendl_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

26 
	`write
(
fd
, "\n", 1);

28 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_putnbr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putnbr_fd
(int 
n
, int 
fd
)

16 if (
n
 == -2147483648)

18 
	`ft_putstr_fd
("-2147483648", 
fd
);

20 else if (
n
 < 0)

22 
	`ft_putchar_fd
('-', 
fd
);

23 
n
 = n * (-1);

24 
	`ft_putnbr_fd
(
n
, 
fd
);

26 else if (
n
 > 9)

28 
	`ft_putnbr_fd
(
n
 / 10, 
fd
);

29 
	`ft_putnbr_fd
((
n
 % 10), 
fd
);

32 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

33 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_putstr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putstr_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

27 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_split.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbsubstr
(const char *
s
, char 
c
)

16 unsigned int 
i
;

17 
size_t
 
count
;

19 
i
 = 0;

20 
count
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] != 
c
)

25 while (
s
[
i
] != 
c
 && s[i] != '\0')

26 
i
++;

27 
count
++;

29 while (
s
[
i
] == 
c
)

30 
i
++;

32 return (
count
);

33 
	}
}

35 unsigned int 
	$ft_start_index_substr
(char const *
s
, char 
c
, unsigned int 
start
)

37 while (
s
[
start
] == 
c
 && s[start] != '\0')

38 
start
++;

39 return (
start
);

40 
	}
}

42 unsigned int 
	$ft_nb_char_substr
(char const *
s
, char 
c
, unsigned int 
start
)

44 unsigned int 
nb_char_substr
;

46 
nb_char_substr
 = 0;

47 while (
s
[
start
] != 
c
 && s[start] != '\0')

49 
start
++;

50 
nb_char_substr
++;

52 return (
nb_char_substr
);

53 
	}
}

55 char *
ft_create_substr
(\

56 char const *
s
, char 
c
, unsigned int 
start
, unsigned int 
nb_char_substr
)

58 unsigned int 
	gi
;

59 char *
	gsubstr
;

61 
	gi
 = 0;

62 
	gsubstr
 = (char *)
ft_calloc
((
nb_char_substr
 + 1), sizeof(char));

63 if (!
	gsubstr
)

64 return (
	gNULL
);

65 while (
	gs
[
start
] != 
c
 && 
s
[start] != '\0' && 
i
 < 
nb_char_substr
)

66 
substr
[
i
++] = 
s
[
start
++];

67 return (
	gsubstr
);

70 char **
	$ft_split
(char const *
s
, char 
c
)

72 
size_t
 
nb_substr
;

73 
size_t
 
i
;

74 char **
tab2d
;

75 unsigned int 
start
;

76 unsigned int 
nb_char_substr
;

78 
i
 = 0;

79 
start
 = 0;

80 
nb_substr
 = 
	`ft_count_nbsubstr
(
s
, 
c
);

81 
tab2d
 = (char **)
	`ft_calloc
((
nb_substr
 + 1), sizeof(char *));

82 if (!
tab2d
)

83 return (
NULL
);

84 while (
s
[
start
] != '\0' && 
i
 < 
nb_substr
)

86 
start
 = 
	`ft_start_index_substr
(
s
, 
c
, start);

87 
nb_char_substr
 = 
	`ft_nb_char_substr
(
s
, 
c
, 
start
);

88 
tab2d
[
i
] = 
	`ft_create_substr
(
s
, 
c
, 
start
, 
nb_char_substr
);

89 
start
 = start + 
nb_char_substr
;

90 
i
++;

92 return (
tab2d
);

93 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_strchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strchr
(const char *
s
, int 
c
)

16 int 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 if ((char)
c
 == 
s
[
i
])

22 return ((char *)(
s
 + 
i
));

23 
i
++;

25 if ((char)
c
 == '\0')

26 return ((char *)(
s
 + 
i
));

28 return (
NULL
);

29 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_strcpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strcpy
(char *
dst
, const char *
src
)

16 int 
i
;

18 
i
 = 0;

19 while (
src
[
i
])

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 
dst
[
i
] = '\0';

25 return (
dst
);

26 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_strcspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strcspn
(const char *
s
, const char *
reject
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
])

21 if (
	`ft_strchr
(
reject
, 
s
[
i
]) != 
NULL
)

22 return (
i
);

23 
i
++;

25 return (
i
);

26 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_strdup.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strdup
(const char *
s1
)

16 int 
size
;

17 char *
s1_copie
;

19 
size
 = 
	`ft_strlen
(
s1
) + 1;

20 
s1_copie
 = (char *)
	`malloc
(
size
 * sizeof(char));

21 if (!
s1_copie
)

22 return (
NULL
);

23 
	`ft_strlcpy
(
s1_copie
, 
s1
, 
size
);

24 return (
s1_copie
);

25 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_striteri.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*))

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`f
(
i
, &
s
[i]);

24 
i
++;

27 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_strjoin.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strjoin
(char const *
s1
, char const *
s2
)

16 
size_t
 
size_s1
;

17 
size_t
 
size_s2
;

18 char *
strjoin
;

20 
size_s1
 = 
	`ft_strlen
(
s1
);

21 
size_s2
 = 
	`ft_strlen
(
s2
);

22 
strjoin
 = (char *)
	`malloc
((
size_s1
 + 
size_s2
 + 1) * sizeof(char));

23 if (!
strjoin
)

24 return (
NULL
);

25 
	`ft_memcpy
(
strjoin
, 
s1
, 
size_s1
);

26 
	`ft_memcpy
((
strjoin
 + 
size_s1
), 
s2
, 
size_s2
);

27 
	`ft_memset
((
strjoin
 + 
size_s1
 + 
size_s2
), 0, 1);

28 return (
strjoin
);

29 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_strlcat.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcat
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
strlen_src
;

18 
size_t
 
strlen_dst
;

19 
size_t
 
temp
;

21 
i
 = 0;

22 
strlen_src
 = 
	`ft_strlen
(
src
);

23 
strlen_dst
 = 
	`ft_strlen
(
dst
);

24 
temp
 = 
strlen_dst
;

25 if (
dstsize
 < 
strlen_dst
)

26 return (
dstsize
 + 
strlen_src
);

27 if (
dstsize
 > 
strlen_dst
 + 1)

29 while (
src
[
i
] && 
strlen_dst
 != (
dstsize
 - 1))

31 
dst
[
strlen_dst
++] = 
src
[
i
++];

33 
dst
[
strlen_dst
] = '\0';

35 return (
temp
 + 
strlen_src
);

36 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_strlcpy.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcpy
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
j
;

19 
i
 = 0;

20 
j
 = 0;

21 while (
src
[
i
] != '\0')

23 
i
++;

25 if (
dstsize
 > 0)

27 while (
j
 < (
dstsize
 - 1) && 
src
[j] != '\0')

29 
dst
[
j
] = 
src
[j];

30 
j
++;

32 
dst
[
j
] = '\0';

34 return (
i
);

35 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_strlen.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlen
(const char *
s
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 
i
++;

23 return (
i
);

24 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_strmapi.c

12 #include 
	~"../includes/libft.h
"

14 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char))

16 unsigned int 
i
;

17 
size_t
 
size
;

18 char *
strmapi
;

20 
i
 = 0;

21 
size
 = 
	`ft_strlen
(
s
);

22 
strmapi
 = (char *)
	`malloc
((
size
 + 1) * sizeof(char));

23 if (!
strmapi
)

24 return (
NULL
);

25 while (
s
[
i
] != '\0')

27 
strmapi
[
i
] = 
	`f
(i, 
s
[i]);

28 
i
++;

30 
strmapi
[
i
] = '\0';

31 return (
strmapi
);

32 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_strncmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (((unsigned char)
s1
[
i
] || (unsigned char)
s2
[i]) && i < 
n
)

21 if (
s1
[
i
] != 
s2
[i])

22 return ((unsigned char)
s1
[
i
] - (unsigned char)
s2
[i]);

23 
i
++;

26 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_strncpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strncpy
(char *
dst
, const char *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
src
[
i
] && i < 
len
)

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 while (
i
 < 
len
)

26 
dst
[
i
] = '\0';

27 
i
++;

29 return (
dst
);

30 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_strnstr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
)

16 
size_t
 
len_needle
;

17 
size_t
 
len_haystack
;

19 
len_needle
 = 
	`ft_strlen
(
needle
);

20 
len_haystack
 = 
	`ft_strlen
(
haystack
);

21 if (
needle
[0] == '\0')

22 return ((char *)(
haystack
));

23 if (
len_needle
 > 
len_haystack
 || 
len
 < len_needle)

24 return (
NULL
);

25 if (
len
 > 
len_haystack
)

26 
len
 = 
len_haystack
;

27 while (
len
 >= 
len_needle
 && 
haystack
)

29 if (
	`ft_memcmp
(
haystack
, 
needle
, 
len_needle
) == 0)

30 return ((char *)(
haystack
));

33 
haystack
++;

34 
len
--;

37 return (
NULL
);

38 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_strpbrk.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strpbrk
(const char *
s1
, const char *
s2
)

16 int 
i
;

18 
i
 = 0;

19 while (
s1
[
i
] != '\0')

21 if (
	`ft_strchr
(
s2
, 
s1
[
i
]) != 0)

23 return ((char *) &
s1
[
i
]);

25 ++
i
;

28 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_strrchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strrchr
(const char *
s
, int 
c
)

16 int 
i
;

17 int 
k
;

19 
i
 = 0;

20 
k
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] == (char)
c
)

24 
k
 = 
i
;

25 
i
++;

27 if (
s
[
k
] == (char)
c
)

28 return ((char *)(
s
 + 
k
));

29 else if ((char)
c
 == 
s
[
i
])

30 return ((char *)(
s
 + 
i
));

32 return (
NULL
);

33 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_strspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strspn
(const char *
s
, const char *
accept
)

16 
size_t
 
count
;

17 
size_t
 
i
;

19 
count
 = 0;

20 
i
 = 0;

21 while (
s
[
i
] && 
	`ft_strchr
(
accept
, s[i]) != 0)

23 
count
++;

24 
i
++;

26 return (
count
);

27 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_strtrim.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strtrim
(char const *
s1
, char const *
set
)

16 unsigned int 
front
;

17 unsigned int 
end
;

18 unsigned int 
i
;

19 char *
strtrim
;

21 
front
 = 0;

22 
i
 = 0;

23 
end
 = (unsigned int)(
	`ft_strlen
(
s1
));

24 while (
s1
[
front
] != '\0' && 
	`ft_strchr
(
set
, *(s1 + front)) != 
NULL
)

25 
front
++;

26 while (
front
 < 
end
 && 
	`ft_strrchr
(
set
, *(
s1
 + end - 1)) != 
NULL
)

27 
end
--;

28 
strtrim
 = (char *)
	`malloc
((
end
 - 
front
 + 1) * sizeof(char));

29 if (!
strtrim
)

30 return (
NULL
);

31 
i
 = 0;

32 while (
front
 < 
end
)

33 
strtrim
[
i
++] = 
s1
[
front
++];

34 
strtrim
[
i
] = 0;

35 return (
strtrim
);

36 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_substr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
)

16 char *
substr
;

17 unsigned int 
i
;

18 
size_t
 
size
;

20 
i
 = 0;

21 if (!
s
)

22 return (
NULL
);

23 
size
 = 
	`ft_strlen
(
s
);

24 if (
len
 > 
size
)

25 
len
 = 
size
;

26 if (
start
 >= (unsigned int)
size
)

28 
substr
 = (char *)
	`malloc
(1 * sizeof(char));

29 if (!
substr
)

30 return (
NULL
);

31 
substr
[0] = '\0';

32 return (
substr
);

34 
substr
 = (char *)
	`malloc
((
len
 + 1) * sizeof(char));

35 if (!
substr
)

36 return (
NULL
);

37 while (
i
 < (unsigned int)
len
 && 
s
[
start
] != '\0' )

38 
substr
[
i
++] = 
s
[
start
++];

39 
substr
[
i
] = '\0';

40 return (
substr
);

41 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_tolower.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_tolower
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

17 return (
c
 + 32);

19 return (
c
);

20 
	}
}

	@sauvegarde/execution_test/libft/libft/ft_toupper.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_toupper
(int 
c
)

16 if (
c
 >= 'a' && c <= 'z')

17 return (
c
 - 32);

19 return (
c
);

20 
	}
}

	@sauvegarde/execution_test/libft/libft/power.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$power
(int 
str_base
, int 
power
)

16 int 
result
;

18 
result
 = 1;

19 if (
power
 < 0 || 
str_base
 == 0)

23 while (
power
 > 0)

25 
result
 = result * 
str_base
;

26 
power
--;

28 return (
result
);

29 
	}
}

	@sauvegarde/execution_test/libft/libft/str_lowercase.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$str_lowercase
(char *
str
)

16 int 
i
;

18 
i
 = 0;

19 while (
str
[
i
])

21 if (
str
[
i
] >= 'A' && str[i] <= 'Z')

22 
str
[
i
] += 32;

23 
i
++;

25 return (
str
);

26 
	}
}

	@sauvegarde/execution_test/main.c

2 #include 
	~"minishell.h
"

4 
t_shell
 *
	gg_shell
;

10 void 
	$print_env
()

12 
t_env
 *
ptr
;

14 
ptr
 = 
g_shell
->
env
;

15 if (!
g_shell
 || !g_shell->
env
)

17 while (
g_shell
->
env
)

19 
	`ft_printf
("print_env function: %s\n", 
g_shell
->
env
->
var_name
);

20 
	`ft_printf
("print_env function: %s\n", 
g_shell
->
env
->
var_value
);

21 
g_shell
->
env
 = g_shell->env->
next
;

23 
g_shell
->
env
 = 
ptr
;

24 
	}
}

27 void 
	$free_shell
(void)

29 
	`free_env
(&
g_shell
->
env
);

31 if (
g_shell
)

32 
	`free
(
g_shell
);

33 
	}
}

35 int 
	$shell_no_env
()

37 
t_env
 *
env_no
;

38 
env_no
 = 
	`malloc
(sizeof(
t_env
));

39 if (!
env_no
)

41 
	`malloc_error_print_message
(
	`strerror
(
errno
));

44 
env_no
->
var_name
 = 
	`ft_strdup
("SHLVL");

45 
env_no
->
var_value
 = 
	`ft_strdup
("1");

46 
env_no
->
next
 = 
NULL
;

47 
g_shell
->
env
 = 
env_no
;

50 
	}
}

52 int 
	$init_shell
(char **
envp
)

54 
g_shell
 = 
	`ft_calloc
(1, sizeof(
t_shell
));

55 if (!
g_shell
)

57 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

60 if (!*
envp
)

62 if (!
	`shell_no_env
())

67 
g_shell
->
env
 = 
	`get_envp
(
envp
);

68 if (!
g_shell
->
env
)

69 return (
	`free_shell
(), 0);

71 
g_shell
->
exit_status
 = 0;

75 
	}
}

78 int 
	$main
(int 
ac
, char **
av
, char **
envp
)

80 (void)
av
;

81 (void)
ac
;

82 char *
line
;

83 
t_token
 *
token
;

85 if (!
	`init_shell
(
envp
))

87 if (
	`sig_handler
() == -1)

91 
line
 = 
NULL
;

92 
line
 = 
	`readline
(
BLU_2
"minishell$ "
RESET
);

93 if (!
line
)

95 
	`rl_clear_history
();

98 if (
line
[0])

99 
	`add_history
(
line
);

102 
token
 = 
	`parsing
(
line
);

104 
	`check_then_execute
(
token
);

105 
g_shell
->
exit_status
 = 0;

106 
	`free_token
(&
token
);

108 
	`free_shell
();

110 
	}
}

	@sauvegarde/execution_test/malloc_error_print_message.c

12 #include 
	~"minishell.h
"

14 void 
	$malloc_error_print_message
(char *
s
)

16 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
s
);

17 
g_shell
->
exit_status
 = 1;

18 
	}
}

	@sauvegarde/execution_test/minishell.h

13 #ifndef 
MINISHELL_H


14 #define 
	#MINISHELL_H


	)

16 #include 
	~<stdio.h
>

17 #include 
	~<string.h
>

18 #include 
	~<stdlib.h
>

19 #include 
	~<errno.h
>

20 #include 
	~<curses.h
>

21 #include 
	~<term.h
>

22 #include 
	~<signal.h
>

23 #include 
	~<unistd.h
>

24 #include 
	~<fcntl.h
>

25 #include 
	~<stdarg.h
>

26 #include 
	~<sys/wait.h
>

27 #include 
	~<sys/stat.h
>

28 #include 
	~<sys/types.h
>

29 #include 
	~<readline/readline.h
>

30 #include 
	~<readline/history.h
>

31 #include 
	~"libft/includes/libft.h
"

34 #define 
	#RED
 "\x1b[31m"

	)

35 #define 
	#BLU
 "\x1B[34m"

	)

36 #define 
	#BLU_2
 "\e[1;34m"

	)

37 #define 
	#GRN
 "\x1B[32m"

	)

38 #define 
	#YEL
 "\x1B[33m"

	)

39 #define 
	#MAG
 "\x1B[35m"

	)

40 #define 
	#CYN
 "\x1B[36m"

	)

41 #define 
	#WHT
 "\x1B[37m"

	)

42 #define 
	#RESET
 "\x1B[0m"

	)

44 #define 
	#WORD
 1

	)

45 #define 
	#PIPELINE
 2

	)

46 #define 
	#L_CHEVRON
 3

	)

47 #define 
	#R_CHEVRON
 4

	)

48 #define 
	#APPEND
 5

	)

49 #define 
	#HERE_DOC
 6

	)

50 #define 
	#DOLLAR
 7

	)

51 #define 
	#QUESTION
 8

	)

52 #define 
	#EXPAND
 9

	)

53 #define 
	#DELETE
 10

	)

54 #define 
	#EXPANDED
 11

	)

55 #define 
	#CONTINUE
 -1

	)

56 #define 
	#ERROR_EXIT
 -169

	)

57 #define 
	#ERROR_EXIT_
 0

	)

62 typedef struct 
	ss_env


64 char *
	mvar_name
;

65 char *
	mvar_value
;

66 struct 
s_env
 *
	mnext
;

67 } 
	tt_env
;

69 typedef struct 
	ss_token


71 char *
	mcontent
;

72 int 
	mid
;

73 struct 
s_token
 *
	mnext
;

74 } 
	tt_token
;

77 typedef struct 
	ss_cmd


80 char **
	mcmd
;

81 char **
	mredir
;

82 char **
	mpath
;

86 int 
	mfdout
;

87 int 
	mfdin
;

88 int 
	mfd
[2];

89 } 
	tt_cmd
;

93 typedef struct 
	ss_bin


95 char *
	mpath
;

96 char **
	msplitted_path
;

97 char *
	mcmd
;

98 int 
	mok
;

99 
pid_t
 
	mchild
;

100 } 
	tt_bin
;

103 typedef struct 
	ss_shell


105 
t_env
 *
	menv
;

106 int 
	mexit_status
;

107 char **
	msave_env
;

108 } 
	tt_shell
;

111 extern 
t_shell
 *
g_shell
;

113 int 
expansion
(
t_token
 **
token
, t_token *
curr
, int 
pos
);

114 int 
check_dollar
(
t_token
 *
curr
, int 
i
);

115 int 
trim_dollar
(
t_token
 *
curr
, int 
pos
);

118 int 
is_dollar_to_expand
(
t_token
 *
curr
, int 
i
);

119 int 
not_within_squotes
(
t_token
 *
curr
, int 
pos
);

122 int 
trim_dollar
(
t_token
 *
curr
, int 
pos
);

125 int 
loop_dollars
(char *
s
, int 
i
);

126 int 
loop_through
(char *
s
, int 
i
);

131 int 
size_var
(char *
s
);

132 int 
check_var_exist
(
t_token
 *
tmp
);

135 int 
join_tokens
(
t_token
 **
new
, t_token *
curr
);

138 int 
prepare_expand
(
t_token
 *
tmp
, int 
i
);

139 int 
set_id_expansion
(
t_token
 *
token
);

142 int 
quote_removing
(
t_token
 **
head
, t_token *
curr
, int 
pos
);

144 
t_token
 *
delete_token
(t_token **
head
);

145 int 
token_list_size
(
t_token
 **
head
);

148 int 
_pwd
(
t_cmd
 *
cmd
);

149 int 
_env
(
t_env
 *
env
);

152 char **
env_copied
(char **
envp
);

153 void 
free_tab
(char **
table
);

156 
t_env
 *
get_envp
(char **
envp
);

157 void 
free_env
(
t_env
 **
head
);

161 
t_token
 *
parsing
(char *
line
);

162 int 
syntax_error_check
(char *
s
);

163 int 
check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
);

164 int 
check_quotes_errors
(char *
s
, char 
c
, int *
i
);

165 int 
count_metachar
(char *
s
, char 
c
, int 
num
);

166 int 
check_multiple_operators_error
(int 
i
, int 
num
, char 
c
);

167 void 
print_syntax_error_char
(char 
c
);

168 void 
print_syntax_error_dchar
(char 
c
);

169 void 
print_syntax_error_str
(char *
s
);

172 int 
character_extraction
(char *
line
, int 
ind
);

173 int 
token_extraction
(char *
line
, int 
ind
);

174 
t_token
 *
get_tokens
(char *
line
);

175 int 
get_tokens_size
(char *
line
, int *
i
);

176 
t_token
 *
create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
);

179 void 
malloc_error_print_message
(char *
s
);

182 
t_token
 *
new_token
(char *
line
, int 
start
, int 
len
);

183 void 
set_id
(
t_token
 *
token
);

184 int 
token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
);

185 int 
link_token
(
t_token
 **
head
, t_token *
new
);

186 void 
free_token
(
t_token
 **
head
);

189 int 
is_dollar
(char 
c
);

190 int 
is_pipeline
(char 
c
);

191 int 
is_chevron
(char 
c
);

192 int 
is_lchevron
(char 
c
);

193 int 
is_rchevron
(char 
c
);

194 int 
is_operator
(char 
c
);

195 int 
is_newline
(char 
c
);

196 int 
is_white_space
(char 
c
);

197 int 
is_blank
(char 
c
);

198 int 
is_metacharacter
(char 
c
);

199 int 
is_delimiter
(char 
c
);

200 int 
is_word
(char 
c
);

201 int 
is_double_quote
(char 
c
);

202 int 
is_simple_quote
(char 
c
);

203 int 
is_quote
(char 
c
);

204 int 
is_question
(char 
c
);

205 int 
is_punct
(char 
c
);

208 int 
sig_handler
(void);

211 void 
handler_ctr_c
(int 
code
);

214 char **
ft_splitpath
(char *
s
, char 
c
);

217 char **
copy_env_tab
(
t_env
 *
env
);

219 int 
cmd_is_bin
(
t_token
 *
token
, 
t_bin
 *
bin
);

220 void 
check_then_execute
(
t_token
 *
token
);

	@sauvegarde/execution_test/parsing.c

12 #include 
	~"minishell.h
"

16 void 
	$print_token
(
t_token
 **
head
)

18 int 
i
;

19 
t_token
 *
tmp
;

21 
i
 = 0;

22 if (!*
head
 || !head)

24 
tmp
 = *
head
;

25 while (
tmp
)

27 if (
tmp
->
id
 == 
L_CHEVRON
)

28 
	`printf
("L_CHEVRON: ");

29 else if (
tmp
->
id
 == 
R_CHEVRON
)

30 
	`printf
("R_CHEVRON: ");

31 else if (
tmp
->
id
 == 
PIPELINE
)

32 
	`printf
("PIPELINE: ");

33 else if (
tmp
->
id
 == 
WORD
)

34 
	`printf
("WORD: ");

35 else if (
tmp
->
id
 == 
APPEND
)

36 
	`printf
("APPEND: ");

37 else if (
tmp
->
id
 == 
HERE_DOC
)

38 
	`printf
("HERE_DOC: ");

39 else if (
tmp
->
id
 == 
DOLLAR
)

40 
	`printf
("DOLLAR: ");

41 while (
tmp
->
content
[
i
])

43 
	`printf
 ("%c", 
tmp
->
content
[
i
]);

44 
i
++;

46 
	`printf
 ("%c", 
tmp
->
content
[
i
]);

47 
	`printf
 ("\n");

48 
i
 = 0;

49 
tmp
 = tmp->
next
;

51 
	}
}

89 
t_token
 *
	$parsing
(char *
line
)

91 
t_token
 *
token
;

93 if (!
	`syntax_error_check
(
line
))

94 return (
NULL
);

95 
token
 = 
	`get_tokens
(
line
);

96 if (!
token
)

97 return (
NULL
);

98 if (!
	`expansion
(&
token
, token, 0))

99 return (
NULL
);

100 if (!
	`quote_removing
(&
token
, token, 0))

101 return (
NULL
);

102 
	`print_token
(&
token
);

103 return (
token
);

104 
	}
}

	@sauvegarde/execution_test/parsing_expansion.c

12 #include 
	~"minishell.h
"

42 int 
	$check_dollar
(
t_token
 *
curr
, int 
i
)

44 int 
res
;

46 while (
curr
->
content
[
i
])

48 if (
	`is_dollar
(
curr
->
content
[
i
]) && 
	`not_within_squotes
(curr, i))

50 if (
	`is_dollar_to_expand
(
curr
, 
i
))

51 return (
	`prepare_expand
(
curr
, 
i
));

52 else if (
	`is_dollar
(
curr
->
content
[
i
 + 1]))

53 
i
 = 
	`loop_dollars
(
curr
->
content
, i);

54 else if (
	`is_quote
(
curr
->
content
[
i
 + 1]))

56 
res
 = 
	`trim_dollar
(
curr
, 
i
);

57 if (
res
 == 
ERROR_EXIT
)

58 return (
ERROR_EXIT
);

59 
i
 += 
res
;

61 else if (
curr
->
content
[
i
 + 1] == '\0')

64 
i
++;

67 
i
++;

69 
curr
->
id
 = 
WORD
;

70 return (
i
);

71 
	}
}

73 static void 
	$expansion_next_token
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

75 
pos
 = 0;

76 if (
curr
->
next
)

78 
curr
 = curr->
next
;

79 
	`expansion
(
head
, 
curr
, 
pos
);

81 
	}
}

107 int 
	$expansion
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

109 if (
curr
)

111 if (
curr
->
id
 == 
DOLLAR
)

113 
pos
 = 
	`check_dollar
(
curr
, pos);

114 if (
pos
 == 
ERROR_EXIT
)

115 return (
	`free_token
(
head
), 0);

116 if (
curr
->
id
 == 
DELETE
)

118 
curr
 = 
	`delete_token
(
head
);

119 if (!
curr
)

121 
head
 = 
NULL
;

124 
pos
 = 0;

126 
	`expansion
(
head
, 
curr
, 
pos
);

129 
	`expansion_next_token
(
head
, 
curr
, 
pos
);

132 
	}
}

	@sauvegarde/execution_test/parsing_expansion_dollar_conditions.c

12 #include 
	~"minishell.h
"

18 int 
	$not_within_squotes
(
t_token
 *
curr
, int 
pos
)

20 int 
i
;

21 int 
start
;

23 
i
 = 0;

24 
start
 = 0;

25 if (!
	`is_dollar
(
curr
->
content
[
pos
]))

27 while (
curr
->
content
[
i
])

29 if (
	`is_double_quote
(
curr
->
content
[
i
]))

30 
i
 = 
	`loop_through
(
curr
->
content
, i);

31 else if (
	`is_simple_quote
(
curr
->
content
[
i
]))

33 
start
 = 
i
;

34 
i
 = 
	`loop_through
(
curr
->
content
, i);

35 if (
pos
 > 
start
 && pos < 
i
)

38 
i
++;

41 
	}
}

43 int 
	$is_dollar_to_expand
(
t_token
 *
curr
, int 
i
)

45 if (
	`is_question
(
curr
->
content
[
i
 + 1]) || \

46 (!
	`is_dollar
(
curr
->
content
[
i
 + 1]) && \

47 !
	`is_quote
(
curr
->
content
[
i
 + 1]) && \

48 !
	`is_punct
(
curr
->
content
[
i
 + 1]) && \

49 !
	`is_white_space
(
curr
->
content
[
i
 + 1]) && \

50 
curr
->
content
[
i
 + 1] != '\0'))

55 
	}
}

	@sauvegarde/execution_test/parsing_expansion_expand_var_helper.c

12 #include 
	~"minishell.h
"

14 static int 
	$replace_content
(
t_token
 *
tmp
, char *
s
)

16 
	`free
(
tmp
->
content
);

17 
tmp
->
content
 = 
NULL
;

18 
tmp
->
content
 = 
	`ft_strdup
(
s
);

19 if (!
tmp
->
content
)

21 
	`malloc_error_print_message
("ft_strdup failed");

22 return (
ERROR_EXIT
);

25 
	}
}

27 int 
	$check_var_exist
(
t_token
 *
tmp
)

29 if (
	`ft_strncmp
(&
tmp
->
content
[1], "?", 1) == 0)

31 return (
	`replace_content
(
tmp
, 
	`ft_itoa
(
g_shell
->
exit_status
)));

33 else if (
g_shell
 && g_shell->
env
 && g_shell->env->
var_name
)

35 if (
	`ft_strncmp
(
g_shell
->
env
->
var_name
, &
tmp
->
content
[1], \

36 
	`ft_strlen
(
tmp
->
content
)) == 0)

38 return (
	`replace_content
(
tmp
, 
g_shell
->
env
->
var_value
));

42 
	}
}

44 int 
	$size_var
(char *
s
)

46 int 
i
;

47 int 
count
;

49 
i
 = 0;

50 
count
 = 0;

51 while (
s
[
i
] && 
	`is_white_space
(s[i]))

52 
i
++;

53 while (
s
[
i
] && !
	`is_white_space
(s[i]))

55 
count
++;

56 
i
++;

58 return (
count
);

59 
	}
}

	@sauvegarde/execution_test/parsing_expansion_helper.c

12 #include 
	~"minishell.h
"

14 int 
	$expand_var
(
t_token
 **
new
)

16 
t_token
 *
tmp
;

17 
t_env
 *
save
;

18 int 
res
;

20 
tmp
 = *
new
;

21 
save
 = 
g_shell
->
env
;

22 while (
tmp
->
id
 != 
EXPAND
)

23 
tmp
 = tmp->
next
;

24 while (
g_shell
->
env
)

26 
res
 = 
	`check_var_exist
(
tmp
);

27 if (
res
 == 
ERROR_EXIT
)

28 return (
ERROR_EXIT
);

29 else if (
res
 == 1)

31 
tmp
->
id
 = 
EXPANDED
;

32 
g_shell
->
env
 = 
save
;

33 return (
	`size_var
(
tmp
->
content
));

35 
g_shell
->
env
 = g_shell->env->
next
;

37 
tmp
->
id
 = 
DELETE
;

38 
g_shell
->
env
 = 
save
;

40 
	}
}

42 int 
	$split_tokens
(
t_token
 **
new
, char *
s
, int 
start
, int 
len
)

44 if (
start
 != 0)

46 *
new
 = 
	`new_token
(
s
, 0, 
start
);

47 if (!*
new
)

48 return (
ERROR_EXIT
);

49 (*
new
)->
id
 = 
WORD
;

50 if (!
	`token_linked_list
(
new
, 
s
, 
start
, 
len
))

51 return (
ERROR_EXIT
);

52 (*
new
)->
next
->
id
 = 
EXPAND
;

56 *
new
 = 
	`new_token
(
s
, 
start
, 
len
);

57 if (!*
new
)

58 return (
ERROR_EXIT
);

59 (*
new
)->
id
 = 
EXPAND
;

61 
start
 += 
len
;

62 
len
 = 
start
;

63 while (
s
[
len
])

64 
len
++;

65 if (
len
 != 
start
)

66 if (!
	`token_linked_list
(
new
, 
s
, 
start
, 
len
))

67 return (
ERROR_EXIT
);

69 
	}
}

71 static int 
	$var_len
(char *
s
, int 
i
)

73 int 
len
;

75 
len
 = 0;

76 
i
++;

77 if (
	`is_question
(
s
[
i
]))

81 while (
s
[
i
] && \

82 !
	`is_white_space
(
s
[
i
]) && \

83 !
	`is_quote
(
s
[
i
]) && \

84 !
	`is_question
(
s
[
i
]) && \

85 !
	`is_dollar
(
s
[
i
]) && \

86 !
	`is_punct
(
s
[
i
]))

88 
i
++;

89 
len
++;

92 return (
len
);

93 
	}
}

95 int 
	$new_id
(
t_token
 **
new
)

97 
t_token
 *
ptr
;

99 
ptr
 = *
new
;

100 while (
ptr
)

102 if (
ptr
->
id
 == 
DELETE
 || ptr->id == 
EXPANDED
)

104 
ptr
 = ptr->
next
;

106 if (
ptr
->
next
 == 
NULL
)

107 return (
WORD
);

108 return(
	`set_id_expansion
(
ptr
->
next
));

109 
	}
}

116 int 
	$prepare_expand
(
t_token
 *
curr
, int 
i
)

118 
t_token
 *
new
;

119 int 
len
;

120 int 
id
;

122 
new
 = 
NULL
;

123 
len
 = 
	`var_len
(
curr
->
content
, 
i
);

124 if (
	`split_tokens
(&
new
, 
curr
->
content
, 
i
, 
len
 + 1) == 
ERROR_EXIT
)

125 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

126 
len
 = 
	`expand_var
(&
new
);

127 if (
len
 == 
ERROR_EXIT
)

128 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

129 
id
 = 
	`new_id
 (&
new
);

130 if (
	`join_tokens
(&
new
, 
curr
) == 
ERROR_EXIT
)

131 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

132 if (
curr
->
id
 == 
DELETE
)

134 
curr
->
id
 = id ;

135 return (
len
 + 
i
);

136 
	}
}

	@sauvegarde/execution_test/parsing_expansion_join_tokens.c

12 #include 
	~"minishell.h
"

14 static int 
	$get_expanded_size
(char *
s
, int 
i
)

16 int 
size
;

18 
size
 = 0;

19 while (
	`is_white_space
(
s
[
i
]))

20 
i
++;

21 while (
s
[
i
] && !
	`is_white_space
(s[i]))

23 
i
++;

24 
size
++;

26 return (
size
);

27 
	}
}

29 static int 
	$get_new_size
(
t_token
 **
new
)

31 
t_token
 *
ptr
;

32 int 
size
;

33 int 
i
;

35 
size
 = 0;

36 
ptr
 = *
new
;

37 while (
ptr
)

39 
i
 = 0;

40 if (
ptr
->
id
 == 
EXPANDED
)

41 
size
 += 
	`get_expanded_size
(
ptr
->
content
, 
i
);

42 else if (
ptr
->
id
 != 
DELETE
)

44 while (
ptr
->
content
[
i
])

46 
size
++;

47 
i
++;

50 
ptr
 = ptr->
next
;

52 return (
size
);

53 
	}
}

55 static void 
	$copy_helper
(
t_token
 **
new
, t_token *
curr
)

57 int 
i
;

58 int 
j
;

59 
t_token
 *
ptr
;

61 
i
 = 0;

62 
j
 = 0;

63 
ptr
 = *
new
;

64 while (
ptr
)

66 if (
ptr
->
id
 == 
EXPANDED
)

68 while (
ptr
->
content
[
j
] && 
	`is_white_space
(ptr->content[j]))

69 
j
++;

70 while (
ptr
->
content
[
j
] && !
	`is_white_space
(ptr->content[j]))

71 
curr
->
content
[
i
++] = 
ptr
->content[
j
++];

73 else if (
ptr
->
id
 != 
DELETE
)

74 while (
ptr
->
content
[
j
])

75 
curr
->
content
[
i
++] = 
ptr
->content[
j
++];

76 
ptr
 = ptr->
next
;

77 
j
 = 0;

79 
curr
->
content
[
i
] = '\0';

80 
	}
}

82 static int 
	$copy_join_tokens
(
t_token
 **
new
, t_token *
curr
, int 
size
)

84 
	`free
(
curr
->
content
);

85 
curr
->
content
 = 
NULL
;

86 
curr
->
content
 = 
	`malloc
((
size
 + 1) * sizeof(char));

87 if (!
curr
->
content
)

89 
	`malloc_error_print_message
(
	`strerror
(
errno
));

90 return (
ERROR_EXIT
);

92 
	`copy_helper
(
new
, 
curr
);

93 
	`free_token
(
new
);

95 
	}
}

97 int 
	$join_tokens
(
t_token
 **
new
, t_token *
curr
)

99 int 
size
;

101 
size
 = 
	`get_new_size
(
new
);

102 if (
size
 == 0)

104 
	`free_token
(
new
);

105 
curr
->
id
 = 
DELETE
;

108 if (
	`copy_join_tokens
(
new
, 
curr
, 
size
) == 
ERROR_EXIT
)

109 return (
ERROR_EXIT
);

111 
	}
}

	@sauvegarde/execution_test/parsing_expansion_looping.c

12 #include 
	~"minishell.h
"

53 int 
	$loop_dollars
(char *
s
, int 
i
)

55 while (
	`is_dollar
(
s
[
i
]) && s[i])

56 
i
++;

57 if (
s
[
i
] != '\0' && !
	`is_white_space
(s[i]))

58 
i
--;

59 return (
i
);

60 
	}
}

68 int 
	$loop_through
(char *
s
, int 
i
)

70 char 
c
;

72 
c
 = 
s
[
i
];

73 
i
++;

74 while (
s
[
i
] != 
c
)

75 
i
++;

76 return (
i
);

77 
	}
}

	@sauvegarde/execution_test/parsing_expansion_trim_dollar.c

12 #include 
	~"minishell.h
"

17 static int 
	$copy_string
(
t_token
 *
curr
, char **
s
, int 
pos
)

19 int 
i
;

20 int 
j
;

22 
i
 = 0;

23 
j
 = 0;

24 *
s
 = 
	`malloc
(sizeof(char) * 
	`ft_strlen
(
curr
->
content
));

25 if (!*
s
)

27 
i
 = 0;

28 while (
curr
->
content
[
i
])

30 if (
i
 == 
pos
)

31 
i
++;

32 (*
s
)[
j
] = 
curr
->
content
[
i
];

33 
i
++;

34 
j
++;

36 (*
s
)[
j
] = '\0';

37 
	`free
(
curr
->
content
);

38 
curr
->
content
 = *
s
;

40 
	}
}

46 int 
	$trim_dollar
(
t_token
 *
curr
, int 
pos
)

48 int 
i
;

49 int 
start
;

50 char *
s
;

52 
s
 = 
NULL
;

53 
i
 = 0;

54 
start
 = 0;

55 while (
curr
->
content
[
i
])

57 if (
	`is_double_quote
(
curr
->
content
[
i
]))

59 
start
 = 
i
;

60 
i
 = 
	`loop_through
(
curr
->
content
, i);

61 if (
pos
 > 
start
 && pos < 
i
)

64 
i
++;

66 if (!
	`copy_string
(
curr
, &
s
, 
pos
))

67 return (
ERROR_EXIT
);

69 
	}
}

	@sauvegarde/execution_test/parsing_quote_removing.c

12 #include 
	~"minishell.h
"

14 static int 
copy_string_unquoted
(
t_token
 *
curr
, char *
new_str
, \

15 int 
start
, int 
pos
)

17 int 
	gj
;

18 int 
	gi
;

19 int 
	gsave
;

21 
	gj
 = 0;

22 
	gi
 = 0;

23 
	gsave
 = 0;

24 while (
	gcurr
->
	gcontent
[
i
])

26 if (
	gi
 == 
start
)

27 
i
++;

28 else if (
	gi
 == 
pos
)

30 
i
++;

31 
	gsave
 = 
j
;

35 
	gnew_str
[
j
] = 
curr
->
content
[
i
];

36 
	gi
++;

37 
	gj
++;

40 
	gnew_str
[
j
] = '\0';

41 return (
	gsave
);

44 int 
	$string_replace
(
t_token
 *
curr
, int 
start
, int 
pos
)

46 int 
save
;

47 char *
new_str
;

49 
new_str
 = 
	`malloc
(sizeof(char) * (
	`ft_strlen
(
curr
->
content
) - 2 + 1));

50 if (!
new_str
)

52 
	`malloc_error_print_message
(
	`strerror
(
errno
));

53 return (
ERROR_EXIT
);

55 
save
 = 
	`copy_string_unquoted
(
curr
, 
new_str
, 
start
, 
pos
);

56 
	`free
(
curr
->
content
);

57 
curr
->
content
 = 
NULL
;

58 
curr
->
content
 = 
new_str
;

59 return (
save
);

60 
	}
}

62 int 
	$remove_q
(
t_token
 *
curr
, int 
pos
)

64 int 
start
;

66 
start
 = 
pos
;

67 
pos
 = 
	`loop_through
(
curr
->
content
, pos);

68 
pos
 = 
	`string_replace
(
curr
, 
start
, pos);

69 if (
pos
 == 
ERROR_EXIT
)

70 return (
ERROR_EXIT
);

71 return (
pos
++);

72 
	}
}

74 int 
	$quote_removing
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

76 if (!
head
 || !*head)

78 if (
curr
->
content
[
pos
] == '\0')

80 if (
curr
->
next
)

82 
pos
 = 0;

83 
curr
 = curr->
next
;

84 
	`quote_removing
(
head
, 
curr
, 
pos
);

88 else if (
	`is_quote
(
curr
->
content
[
pos
]))

90 
pos
 = 
	`remove_q
(
curr
, pos);

91 if (
pos
 == 
ERROR_EXIT
)

92 return (
	`free_token
(
head
), 0);

93 
	`quote_removing
(
head
, 
curr
, 
pos
);

97 
pos
++;

98 
	`quote_removing
(
head
, 
curr
, 
pos
);

101 
	}
}

	@sauvegarde/execution_test/parsing_syntax_errors.c

12 #include 
	~"minishell.h
"

14 int 
	$check_multiple_operators_error
(int 
i
, int 
num
, char 
c
)

16 if (
i
 > 
num
)

18 if (
	`is_chevron
(
c
))

19 
	`print_syntax_error_dchar
(
c
);

20 else if (
	`is_pipeline
(
c
))

21 
	`print_syntax_error_char
(
c
);

25 
	}
}

27 int 
	$count_metachar
(char *
s
, char 
c
, int 
num
)

29 int 
i
;

31 
i
 = 1;

32 while (
s
[
i
] && s[i] == 
c
)

33 
i
++;

34 if (!
	`check_multiple_operators_error
(
i
, 
num
, 
c
))

36 while (
s
[
i
] && 
	`is_blank
(s[i]))

37 
i
++;

38 if (
	`is_operator
(
s
[
i
]) && !
	`is_pipeline
(
c
))

40 
c
 = 
s
[
i
];

41 if (
	`is_chevron
(
c
) && is_chevron(
s
[
i
 + 1]))

42 return (
	`print_syntax_error_dchar
(
c
), 0);

44 
	`print_syntax_error_char
(
c
);

47 else if (
s
[
i
] == '\0')

48 return (
	`print_syntax_error_str
("newline"), 0);

50 
	}
}

52 int 
	$check_quotes_errors
(char *
s
, char 
c
, int *
i
)

54 int 
j
;

56 
j
 = *
i
 + 1;

57 while (
s
[
j
] && s[j] != 
c
)

58 
j
++;

59 if (
s
[
j
] != 
c
)

61 
	`print_syntax_error_char
(
c
);

64 (*
i
)++;

65 while (
s
[*
i
] && s[*i] != 
c
)

66 (*
i
)++;

68 
	}
}

70 int 
	$check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
)

72 int 
j
;

74 
j
 = 0;

75 while (
s
[
j
] && 
	`is_blank
(s[j]))

76 
j
++;

77 if (
s
[
j
] == 
c
)

79 
	`print_syntax_error_char
(
c
);

82 if (!
	`count_metachar
(&
s
[
i
], 
c
, 
num
))

85 
	}
}

132 int 
	$syntax_error_check
(char *
s
)

134 int 
i
;

136 
i
 = 0;

137 while (
s
[
i
])

139 if (
	`is_quote
(
s
[
i
]))

141 if (!
	`check_quotes_errors
(
s
, s[
i
], &i))

142 return (
	`free
(
s
), 0);

144 else if ((
	`is_lchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '<', 2)) || \

145 (
	`is_rchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '>', 2)))

146 return (
	`free
(
s
), 0);

147 else if (
	`is_pipeline
(
s
[
i
]) && !
	`check_pipeline_errors
(s, i, '|', 1))

148 return (
	`free
(
s
), 0);

149 
i
++;

152 
	}
}

	@sauvegarde/execution_test/parsing_syntax_errors_print_message.c

12 #include 
	~"minishell.h
"

19 void 
	$print_syntax_error_char
(char 
c
)

21 
	`ft_dprintf
(2, "minishell: ");

22 
	`ft_dprintf
(2, "syntax error near unexpected token ");

23 
	`ft_dprintf
(2, "\'%c\'\n", 
c
);

24 
g_shell
->
exit_status
 = 258;

25 
	}
}

27 void 
	$print_syntax_error_dchar
(char 
c
)

29 
	`ft_dprintf
(2, "minishell: ");

30 
	`ft_dprintf
(2, "syntax error near unexpected token ");

31 
	`ft_dprintf
(2, "\'%c%c\'\n", 
c
, c);

32 
g_shell
->
exit_status
 = 258;

33 
	}
}

35 void 
	$print_syntax_error_str
(char *
s
)

37 
	`ft_dprintf
(2, "minishell: ");

38 
	`ft_dprintf
(2, "syntax error near unexpected token ");

39 
	`ft_dprintf
(2, "\'%s\'\n", 
s
);

40 
g_shell
->
exit_status
 = 258;

41 
	}
}

	@sauvegarde/execution_test/parsing_token_extraction.c

12 #include 
	~"minishell.h
"

21 int 
	$character_extraction
(char *
line
, int 
ind
)

23 if ((
line
[
ind
] == '>' && line[ind + 1] == '>') || \

24 (
line
[
ind
] == '<' && line[ind + 1] == '<'))

27 
	}
}

43 int 
	$word_extraction
(char *
line
, int 
ind
)

45 int 
start
;

46 char 
c
;

48 
start
 = 
ind
;

49 while (
	`is_word
(
line
[
ind
]) && line[ind])

51 if (
	`is_quote
(
line
[
ind
]))

53 
c
 = 
line
[
ind
];

54 
ind
++;

55 while (
line
[
ind
] && line[ind] != 
c
)

56 
ind
++;

58 
ind
++;

60 return (
ind
 - 
start
);

61 
	}
}

64 int 
	$get_tokens_size
(char *
line
, int *
i
)

66 int 
len
;

68 
len
 = 0;

69 while (
	`is_white_space
(
line
[*
i
]))

70 (*
i
)++;

71 if (
	`is_word
(
line
[*
i
]))

72 
len
 = 
	`word_extraction
(
line
, *
i
);

73 else if (
	`is_operator
(
line
[*
i
]))

74 
len
 = 
	`character_extraction
(
line
, *
i
);

75 return (
len
);

76 
	}
}

83 
t_token
 *
	$create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
)

85 
t_token
 *
head
;

87 
head
 = 
	`new_token
(
line
, 
i
, 
len
);

88 if (!
head
)

89 return (
NULL
);

90 *
flag
 = 1;

91 return (
head
);

92 
	}
}

122 
t_token
 *
	$get_tokens
(char *
line
)

124 int 
i
;

125 int 
len
;

126 int 
flag
;

127 
t_token
 *
head
;

129 
i
 = 0;

130 
flag
 = 0;

131 
head
 = 
NULL
;

132 while (
line
[
i
])

134 
len
 = 
	`get_tokens_size
(
line
, &
i
);

135 if (
len
 == 0)

137 if (!
flag
)

139 
head
 = 
	`create_token_head
(
line
, 
i
, 
len
, &
flag
);

140 if (!
head
)

141 return (
	`free
(
line
), 
NULL
);

144 if (!
	`token_linked_list
(&
head
, 
line
, 
i
, 
len
))

145 return (
	`free_token
(&
head
), 
	`free
(
line
), 
NULL
);

146 
i
 += 
len
;

148 return (
	`free
(
line
), 
head
);

149 
	}
}

	@sauvegarde/execution_test/sans_readline_main.c

13 #include 
	~"minishell.h
"

15 
t_shell
 *
	gg_shell
;

21 void 
	$print_env
(
t_env
 **
head
)

23 
t_env
 *
ptr
;

25 
ptr
 = *
head
;

26 if (!
head
 || !*head)

28 while (
ptr
)

30 
	`ft_printf
("print_env function: %s\n", 
ptr
->
var_name
);

31 
	`ft_printf
("print_env function: %s\n", 
ptr
->
var_value
);

32 
ptr
 = ptr->
next
;

34 
	}
}

37 void 
	$free_shell
(void)

39 
	`free_env
(&
g_shell
->
env
);

41 if (
g_shell
)

42 
	`free
(
g_shell
);

43 
	}
}

45 int 
	$init_shell
(char **
envp
)

47 
g_shell
 = 
	`ft_calloc
(1, sizeof(
t_shell
));

48 if (!
g_shell
)

50 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

53 if (!*
envp
)

58 
g_shell
->
env
 = 
	`get_envp
(
envp
);

59 if (!
g_shell
->
env
)

61 
	`free_shell
();

62 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

65 
g_shell
->
exit_status
 = 0;

69 
	}
}

72 int 
	$main
(int 
ac
, char **
av
, char **
envp
)

74 (void)
av
;

75 (void)
ac
;

76 char *
line
;

77 
t_token
 *
token
;

79 if (!
	`init_shell
(
envp
))

81 
line
 = 
NULL
;

83 
line
 = 
	`ft_strdup
("ls");

85 
	`printf
("LINE = %s\n", 
line
);

86 
token
 = 
	`parsing
(
line
);

87 
	`check_then_execute
(
token
);

89 
g_shell
->
exit_status
 = 0;

90 if (
token
)

91 
	`free_token
(&
token
);

92 
	`free_shell
();

94 
	}
}

	@sauvegarde/execution_test/token_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_token
(
t_token
 **
head
)

16 
t_token
 *
ptr
;

17 
t_token
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
content
);

27 
	`free
(
tmp
);

29 *
head
 = 
NULL
;

30 
head
 = 
NULL
;

31 
	}
}

46 
t_token
 *
	$new_token
(char *
line
, int 
start
, int 
len
)

48 
t_token
 *
token
;

50 
token
 = 
NULL
;

51 
token
 = 
	`malloc
(sizeof(
t_token
));

52 if (!
token
)

54 
	`malloc_error_print_message
(
	`strerror
(
errno
));

55 return (
NULL
);

57 
token
->
content
 = 
	`ft_substr
(
line
, 
start
, 
len
);

58 if (!
token
->
content
)

60 
	`malloc_error_print_message
(
	`strerror
(
errno
));

61 return (
	`free_token
(&
token
), 
NULL
);

63 
	`set_id
(
token
);

64 
token
->
next
 = 
NULL
;

65 return (
token
);

66 
	}
}

75 int 
	$link_token
(
t_token
 **
head
, t_token *
new
)

77 
t_token
 *
ptr
;

79 if (!
new
)

81 
ptr
 = *
head
;

82 while (
ptr
)

84 if (!
ptr
->
next
)

86 
ptr
 = ptr->
next
;

88 
ptr
->
next
 = 
new
;

90 
	}
}

113 int 
	$token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
)

115 
t_token
 *
new
;

117 if (!
head
)

119 
new
 = 
	`new_token
(
line
, 
start
, 
len
);

120 if (!
new
)

122 if (!
	`link_token
(
head
, 
new
))

125 
	}
}

	@sauvegarde/execution_test/token_routine_delete.c

12 #include 
	~"minishell.h
"

14 int 
	$token_list_size
(
t_token
 **
head
)

16 
t_token
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

29 static 
t_token
 *
delete_helper
(t_token **
head
, t_token *
curr
, \

30 
t_token
 *
prev
, int 
i
)

32 int 
	gsize
;

34 
	gsize
 = 
token_list_size
(
head
);

35 if (
	gi
 == 0 && 
size
 == 1)

37 
free
(
curr
->
content
);

38 
free
(
curr
);

39 *
	ghead
 = 
NULL
;

40 return (*
	ghead
);

42 else if (
	gi
 == 0 && 
size
 > 1)

44 *
head
 = 
curr
->
next
;

45 
	gprev
 = *
head
;

47 else if (
	gi
 == 
size
 - 1)

48 
prev
->
next
 = 
NULL
;

50 
	gprev
->
	gnext
 = 
curr
->
next
;

51 
free
(
curr
->
content
);

52 
free
(
curr
);

53 
	gcurr
 = 
NULL
;

54 return (
	gprev
);

57 
t_token
 *
	$delete_token
(
t_token
 **
head
)

59 int 
i
;

60 
t_token
 *
curr
;

61 
t_token
 *
prev
;

63 
i
 = 0;

64 
curr
 = *
head
;

65 
prev
 = 
NULL
;

66 while (
curr
->
id
 != 
DELETE
)

68 
prev
 = 
curr
;

69 
curr
 = curr->
next
;

70 
i
++;

72 return (
	`delete_helper
(
head
, 
curr
, 
prev
, 
i
));

73 
	}
}

	@sauvegarde/execution_test/token_routine_set_id.c

12 #include 
	~"minishell.h
"

14 int 
	$set_id_expansion
(
t_token
 *
token
)

16 if (
	`ft_strchr
(
token
->
content
, '$'))

17 return(
DOLLAR
);

18 return (
WORD
);

19 
	}
}

21 void 
	$set_id
(
t_token
 *
token
)

23 if (
	`ft_strncmp
(
token
->
content
, "|", 2) == 0)

24 
token
->
id
 = 
PIPELINE
;

25 else if (
	`ft_strncmp
(
token
->
content
, "<", 2) == 0)

26 
token
->
id
 = 
L_CHEVRON
;

27 else if (
	`ft_strncmp
(
token
->
content
, ">", 2) == 0)

28 
token
->
id
 = 
R_CHEVRON
;

29 else if (
	`ft_strncmp
(
token
->
content
, "<<", 3) == 0)

30 
token
->
id
 = 
HERE_DOC
;

31 else if (
	`ft_strncmp
(
token
->
content
, ">>", 3) == 0)

32 
token
->
id
 = 
APPEND
;

33 else if (
	`ft_strchr
(
token
->
content
, '$'))

34 
token
->
id
 = 
DOLLAR
;

36 
token
->
id
 = 
WORD
;

38 
	}
}

	@sauvegarde/free_cmd.c

12 #include 
	~"minishell.h
"

14 static void 
	$free_tab2d
(char **
s
)

16 int 
i
;

18 if (!
s
 || !*s)

20 
i
 = 0;

21 while (
s
[
i
])

23 
	`free
 (
s
[
i
]);

24 
i
++;

26 
	`free
 (
s
);

27 
	}
}

29 void 
	$free_cmd
(
t_cmd
 **
head
)

31 
t_cmd
 *
ptr
;

32 
t_cmd
 *
tmp
;

34 if (!
head
 || !*head)

36 
ptr
 = *
head
;

37 while (
ptr
)

39 
tmp
 = 
ptr
;

40 
ptr
 = ptr->
next
;

41 
	`free_tab2d
(
tmp
->
cmd
);

42 
	`free_tab2d
(
tmp
->
redir
);

43 
	`free
(
tmp
);

45 *
head
 = 
NULL
;

46 
	}
}

	@sauvegarde/global_variable/init_global.c

12 #include 
	~"minishell.h
"

16 void 
	$print_env
()

18 
t_env
 *
ptr
;

20 
ptr
 = 
g_shell
->
env
;

21 if (!
g_shell
 || !g_shell->
env
)

23 while (
g_shell
->
env
)

25 
	`ft_printf
("print_env function: %s\n", 
g_shell
->
env
->
var_name
);

26 
	`ft_printf
("print_env function: %s\n", 
g_shell
->
env
->
var_value
);

27 
g_shell
->
env
 = g_shell->env->
next
;

29 
g_shell
->
env
 = 
ptr
;

30 
	}
}

32 void 
	$free_shell
(void)

34 
	`free_env
(&
g_shell
->
env
);

36 if (
g_shell
)

37 
	`free
(
g_shell
);

38 
	}
}

40 int 
	$shell_no_env
()

42 
t_env
 *
env_no
;

43 
env_no
 = 
	`malloc
(sizeof(
t_env
));

44 if (!
env_no
)

46 
	`malloc_error_print_message
(
	`strerror
(
errno
));

49 
env_no
->
var_name
 = 
	`ft_strdup
("SHLVL");

50 
env_no
->
var_value
 = 
	`ft_strdup
("1");

51 
env_no
->
next
 = 
NULL
;

52 
g_shell
->
env
 = 
env_no
;

55 
	}
}

57 int 
	$init_shell
(char **
envp
)

59 
g_shell
 = 
	`ft_calloc
(1, sizeof(
t_shell
));

60 if (!
g_shell
)

62 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

65 if (!*
envp
)

67 if (!
	`shell_no_env
())

72 
g_shell
->
env
 = 
	`get_envp
(
envp
);

73 if (!
g_shell
->
env
)

74 return (
	`free_shell
(), 0);

76 
g_shell
->
exit_status
 = 0;

77 
	`printf
("%s\n", 
g_shell
->
env
->
var_name
);

78 
g_shell
->
save_env
 = 
	`copy_env_tab
(g_shell->
env
);

79 
	`print_env
();

81 
	}
}

	@sauvegarde/handler_ctr_c.c

12 #include 
	~"minishell.h
"

14 void 
	$handler_ctr_c
(int 
code
)

16 (void)
code
;

17 
	`printf
("\n");

18 
	`rl_replace_line
("", 0);

19 
	`rl_on_new_line
();

20 
	`rl_redisplay
();

21 
	}
}

	@sauvegarde/init_cmd.c

12 #include 
	~"minishell.h
"

14 void 
	$cmd_backadd
(
t_cmd
 **
head
, t_cmd *
new
)

16 
t_cmd
 *
ptr
;

18 if (!
head
 || !
new
)

20 if (!*
head
)

22 *
head
 = 
new
;

25 
ptr
 = *
head
;

26 while (
ptr
)

28 if (!
ptr
->
next
)

30 
ptr
 = ptr->
next
;

32 
ptr
->
next
 = 
new
;

33 
	}
}

35 int 
	$get_redir_size
(
t_token
 *
ptr
)

37 int 
i
;

39 
i
 = 0;

40 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

42 if (
ptr
->
id
 == 
L_CHEVRON
 || ptr->id == 
R_CHEVRON
 || \

43 
ptr
->
id
 == 
APPEND
 || ptr->id == 
HERE_DOC
)

44 
i
 = i + 2;

45 
ptr
 = ptr->
next
;

47 return (
i
);

48 
	}
}

50 void 
	$copy_redir
(
t_token
 **
token
, 
t_cmd
 *
cmd
)

52 
t_token
 *
ptr
;

53 int 
i
;

55 
ptr
 = *
token
;

56 
i
 = 0;

57 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

59 if (
ptr
->
id
 == 
L_CHEVRON
 || ptr->id == 
R_CHEVRON
 || \

60 
ptr
->
id
 == 
APPEND
 || ptr->id == 
HERE_DOC
)

62 
cmd
->
redir
[
i
] = 
	`ft_strdup
(
ptr
->
content
);

63 if (!
cmd
->
redir
[
i
])

65 
	`malloc_error_print_message
("ft_strdup failed");

68 
i
++;

69 
ptr
 = ptr->
next
;

70 
cmd
->
redir
[
i
] = 
	`ft_strdup
(
ptr
->
content
);

71 if (!
cmd
->
redir
[
i
])

73 
	`malloc_error_print_message
("ft_strdup failed");

76 
i
++;

78 
ptr
 = ptr->
next
;

80 
	}
}

82 int 
	$create_redir
(
t_token
 **
token
, 
t_cmd
 *
cmd
)

84 
t_token
 *
ptr
;

85 int 
i
;

87 
ptr
 = *
token
;

88 
i
 = 
	`get_redir_size
(
ptr
);

89 if (
i
 == 0)

91 
cmd
->
redir
 = 
NULL
;

94 
cmd
->
redir
 = 
	`ft_calloc
(
i
 + 1, sizeof(char *));

95 if (!
cmd
->
redir
)

97 
	`malloc_error_print_message
("ft_calloc failed");

100 
	`copy_redir
(
token
, 
cmd
);

102 
	}
}

104 
t_cmd
 *
	$init_cmd
(
t_token
 **
token
)

106 
t_cmd
 *
cmd
;

107 int 
res
;

109 
res
 = 0;

110 
cmd
 = 
	`ft_calloc
(1, sizeof(
t_cmd
));

111 if (!
cmd
)

113 
	`malloc_error_print_message
("ft_calloc failed");

114 return (
NULL
);

116 
	`create_cmd
(
token
, 
cmd
);

117 if (!
cmd
->cmd)

119 
	`free
(
cmd
);

120 return (
NULL
);

122 
cmd
->
next
 = 
NULL
;

123 
res
 = 
	`create_redir
(
token
, 
cmd
);

124 if (
res
 == -1)

126 
	`free_cmd
(&
cmd
);

127 return (
NULL
);

129 return (
cmd
);

130 
	}
}

132 
t_cmd
 *
	$cmd_linked_list
(
t_token
 **
token
)

134 
t_cmd
 *
head
;

135 
t_cmd
 *
new
;

136 
t_token
 *
ptr
;

138 
ptr
 = *
token
;

139 
head
 = 
NULL
;

140 
head
 = 
	`init_cmd
(&
ptr
);

141 if (!
head
)

142 return (
NULL
);

143 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

144 
ptr
 = ptr->
next
;

145 while (
ptr
)

147 if (
ptr
->
id
 != 
PIPELINE
)

149 
new
 = 
	`init_cmd
(&
ptr
);

150 if (!
new
)

152 
	`free_cmd
(&
head
);

153 return (
NULL
);

155 
	`cmd_backadd
(&
head
, 
new
);

156 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

157 
ptr
 = ptr->
next
;

160 
ptr
 = ptr->
next
;

162 return (
head
);

163 
	}
}

	@sauvegarde/init_cmd_cmd.c

12 #include 
	~"minishell.h
"

14 static int 
	$get_cmd_size
(
t_token
 **
token
)

16 
t_token
 *
ptr
;

17 int 
i
;

19 
i
 = 0;

20 
ptr
 = *
token
;

21 if (!
token
 || !*token)

23 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

25 if (
ptr
->
id
 == 
L_CHEVRON
 || ptr->id == 
R_CHEVRON
 || \

26 
ptr
->
id
 == 
APPEND
 || ptr->id == 
HERE_DOC
)

28 
ptr
 = ptr->
next
->next;

32 
i
++;

33 
ptr
 = ptr->
next
;

36 return (
i
);

37 
	}
}

39 static void 
	$copy_cmd
(
t_token
 **
token
, 
t_cmd
 *
cmd
)

41 
t_token
 *
ptr
;

42 int 
i
;

44 
ptr
 = *
token
;

45 
i
 = 0;

46 while (
ptr
 && ptr->
id
 != 
PIPELINE
)

48 if (
ptr
->
id
 == 
L_CHEVRON
 || ptr->id == 
R_CHEVRON
 || \

49 
ptr
->
id
 == 
APPEND
 || ptr->id == 
HERE_DOC
)

50 
ptr
 = ptr->
next
->next;

53 
cmd
->cmd[
i
] = 
	`ft_strdup
(
ptr
->
content
);

54 
ptr
 = ptr->
next
;

55 
i
++;

58 
cmd
->cmd[
i
] = 
NULL
;

59 
	}
}

61 void 
	$create_cmd
(
t_token
 **
token
, 
t_cmd
 *
cmd
)

63 int 
i
;

65 
i
 = 
	`get_cmd_size
(
token
);

66 if (
i
 == -1)

68 
cmd
->cmd = 
	`malloc
(sizeof(char *) * (
i
 + 1));

69 if (!
cmd
->cmd)

71 
	`malloc_error_print_message
(
	`strerror
(
errno
));

74 
	`copy_cmd
(
token
, 
cmd
);

75 
	}
}

	@sauvegarde/is_smth/is_dollar.c

12 #include 
	~"minishell.h
"

16 int 
	$is_dollar
(char 
c
)

18 if (
c
 == '$')

21 
	}
}

	@sauvegarde/is_smth/is_operator.c

12 #include 
	~"minishell.h
"

16 int 
	$is_pipeline
(char 
c
)

18 if (
c
 == '|')

21 
	}
}

25 int 
	$is_lchevron
(char 
c
)

27 if (
c
 == '<')

30 
	}
}

32 int 
	$is_rchevron
(char 
c
)

34 if (
c
 == '>')

37 
	}
}

39 int 
	$is_chevron
(char 
c
)

41 if (
	`is_lchevron
(
c
) || 
	`is_rchevron
(c))

44 
	}
}

48 int 
	$is_operator
(char 
c
)

50 if (
	`is_pipeline
(
c
) || 
	`is_chevron
(c))

53 
	}
}

	@sauvegarde/is_smth/is_question.c

12 #include 
	~"minishell.h
"

14 int 
	$is_question
(char 
c
)

16 if (
c
 == '?')

19 
	}
}

21 int 
	$is_punct
(char 
c
)

23 if ((
c
 >= 33 && c <= 47) || \

24 (
c
 >= 58 && c <= 64) || \

25 (
c
 >= 91 && c <= 94) || \

26 (
c
 == 96) || \

27 (
c
 >= 123 && c <= 126))

30 
	}
}

	@sauvegarde/is_smth/is_quote.c

12 #include 
	~"minishell.h
"

16 int 
	$is_double_quote
(char 
c
)

18 if (
c
 == '\"')

21 
	}
}

23 int 
	$is_simple_quote
(char 
c
)

25 if (
c
 == '\'')

28 
	}
}

30 int 
	$is_quote
(char 
c
)

32 if (
	`is_double_quote
(
c
) || 
	`is_simple_quote
(c))

35 
	}
}

	@sauvegarde/is_smth/is_token.c

12 #include 
	~"minishell.h
"

16 int 
	$is_metacharacter
(char 
c
)

18 if (
	`is_blank
(
c
) || 
	`is_newline
(c) || 
	`is_operator
(c))

21 
	}
}

25 int 
	$is_delimiter
(char 
c
)

27 if (
	`is_metacharacter
(
c
))

30 
	}
}

34 int 
	$is_word
(char 
c
)

36 if (!
	`is_delimiter
(
c
))

39 
	}
}

	@sauvegarde/is_smth/is_white_space.c

12 #include 
	~"minishell.h
"

14 int 
	$is_blank
(char 
c
)

16 if (
c
 == ' ' || c == '\t')

19 
	}
}

21 int 
	$is_newline
(char 
c
)

23 if (
c
 == '\n')

26 
	}
}

28 int 
	$is_white_space
(char 
c
)

30 if (
	`is_blank
(
c
) || 
	`is_newline
(c))

33 
	}
}

	@sauvegarde/launch_setup.c

12 #include 
	~"minishell.h
"

24 int 
	$sig_handler
(void)

26 
	`signal
(
SIGINT
, 
handler_ctr_c
);

27 
	`signal
(
SIGQUIT
, 
SIG_IGN
);

29 
	}
}

	@sauvegarde/libft/ft_printf/ft_count_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_int
(int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

	@sauvegarde/libft/ft_printf/ft_count_unsigned_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_unsigned_int
(unsigned int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 else if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 return (
count
);

30 
	}
}

	@sauvegarde/libft/ft_printf/ft_dprintf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 
fd
, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 
fd
, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 
fd
, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 
fd
, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 
fd
, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_dprintf
(int 
fd
, const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 
fd
, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 
fd
, &
count
);

50 
	`ft_format_specifier_fd
(
last
[
i
 + 1], 
ap
, &
count
, 
fd
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@sauvegarde/libft/ft_printf/ft_printf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier
(char 
format
, 
va_list
 
ap
, int *
count
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 1, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 1, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 1, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 1, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 1, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 1, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 1, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_printf
(const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 1, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 1, &
count
);

50 
	`ft_format_specifier
(
last
[
i
 + 1], 
ap
, &
count
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@sauvegarde/libft/ft_printf/ft_printf_address.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
);

16 void 
	$ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
)

18 
	`ft_printf_str
("0x", 
fd
, 
count
);

19 
	`ft_put_uintptr_fd
(
n
, 
fd
, 
count
);

20 
	}
}

22 void 
	$ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
)

24 if (
n
 > 15)

26 
	`ft_put_uintptr_fd
(
n
 / 16, 
fd
, 
count
);

27 
	`ft_put_uintptr_fd
(
n
 % 16, 
fd
, 
count
);

29 if (
n
 < 10)

30 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

31 else if (
n
 > 9 && n < 16)

32 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

33 
	}
}

	@sauvegarde/libft/ft_printf/ft_printf_char.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_char
(char 
c
, int 
fd
, int *
count
)

16 
	`ft_putchar_fd
(
c
, 
fd
);

17 *
count
 += 1;

18 
	}
}

	@sauvegarde/libft/ft_printf/ft_printf_hexa.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
)

16 if (
n
 > 15)

18 
	`ft_printf_hexa
(
n
 / 16, 
fd
, 
count
, 
c
);

19 
	`ft_printf_hexa
(
n
 % 16, 
fd
, 
count
, 
c
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

25 if (
c
 == 'x')

26 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

27 else if (
c
 == 'X')

28 
	`ft_printf_char
(
n
 + 55, 
fd
, 
count
);

30 
	}
}

	@sauvegarde/libft/ft_printf/ft_printf_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_int
(int 
n
, int 
fd
, int *
count
)

16 
	`ft_putnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_int
(
n
);

18 
	}
}

	@sauvegarde/libft/ft_printf/ft_printf_str.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_str
(char *
s
, int 
fd
, int *
count
)

16 int 
i
;

18 
i
 = 0;

19 if (
s
 != 
NULL
)

21 while (
s
[
i
] != '\0')

22 
i
++;

23 
	`ft_putstr_fd
(
s
, 
fd
);

27 
	`ft_putstr_fd
("(null)", 1);

28 
i
 = 6;

30 *
count
 += 
i
;

31 
	}
}

	@sauvegarde/libft/ft_printf/ft_printf_unsint.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
)

16 
	`ft_put_unsnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_unsigned_int
(
n
);

18 
	}
}

	@sauvegarde/libft/ft_printf/ft_put_hexanbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_hexanbr_fd
(unsigned int 
n
, int 
fd
, int *
count
)

16 if (
n
 > 15)

18 
	`ft_put_hexanbr_fd
(
n
 / 16, 
fd
, 
count
);

19 
	`ft_put_hexanbr_fd
(
n
 % 16, 
fd
, 
count
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

24 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

25 
	}
}

	@sauvegarde/libft/ft_printf/ft_put_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_put_int
(int 
n
, int 
fd
, int *
count
)

16 int 
a
;

18 
a
 = *
count
;

19 
	`ft_putnbr_fd
(
n
, 
fd
);

20 
a
 += 
	`ft_count_int
(
n
);

21 return (
a
);

22 
	}
}

	@sauvegarde/libft/ft_printf/ft_put_unsnbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
)

16 if (
n
 > 9)

18 
	`ft_put_unsnbr_fd
(
n
 / 10, 
fd
);

19 
	`ft_put_unsnbr_fd
((
n
 % 10), 
fd
);

22 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

23 
	}
}

	@sauvegarde/libft/get_next_line/get_next_line.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$create_nextline
(char *
result
, char *
line
)

16 int 
start
;

17 int 
size
;

18 char *
nextline
;

20 
start
 = 
	`ft_strlen_int
(
result
);

21 
size
 = 
	`ft_strlen_int
(
line
);

22 
size
 = size - 
start
;

23 if (
size
 == 0)

25 
	`free
 (
line
);

26 return (
NULL
);

28 
nextline
 = 
	`malloc
((
size
 + 1) * sizeof(char));

29 if (!
nextline
)

30 return (
NULL
);

31 
size
 = 0;

32 while (
line
[
start
] != '\0')

34 
nextline
[
size
] = 
line
[
start
];

35 
size
++;

36 
start
++;

38 
nextline
[
size
] = '\0';

39 
	`free
(
line
);

40 return (
nextline
);

41 
	}
}

55 char *
	$create_result
(char *
line
)

57 int 
i
;

58 char *
result
;

60 
i
 = 
	`there_is_n
(
line
);

61 if (
i
 == -1 && *
line
)

62 
i
 = 
	`ft_strlen_int
(
line
);

63 else if (
i
 == -1 && !*
line
)

64 return (
NULL
);

65 
result
 = 
	`malloc
((
i
 + 1) * sizeof(char));

66 if (!
result
)

67 return (
NULL
);

68 
i
 = 0;

69 while (
line
[
i
] != '\0')

71 
result
[
i
] = 
line
[i];

72 if (
line
[
i
] == '\n')

74 
i
++;

77 
i
++;

79 
result
[
i
] = '\0';

80 return (
result
);

81 
	}
}

94 char *
	$read_fd
(char *
line
, int 
fd
, int *
error
)

96 char *
buffer
;

97 int 
ret
;

99 
ret
 = 1;

100 
	`prepare_forstash
(&
line
, &
buffer
);

101 while (
ret
 > 0 && 
	`there_is_n
(
buffer
) == -1 && there_is_n(
line
) == -1)

103 
ret
 = (int)
	`read
(
fd
, 
buffer
, 
BUFFER_SIZE
);

104 if (
ret
 < 0)

106 
	`free
(
buffer
);

107 *
error
 = -1;

108 return (
NULL
);

110 if (
ret
 == 0)

112 *
error
 = 0;

115 
buffer
[
ret
] = '\0';

116 
line
 = 
	`ft_join
(line, 
buffer
);

118 
	`free
(
buffer
);

119 return (
line
);

120 
	}
}

130 int 
	$check_errors
(int 
fd
, char **
line
)

132 if (
fd
 < 0 || 
BUFFER_SIZE
 <= 0 || 
	`read
(fd, 0, 0) < 0)

134 
	`free
(*
line
);

135 *
line
 = 0;

139 
	}
}

150 char *
	$get_next_line
(int 
fd
)

152 static char *
line
;

153 char *
result
;

154 int 
error
;

156 
error
 = 
	`check_errors
(
fd
, &
line
);

157 if (
error
 == 0)

158 return (
NULL
);

159 
line
 = 
	`read_fd
(line, 
fd
, &
error
);

160 if (
error
 == -1 || (error == 0 && !*
line
))

162 
	`free
(
line
);

163 
line
 = 0;

164 return (
NULL
);

166 if (!
line
)

167 return (
NULL
);

168 
result
 = 
	`create_result
(
line
);

169 if (!
result
)

171 
line
 = 0;

172 
	`free
(
line
);

174 
line
 = 
	`create_nextline
(
result
, line);

175 return (
result
);

176 
	}
}

	@sauvegarde/libft/get_next_line/get_next_line_bonus.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$get_next_line_maxopen
(int 
fd
)

16 static char *
line
[
OPEN_MAX
];

17 char *
result
;

18 int 
error
;

20 
error
 = 
	`check_errors
(
fd
, &
line
[fd]);

21 if (
error
 == 0)

22 return (
NULL
);

23 
line
[
fd
] = 
	`read_fd
(line[fd], fd, &
error
);

24 if (
error
 == -1 || (error == 0 && !*
line
[
fd
]))

26 
	`free
(
line
[
fd
]);

27 
line
[
fd
] = 0;

28 return (
NULL
);

30 if (!
line
[
fd
])

31 return (
NULL
);

32 
result
 = 
	`create_result
(
line
[
fd
]);

33 if (!
result
)

35 
line
[
fd
] = 0;

36 
	`free
(
line
[
fd
]);

38 
line
[
fd
] = 
	`create_nextline
(
result
, line[fd]);

39 return (
result
);

40 
	}
}

	@sauvegarde/libft/get_next_line/get_next_line_utils.c

12 #include 
	~"../includes/get_next_line.h
"

14 void 
	$prepare_forstash
(char **
line
, char **
buffer
)

16 *
buffer
 = 
	`ft_calloc_count
(
BUFFER_SIZE
);

17 if (*
line
 == 
NULL
)

18 *
line
 = 
	`ft_calloc_count
(0);

19 
	}
}

21 char *
	$ft_join
(char *
line
, char *
buffer
)

23 int 
i
;

24 int 
j
;

25 char *
stash
;

27 if (!
line
 || !
buffer
)

28 return (
NULL
);

29 
i
 = 
	`ft_strlen_int
(
line
);

30 
j
 = 
	`ft_strlen_int
(
buffer
);

31 
stash
 = 
	`malloc
((
i
 + 
j
 + 1) * sizeof(char));

32 if (!
stash
)

33 return (
NULL
);

34 
i
 = 0;

35 
j
 = 0;

36 while (
line
[
i
] != '\0')

38 
stash
[
i
] = 
line
[i];

39 
i
++;

41 while (
buffer
[
j
] != '\0')

42 
stash
[
i
++] = 
buffer
[
j
++];

43 
stash
[
i
] = '\0';

44 
	`free
(
line
);

45 return (
stash
);

46 
	}
}

48 char *
	$ft_calloc_count
(int 
count
)

50 char *
string
;

51 int 
i
;

53 
i
 = 0;

54 
string
 = 
	`malloc
((
count
 + 1) * sizeof(char));

55 if (!
string
)

56 return (
NULL
);

57 while (
i
 <= 
count
)

59 
string
[
i
] = '\0';

60 
i
++;

62 return (
string
);

63 
	}
}

65 int 
	$ft_strlen_int
(const char *
string
)

67 int 
i
;

69 
i
 = 0;

70 while (
string
[
i
] != '\0')

71 
i
++;

72 return (
i
);

73 
	}
}

75 int 
	$there_is_n
(char *
line
)

77 int 
i
;

79 
i
 = 0;

80 while (
line
[
i
] != '\0')

82 if (
line
[
i
] == '\n')

83 return (
i
 + 1);

84 
i
++;

87 
	}
}

	@sauvegarde/libft/includes/ft_printf.h

12 #ifndef 
FT_PRINTF_H


13 #define 
	#FT_PRINTF_H


	)

15 #include 
	~"libft.h
"

16 #include 
	~<stdarg.h
>

18 int 
ft_printf
(const char *
last
, ...);

19 void 
ft_printf_char
(char 
c
, int 
fd
, int *
count
);

20 void 
ft_printf_str
(char *
s
, int 
fd
, int *
count
);

21 void 
ft_printf_int
(int 
n
, int 
fd
, int *
count
);

22 int 
ft_count_int
(int 
n
);

23 void 
ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
);

24 void 
ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
);

25 int 
ft_count_unsigned_int
(unsigned int 
n
);

26 void 
ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
);

27 void 
ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
);

31 void 
ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
);

32 int 
ft_dprintf
(int 
fd
, const char *
last
, ...);

	@sauvegarde/libft/includes/get_next_line.h

12 #ifndef 
GET_NEXT_LINE_H


13 #define 
	#GET_NEXT_LINE_H


	)

15 #include 
	~<unistd.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<limits.h
>

19 #ifndef 
BUFFER_SIZE


20 #define 
	#BUFFER_SIZE
 42

	)

23 char *
ft_calloc_count
(int 
count
);

24 int 
ft_strlen_int
(const char *
string
);

25 char *
ft_join
(char *
nextline
, char *
buffer
);

26 int 
there_is_n
(char *
line
);

27 char *
read_fd
(char *
nextline
, int 
fd
, int *
error
);

28 char *
create_result
(char *
line
);

29 char *
create_nextline
(char *
result
, char *
line
);

30 char *
get_next_line
(int 
fd
);

31 char *
get_next_line_maxopen
(int 
fd
);

32 int 
check_errors
(int 
fd
, char **
line
);

33 void 
prepare_forstash
(char **
line
, char **
buffer
);

	@sauvegarde/libft/includes/libft.h

12 #ifndef 
LIBFT_H


13 #define 
	#LIBFT_H


	)

15 #include 
	~<stddef.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<unistd.h
>

18 #include 
	~"ft_printf.h
"

19 #include 
	~"get_next_line.h
"

21 typedef struct 
	ss_list


23 void *
	mcontent
;

24 struct 
s_list
 *
	mnext
;

25 } 
	tt_list
;

27 void *
ft_memset
(void *
b
, int 
c
, 
size_t
 
len
);

28 void 
ft_bzero
(void *
s
, 
size_t
 
n
);

29 void *
ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
);

30 void *
ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
);

31 void *
ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
);

32 int 
ft_isalpha
(int 
c
);

33 int 
ft_isdigit
(int 
c
);

34 int 
ft_isalnum
(int 
c
);

35 int 
ft_isascii
(int 
c
);

36 int 
ft_isprint
(int 
c
);

37 
size_t
 
ft_strlen
(const char *
s
);

38 int 
ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
);

39 char *
ft_strcpy
(char *
dst
, const char *
src
);

40 
size_t
 
ft_strlcpy
(char *
dst
, const char *
src
, size_t 
dstsize
);

41 
size_t
 
ft_strlcat
(char *
dst
, const char *
src
, size_t 
dstsize
);

42 char *
ft_strchr
(const char *
s
, int 
c
);

43 char *
ft_strrchr
(const char *
s
, int 
c
);

44 char *
ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
);

45 int 
ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
);

46 int 
ft_toupper
(int 
c
);

47 int 
ft_tolower
(int 
c
);

48 int 
ft_atoi
(const char *
str
);

49 void *
ft_calloc
(
size_t
 
count
, size_t 
size
);

50 char *
ft_strdup
(const char *
s1
);

51 char *
ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
);

52 char *
ft_strjoin
(char const *
s1
, char const *
s2
);

53 char *
ft_strtrim
(char const *
s1
, char const *
set
);

54 char **
ft_split
(char const *
s
, char 
c
);

55 char *
ft_itoa
(int 
n
);

56 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char));

57 void 
	`ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*));

58 void 
	`ft_putchar_fd
(char 
c
, int 
fd
);

59 void 
	`ft_putstr_fd
(char *
s
, int 
fd
);

60 void 
	`ft_putendl_fd
(char *
s
, int 
fd
);

61 void 
	`ft_putnbr_fd
(int 
n
, int 
fd
);

64 
t_list
 *
	`ft_lstnew
(void *
content
);

65 void 
	`ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
);

66 int 
	`ft_lstsize
(
t_list
 *
lst
);

67 
t_list
 *
	`ft_lstlast
(t_list *
lst
);

68 void 
	`ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
);

69 void 
	`ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*));

70 void 
	`ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*));

71 void 
	`ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *));

72 
t_list
 *
	`ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *));

73 void 
	`delete_first_el
(
t_list
 **
a
);

74 void 
	`delete_last_el
(
t_list
 **
a
);

75 void 
	`del
(void *
content
);

78 int 
	`power
(int 
str_base
, int 
power
);

79 int 
	`ft_atoi_base
(const char *
str
, int 
str_base
);

80 int 
	`transform
(char 
c
);

81 
size_t
 
	`ft_strcspn
(const char *
s
, const char *
reject
);

82 char *
	`ft_strpbrk
(const char *
s1
, const char *
s2
);

83 
size_t
 
	`ft_strspn
(const char *
s
, const char *
accept
);

84 char *
	`str_lowercase
(char *
str
);

	@sauvegarde/libft/libft/del.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$del
(void *
content
)

16 if (
content
)

17 
	`free
(
content
);

18 
	}
}

	@sauvegarde/libft/libft/ft_atoi.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_atoi
(const char *
str
)

16 int 
i
;

17 int 
result
;

18 int 
sign
;

20 
i
 = 0;

21 
result
 = 0;

22 
sign
 = 1;

23 while (
str
[
i
] == 32 || (str[i] >= 9 && str[i] <= 13))

24 
i
++;

25 if (
str
[
i
] == '-')

27 
sign
 *= (-1);

28 
i
++;

30 else if (
str
[
i
] == '+')

31 
i
++;

32 while (
str
[
i
] >= '0' && str[i] <= '9')

34 
result
 *= 10;

35 
result
 += 
str
[
i
] - 48;

36 
i
++;

38 return (
sign
 * 
result
);

39 
	}
}

	@sauvegarde/libft/libft/ft_atoi_base.c

12 #include 
	~"../includes/libft.h
"

13 #include 
	~"../includes/get_next_line.h
"

15 int 
	$transform
(char 
c
)

17 int 
i
;

18 char 
c2
;

20 
i
 = 10;

21 if (
c
 >= 'A' && c <= 'F')

22 
c2
 = 'A';

23 if (
c
 >= 'a' && c <= 'f')

24 
c2
 = 'a';

25 while (
c
 != 
c2
)

27 
c2
++;

28 
i
++;

30 return (
i
);

31 
	}
}

33 int 
	$ft_atoi_base
(const char *
str
, int 
str_base
)

35 int 
i
;

36 int 
count
;

37 int 
result
;

38 int 
sign
;

40 
i
 = 0;

41 
result
 = 0;

42 
count
 = 
	`ft_strlen_int
(
str
) - 1;

43 
sign
 = 1;

44 if (
str
[
i
] == '-')

46 
i
++;

47 
sign
 = -1;

48 
count
--;

50 while (
str
[
i
++] != 0)

52 if (
str
[
i
] >= '0' && str[i] <= '9')

53 
result
 = result + (
str
[
i
] - '0') * 
	`power
(
str_base
, 
count
);

54 if ((
str
[
i
] >= 'A' && str[i] <= 'F') || \

55 (
str
[
i
] >= 'a' && str[i] <= 'f'))

56 
result
 = result + 
	`transform
(
str
[
i
]) * 
	`power
(
str_base
, 
count
);

57 
count
--;

59 return (
result
 * 
sign
);

60 
	}
}

	@sauvegarde/libft/libft/ft_bzero.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_bzero
(void *
s
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (
n
 == 0)

21 while (
i
 < 
n
)

23 *(char *)(
s
 + 
i
) = 0;

24 
i
++;

26 
	}
}

	@sauvegarde/libft/libft/ft_calloc.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_calloc
(
size_t
 
count
, size_t 
size
)

16 void *
ptr
;

18 
ptr
 = (void *)
	`malloc
(
count
 * 
size
);

19 if (!
ptr
)

20 return (
NULL
);

21 
	`ft_bzero
(
ptr
, (
count
 * 
size
));

22 return (
ptr
);

23 
	}
}

	@sauvegarde/libft/libft/ft_isalnum.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalnum
(int 
c
)

16 if (
	`ft_isalpha
(
c
) == 1 || 
	`ft_isdigit
(c) == 1)

20 
	}
}

	@sauvegarde/libft/libft/ft_isalpha.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalpha
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

18 else if (
c
 >= 'a' && c <= 'z')

22 
	}
}

	@sauvegarde/libft/libft/ft_isascii.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isascii
(int 
c
)

16 if (
c
 >= 0 && c <= 127)

20 
	}
}

	@sauvegarde/libft/libft/ft_isdigit.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isdigit
(int 
c
)

16 if (
c
 >= '0' && c <= '9')

20 
	}
}

	@sauvegarde/libft/libft/ft_isprint.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isprint
(int 
c
)

16 if (
c
 >= 32 && c <= 126)

20 
	}
}

	@sauvegarde/libft/libft/ft_itoa.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbchar
(int 
n
)

16 
size_t
 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

41 char *
	$ft_nb_is_negative
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

43 int 
result
;

45 
result
 = 0;

46 if (
n
 == -2147483648)

48 
n
 = -214748364;

49 
itoa_str
[
nb_char
 - 1] = (char)(8 + 48);

50 
nb_char
--;

52 
n
 *= (-1);

53 while (
n
 > 0)

55 
result
 = (
n
 % 10);

56 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

57 
n
 = n / 10;

58 
nb_char
--;

60 
itoa_str
[--
nb_char
] = '-';

61 return (
itoa_str
);

62 
	}
}

64 char *
	$ft_nb_is_positive
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

66 int 
result
;

68 
result
 = 0;

69 while (
n
 > 0)

71 
result
 = 
n
 % 10;

72 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

73 
n
 = n / 10;

74 
nb_char
--;

76 return (
itoa_str
);

77 
	}
}

79 char *
	$ft_itoa
(int 
n
)

81 
size_t
 
nb_char
;

82 
size_t
 
buff
;

83 char *
itoa_str
;

85 
buff
 = 0;

86 
nb_char
 = 
	`ft_count_nbchar
(
n
);

87 
itoa_str
 = (char *)
	`ft_calloc
((
nb_char
 + 1), sizeof(char));

88 if (!
itoa_str
)

89 return (
NULL
);

90 while (
buff
 < 
nb_char
)

92 
itoa_str
[
buff
] = '0';

93 
buff
++;

95 if (
n
 == 0)

96 
itoa_str
[0] = (char)(0 + 48);

97 else if (
n
 < 0)

98 
itoa_str
 = 
	`ft_nb_is_negative
(
n
, itoa_str, 
nb_char
);

99 else if (
n
 > 0)

100 
itoa_str
 = 
	`ft_nb_is_positive
(
n
, itoa_str, 
nb_char
);

101 return (
itoa_str
);

102 
	}
}

	@sauvegarde/libft/libft/ft_lstadd_back.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
)

16 
t_list
 *
lstlast
;

18 if (*
lst
 == 
NULL
)

19 *
lst
 = 
new
;

20 else if (!
lst
 || !
new
)

24 
lstlast
 = 
	`ft_lstlast
(*
lst
);

25 
lstlast
->
next
 = 
new
;

27 
	}
}

	@sauvegarde/libft/libft/ft_lstadd_front.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
)

16 if (*
lst
 == 
NULL
)

18 
new
->
next
 = 
NULL
;

19 *
lst
 = 
new
;

21 else if (*
lst
 != 
NULL
)

23 
new
->
next
 = *
lst
;

24 *
lst
 = 
new
;

26 
	}
}

	@sauvegarde/libft/libft/ft_lstclear.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*))

16 
t_list
 *
temp
;

17 
t_list
 *
ptr
;

19 
ptr
 = *
lst
;

20 if (!
del
)

22 while (
ptr
 != 
NULL
)

24 
temp
 = 
ptr
->
next
;

25 
	`ft_lstdelone
(
ptr
, 
del
);

26 
ptr
 = 
temp
;

28 *
lst
 = 
NULL
;

29 
	}
}

	@sauvegarde/libft/libft/ft_lstdel_first_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_first_el
(
t_list
 **
a
)

16 
t_list
 *
tmp
;

18 
tmp
 = (*
a
)->
next
;

19 
	`free
 (*
a
);

20 *
a
 = 
tmp
;

21 
	}
}

	@sauvegarde/libft/libft/ft_lstdel_last_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_last_el
(
t_list
 **
a
)

16 
t_list
 *
end
;

17 
t_list
 *
prev
;

19 
end
 = *
a
;

20 
prev
 = 
NULL
;

21 while (
end
->
next
)

23 
prev
 = 
end
;

24 
end
 = end->
next
;

26 
prev
->
next
 = 
NULL
;

27 
	`free
 (
end
);

28 
	}
}

	@sauvegarde/libft/libft/ft_lstdelone.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*))

16 if (!
lst
 || !
del
)

18 
	`del
(
lst
->
content
);

19 
	`free
(
lst
);

20 
	}
}

	@sauvegarde/libft/libft/ft_lstiter.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *))

16 
t_list
 *
ptr
;

18 
ptr
 = 
lst
;

19 while (
ptr
 != 
NULL
)

21 
	`f
(
ptr
->
content
);

22 
ptr
 = ptr->
next
;

24 
	}
}

	@sauvegarde/libft/libft/ft_lstlast.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstlast
(
t_list
 *
lst
)

16 while (
lst
 != 
NULL
 && lst->
next
 != NULL)

18 
lst
 = lst->
next
;

20 return (
lst
);

21 
	}
}

	@sauvegarde/libft/libft/ft_lstmap.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *))

16 
t_list
 *
new_list
;

17 
t_list
 *
head
;

19 if (!
lst
 || !
f
)

20 return (
NULL
);

21 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

22 if (!
new_list
)

23 return (
NULL
);

24 
head
 = 
new_list
;

25 
lst
 = lst->
next
;

26 while (
lst
 != 
NULL
)

28 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

29 if (!
new_list
)

31 
	`ft_lstclear
(&
head
, 
del
);

32 return (
NULL
);

34 
	`ft_lstadd_back
(&
head
, 
new_list
);

35 
lst
 = lst->
next
;

37 return (
head
);

38 
	}
}

	@sauvegarde/libft/libft/ft_lstnew.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstnew
(void *
content
)

16 
t_list
 *
lstnew
;

18 
lstnew
 = (
t_list
 *)
	`malloc
(sizeof(t_list));

19 if (!
lstnew
)

20 return (
NULL
);

21 
lstnew
->
next
 = 
NULL
;

22 
lstnew
->
content
 = (void *)content;

23 return (
lstnew
);

24 
	}
}

	@sauvegarde/libft/libft/ft_lstsize.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_lstsize
(
t_list
 *
lst
)

16 int 
i
;

17 
t_list
 *
ptr
;

19 
i
 = 0;

20 
ptr
 = 
NULL
;

21 
ptr
 = 
lst
;

22 while (
ptr
 != 
NULL
)

24 
ptr
 = ptr->
next
;

25 
i
++;

27 return (
i
);

28 
	}
}

	@sauvegarde/libft/libft/ft_memchr.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s
 + 
i
) == (unsigned char) 
c
)

23 return ((unsigned char *)(
s
 + 
i
));

26 
i
++;

28 return (
NULL
);

29 
	}
}

	@sauvegarde/libft/libft/ft_memcmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s1
 + 
i
) != *(unsigned char *)(
s2
 + i))

23 return (*(unsigned char *)(
s1
 + 
i
) - *(unsigned char *)(
s2
 + i));

26 
i
++;

29 
	}
}

	@sauvegarde/libft/libft/ft_memcpy.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 while (
i
 < 
n
)

23 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

24 
i
++;

26 return (
dst
);

27 
	}
}

	@sauvegarde/libft/libft/ft_memmove.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 if (
dst
 > 
src
)

23 while (
len
--)

25 *(char *)(
dst
 + 
len
) = *(char *)(
src
 + len);

27 return (
dst
);

29 while (
i
 < 
len
)

31 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

32 
i
++;

34 return (
dst
);

35 
	}
}

	@sauvegarde/libft/libft/ft_memset.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memset
(void *
b
, int 
c
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
len
)

21 *(unsigned char *)(
b
 + 
i
) = (unsigned char)
c
;

22 
i
++;

24 return (
b
);

25 
	}
}

	@sauvegarde/libft/libft/ft_putchar_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putchar_fd
(char 
c
, int 
fd
)

16 
	`write
(
fd
, &
c
, 1);

17 
	}
}

	@sauvegarde/libft/libft/ft_putendl_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putendl_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

26 
	`write
(
fd
, "\n", 1);

28 
	}
}

	@sauvegarde/libft/libft/ft_putnbr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putnbr_fd
(int 
n
, int 
fd
)

16 if (
n
 == -2147483648)

18 
	`ft_putstr_fd
("-2147483648", 
fd
);

20 else if (
n
 < 0)

22 
	`ft_putchar_fd
('-', 
fd
);

23 
n
 = n * (-1);

24 
	`ft_putnbr_fd
(
n
, 
fd
);

26 else if (
n
 > 9)

28 
	`ft_putnbr_fd
(
n
 / 10, 
fd
);

29 
	`ft_putnbr_fd
((
n
 % 10), 
fd
);

32 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

33 
	}
}

	@sauvegarde/libft/libft/ft_putstr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putstr_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

27 
	}
}

	@sauvegarde/libft/libft/ft_split.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbsubstr
(const char *
s
, char 
c
)

16 unsigned int 
i
;

17 
size_t
 
count
;

19 
i
 = 0;

20 
count
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] != 
c
)

25 while (
s
[
i
] != 
c
 && s[i] != '\0')

26 
i
++;

27 
count
++;

29 while (
s
[
i
] == 
c
)

30 
i
++;

32 return (
count
);

33 
	}
}

35 unsigned int 
	$ft_start_index_substr
(char const *
s
, char 
c
, unsigned int 
start
)

37 while (
s
[
start
] == 
c
 && s[start] != '\0')

38 
start
++;

39 return (
start
);

40 
	}
}

42 unsigned int 
	$ft_nb_char_substr
(char const *
s
, char 
c
, unsigned int 
start
)

44 unsigned int 
nb_char_substr
;

46 
nb_char_substr
 = 0;

47 while (
s
[
start
] != 
c
 && s[start] != '\0')

49 
start
++;

50 
nb_char_substr
++;

52 return (
nb_char_substr
);

53 
	}
}

55 char *
ft_create_substr
(\

56 char const *
s
, char 
c
, unsigned int 
start
, unsigned int 
nb_char_substr
)

58 unsigned int 
	gi
;

59 char *
	gsubstr
;

61 
	gi
 = 0;

62 
	gsubstr
 = (char *)
ft_calloc
((
nb_char_substr
 + 1), sizeof(char));

63 if (!
	gsubstr
)

64 return (
	gNULL
);

65 while (
	gs
[
start
] != 
c
 && 
s
[start] != '\0' && 
i
 < 
nb_char_substr
)

66 
substr
[
i
++] = 
s
[
start
++];

67 return (
	gsubstr
);

70 char **
	$ft_split
(char const *
s
, char 
c
)

72 
size_t
 
nb_substr
;

73 
size_t
 
i
;

74 char **
tab2d
;

75 unsigned int 
start
;

76 unsigned int 
nb_char_substr
;

78 
i
 = 0;

79 
start
 = 0;

80 
nb_substr
 = 
	`ft_count_nbsubstr
(
s
, 
c
);

81 
tab2d
 = (char **)
	`ft_calloc
((
nb_substr
 + 1), sizeof(char *));

82 if (!
tab2d
)

83 return (
NULL
);

84 while (
s
[
start
] != '\0' && 
i
 < 
nb_substr
)

86 
start
 = 
	`ft_start_index_substr
(
s
, 
c
, start);

87 
nb_char_substr
 = 
	`ft_nb_char_substr
(
s
, 
c
, 
start
);

88 
tab2d
[
i
] = 
	`ft_create_substr
(
s
, 
c
, 
start
, 
nb_char_substr
);

89 
start
 = start + 
nb_char_substr
;

90 
i
++;

92 return (
tab2d
);

93 
	}
}

	@sauvegarde/libft/libft/ft_strchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strchr
(const char *
s
, int 
c
)

16 int 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 if ((char)
c
 == 
s
[
i
])

22 return ((char *)(
s
 + 
i
));

23 
i
++;

25 if ((char)
c
 == '\0')

26 return ((char *)(
s
 + 
i
));

28 return (
NULL
);

29 
	}
}

	@sauvegarde/libft/libft/ft_strcpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strcpy
(char *
dst
, const char *
src
)

16 int 
i
;

18 
i
 = 0;

19 while (
src
[
i
])

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 
dst
[
i
] = '\0';

25 return (
dst
);

26 
	}
}

	@sauvegarde/libft/libft/ft_strcspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strcspn
(const char *
s
, const char *
reject
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
])

21 if (
	`ft_strchr
(
reject
, 
s
[
i
]) != 
NULL
)

22 return (
i
);

23 
i
++;

25 return (
i
);

26 
	}
}

	@sauvegarde/libft/libft/ft_strdup.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strdup
(const char *
s1
)

16 int 
size
;

17 char *
s1_copie
;

19 
size
 = 
	`ft_strlen
(
s1
) + 1;

20 
s1_copie
 = (char *)
	`malloc
(
size
 * sizeof(char));

21 if (!
s1_copie
)

22 return (
NULL
);

23 
	`ft_strlcpy
(
s1_copie
, 
s1
, 
size
);

24 return (
s1_copie
);

25 
	}
}

	@sauvegarde/libft/libft/ft_striteri.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*))

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`f
(
i
, &
s
[i]);

24 
i
++;

27 
	}
}

	@sauvegarde/libft/libft/ft_strjoin.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strjoin
(char const *
s1
, char const *
s2
)

16 
size_t
 
size_s1
;

17 
size_t
 
size_s2
;

18 char *
strjoin
;

20 
size_s1
 = 
	`ft_strlen
(
s1
);

21 
size_s2
 = 
	`ft_strlen
(
s2
);

22 
strjoin
 = (char *)
	`malloc
((
size_s1
 + 
size_s2
 + 1) * sizeof(char));

23 if (!
strjoin
)

24 return (
NULL
);

25 
	`ft_memcpy
(
strjoin
, 
s1
, 
size_s1
);

26 
	`ft_memcpy
((
strjoin
 + 
size_s1
), 
s2
, 
size_s2
);

27 
	`ft_memset
((
strjoin
 + 
size_s1
 + 
size_s2
), 0, 1);

28 return (
strjoin
);

29 
	}
}

	@sauvegarde/libft/libft/ft_strlcat.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcat
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
strlen_src
;

18 
size_t
 
strlen_dst
;

19 
size_t
 
temp
;

21 
i
 = 0;

22 
strlen_src
 = 
	`ft_strlen
(
src
);

23 
strlen_dst
 = 
	`ft_strlen
(
dst
);

24 
temp
 = 
strlen_dst
;

25 if (
dstsize
 < 
strlen_dst
)

26 return (
dstsize
 + 
strlen_src
);

27 if (
dstsize
 > 
strlen_dst
 + 1)

29 while (
src
[
i
] && 
strlen_dst
 != (
dstsize
 - 1))

31 
dst
[
strlen_dst
++] = 
src
[
i
++];

33 
dst
[
strlen_dst
] = '\0';

35 return (
temp
 + 
strlen_src
);

36 
	}
}

	@sauvegarde/libft/libft/ft_strlcpy.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcpy
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
j
;

19 
i
 = 0;

20 
j
 = 0;

21 while (
src
[
i
] != '\0')

23 
i
++;

25 if (
dstsize
 > 0)

27 while (
j
 < (
dstsize
 - 1) && 
src
[j] != '\0')

29 
dst
[
j
] = 
src
[j];

30 
j
++;

32 
dst
[
j
] = '\0';

34 return (
i
);

35 
	}
}

	@sauvegarde/libft/libft/ft_strlen.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlen
(const char *
s
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 
i
++;

23 return (
i
);

24 
	}
}

	@sauvegarde/libft/libft/ft_strmapi.c

12 #include 
	~"../includes/libft.h
"

14 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char))

16 unsigned int 
i
;

17 
size_t
 
size
;

18 char *
strmapi
;

20 
i
 = 0;

21 
size
 = 
	`ft_strlen
(
s
);

22 
strmapi
 = (char *)
	`malloc
((
size
 + 1) * sizeof(char));

23 if (!
strmapi
)

24 return (
NULL
);

25 while (
s
[
i
] != '\0')

27 
strmapi
[
i
] = 
	`f
(i, 
s
[i]);

28 
i
++;

30 
strmapi
[
i
] = '\0';

31 return (
strmapi
);

32 
	}
}

	@sauvegarde/libft/libft/ft_strncmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (((unsigned char)
s1
[
i
] || (unsigned char)
s2
[i]) && i < 
n
)

21 if (
s1
[
i
] != 
s2
[i])

22 return ((unsigned char)
s1
[
i
] - (unsigned char)
s2
[i]);

23 
i
++;

26 
	}
}

	@sauvegarde/libft/libft/ft_strncpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strncpy
(char *
dst
, const char *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
src
[
i
] && i < 
len
)

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 while (
i
 < 
len
)

26 
dst
[
i
] = '\0';

27 
i
++;

29 return (
dst
);

30 
	}
}

	@sauvegarde/libft/libft/ft_strnstr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
)

16 
size_t
 
len_needle
;

17 
size_t
 
len_haystack
;

19 
len_needle
 = 
	`ft_strlen
(
needle
);

20 
len_haystack
 = 
	`ft_strlen
(
haystack
);

21 if (
needle
[0] == '\0')

22 return ((char *)(
haystack
));

23 if (
len_needle
 > 
len_haystack
 || 
len
 < len_needle)

24 return (
NULL
);

25 if (
len
 > 
len_haystack
)

26 
len
 = 
len_haystack
;

27 while (
len
 >= 
len_needle
 && 
haystack
)

29 if (
	`ft_memcmp
(
haystack
, 
needle
, 
len_needle
) == 0)

30 return ((char *)(
haystack
));

33 
haystack
++;

34 
len
--;

37 return (
NULL
);

38 
	}
}

	@sauvegarde/libft/libft/ft_strpbrk.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strpbrk
(const char *
s1
, const char *
s2
)

16 int 
i
;

18 
i
 = 0;

19 while (
s1
[
i
] != '\0')

21 if (
	`ft_strchr
(
s2
, 
s1
[
i
]) != 0)

23 return ((char *) &
s1
[
i
]);

25 ++
i
;

28 
	}
}

	@sauvegarde/libft/libft/ft_strrchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strrchr
(const char *
s
, int 
c
)

16 int 
i
;

17 int 
k
;

19 
i
 = 0;

20 
k
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] == (char)
c
)

24 
k
 = 
i
;

25 
i
++;

27 if (
s
[
k
] == (char)
c
)

28 return ((char *)(
s
 + 
k
));

29 else if ((char)
c
 == 
s
[
i
])

30 return ((char *)(
s
 + 
i
));

32 return (
NULL
);

33 
	}
}

	@sauvegarde/libft/libft/ft_strspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strspn
(const char *
s
, const char *
accept
)

16 
size_t
 
count
;

17 
size_t
 
i
;

19 
count
 = 0;

20 
i
 = 0;

21 while (
s
[
i
] && 
	`ft_strchr
(
accept
, s[i]) != 0)

23 
count
++;

24 
i
++;

26 return (
count
);

27 
	}
}

	@sauvegarde/libft/libft/ft_strtrim.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strtrim
(char const *
s1
, char const *
set
)

16 unsigned int 
front
;

17 unsigned int 
end
;

18 unsigned int 
i
;

19 char *
strtrim
;

21 
front
 = 0;

22 
i
 = 0;

23 
end
 = (unsigned int)(
	`ft_strlen
(
s1
));

24 while (
s1
[
front
] != '\0' && 
	`ft_strchr
(
set
, *(s1 + front)) != 
NULL
)

25 
front
++;

26 while (
front
 < 
end
 && 
	`ft_strrchr
(
set
, *(
s1
 + end - 1)) != 
NULL
)

27 
end
--;

28 
strtrim
 = (char *)
	`malloc
((
end
 - 
front
 + 1) * sizeof(char));

29 if (!
strtrim
)

30 return (
NULL
);

31 
i
 = 0;

32 while (
front
 < 
end
)

33 
strtrim
[
i
++] = 
s1
[
front
++];

34 
strtrim
[
i
] = 0;

35 return (
strtrim
);

36 
	}
}

	@sauvegarde/libft/libft/ft_substr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
)

16 char *
substr
;

17 unsigned int 
i
;

18 
size_t
 
size
;

20 
i
 = 0;

21 if (!
s
)

22 return (
NULL
);

23 
size
 = 
	`ft_strlen
(
s
);

24 if (
len
 > 
size
)

25 
len
 = 
size
;

26 if (
start
 >= (unsigned int)
size
)

28 
substr
 = (char *)
	`malloc
(1 * sizeof(char));

29 if (!
substr
)

30 return (
NULL
);

31 
substr
[0] = '\0';

32 return (
substr
);

34 
substr
 = (char *)
	`malloc
((
len
 + 1) * sizeof(char));

35 if (!
substr
)

36 return (
NULL
);

37 while (
i
 < (unsigned int)
len
 && 
s
[
start
] != '\0' )

38 
substr
[
i
++] = 
s
[
start
++];

39 
substr
[
i
] = '\0';

40 return (
substr
);

41 
	}
}

	@sauvegarde/libft/libft/ft_tolower.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_tolower
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

17 return (
c
 + 32);

19 return (
c
);

20 
	}
}

	@sauvegarde/libft/libft/ft_toupper.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_toupper
(int 
c
)

16 if (
c
 >= 'a' && c <= 'z')

17 return (
c
 - 32);

19 return (
c
);

20 
	}
}

	@sauvegarde/libft/libft/power.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$power
(int 
str_base
, int 
power
)

16 int 
result
;

18 
result
 = 1;

19 if (
power
 < 0 || 
str_base
 == 0)

23 while (
power
 > 0)

25 
result
 = result * 
str_base
;

26 
power
--;

28 return (
result
);

29 
	}
}

	@sauvegarde/libft/libft/str_lowercase.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$str_lowercase
(char *
str
)

16 int 
i
;

18 
i
 = 0;

19 while (
str
[
i
])

21 if (
str
[
i
] >= 'A' && str[i] <= 'Z')

22 
str
[
i
] += 32;

23 
i
++;

25 return (
str
);

26 
	}
}

	@sauvegarde/main.c

13 #include 
	~"minishell.h
"

15 
t_shell
 *
	gg_shell
;

19 char *
	$readline_routine
(void)

21 char *
line
;

23 
line
 = 
NULL
;

24 
line
 = 
	`readline
(
BLU_2
"minishell$ "
RESET
);

25 if (!
line
)

27 
	`rl_clear_history
();

28 return (
NULL
) ;

30 if (
line
[0])

31 
	`add_history
(
line
);

32 return (
line
);

33 
	}
}

35 void 
	$print_cmd
(
t_cmd
 **
head
)

37 
t_cmd
 *
ptr
;

38 int 
i
 = 0;

39 int 
j
 = 0;

41 
ptr
 = *
head
;

42 while (
ptr
)

44 if (
ptr
->
cmd
)

46 while(
ptr
->
cmd
[
j
])

48 
	`ft_printf
("cmd[%d] = %s\n", 
i
, 
ptr
->
cmd
[
j
]);

49 
j
++;

52 
j
 = 0;

53 if (
ptr
->
redir
)

55 while (
ptr
->
redir
[
j
])

57 
	`ft_printf
("redir[%d] = %s\n", 
i
, 
ptr
->
redir
[
j
]);

58 
j
++;

61 
j
 = 0;

62 
i
++;

63 
ptr
 = ptr->
next
;

65 
	}
}

68 int 
	$main
(int 
ac
, char **
av
, char **
envp
)

70 (void)
av
;

71 (void)
ac
;

72 char *
line
;

73 
t_token
 *
token
;

74 
t_cmd
 *
cmd
;

76 if (!
	`init_shell
(
envp
))

78 if (
	`sig_handler
() == -1)

82 
line
 = 
	`readline_routine
();

83 if (!
line
)

85 
token
 = 
	`parsing
(
line
);

86 
cmd
 = 
	`cmd_linked_list
(&
token
);

87 
	`print_cmd
(&
cmd
);

88 
	`check_then_execute
(
token
, &
cmd
);

89 
	`free_token
(&
token
);

90 
	`free_cmd
(&
cmd
);

92 
	`free_shell
();

94 
	}
}

	@sauvegarde/malloc_error_print_message.c

12 #include 
	~"minishell.h
"

14 void 
	$malloc_error_print_message
(char *
s
)

16 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
s
);

17 
g_shell
->
exit_status
 = 1;

18 
	}
}

	@sauvegarde/minishell.h

13 #ifndef 
MINISHELL_H


14 #define 
	#MINISHELL_H


	)

16 #include 
	~<stdio.h
>

17 #include 
	~<string.h
>

18 #include 
	~<stdlib.h
>

19 #include 
	~<errno.h
>

20 #include 
	~<curses.h
>

21 #include 
	~<term.h
>

22 #include 
	~<signal.h
>

23 #include 
	~<unistd.h
>

24 #include 
	~<fcntl.h
>

25 #include 
	~<stdarg.h
>

26 #include 
	~<sys/wait.h
>

27 #include 
	~<sys/stat.h
>

28 #include 
	~<sys/types.h
>

29 #include 
	~<readline/readline.h
>

30 #include 
	~<readline/history.h
>

31 #include 
	~"libft/includes/libft.h
"

34 #define 
	#RED
 "\x1b[31m"

	)

35 #define 
	#BLU
 "\x1B[34m"

	)

36 #define 
	#BLU_2
 "\e[1;34m"

	)

37 #define 
	#GRN
 "\x1B[32m"

	)

38 #define 
	#YEL
 "\x1B[33m"

	)

39 #define 
	#MAG
 "\x1B[35m"

	)

40 #define 
	#CYN
 "\x1B[36m"

	)

41 #define 
	#WHT
 "\x1B[37m"

	)

42 #define 
	#RESET
 "\x1B[0m"

	)

44 #define 
	#WORD
 1

	)

45 #define 
	#PIPELINE
 2

	)

46 #define 
	#L_CHEVRON
 3

	)

47 #define 
	#R_CHEVRON
 4

	)

48 #define 
	#APPEND
 5

	)

49 #define 
	#HERE_DOC
 6

	)

50 #define 
	#DOLLAR
 7

	)

51 #define 
	#QUESTION
 8

	)

52 #define 
	#EXPAND
 9

	)

53 #define 
	#DELETE
 10

	)

54 #define 
	#EXPANDED
 11

	)

55 #define 
	#CONTINUE
 -1

	)

56 #define 
	#ERROR_EXIT
 -169

	)

57 #define 
	#ERROR_EXIT_
 0

	)

62 typedef struct 
	ss_env


64 char *
	mvar_name
;

65 char *
	mvar_value
;

66 struct 
s_env
 *
	mnext
;

67 } 
	tt_env
;

69 typedef struct 
	ss_token


71 char *
	mcontent
;

72 int 
	mid
;

73 struct 
s_token
 *
	mnext
;

74 } 
	tt_token
;

77 typedef struct 
	ss_cmd


81 char **
	mcmd
;

82 char **
	mredir
;

83 char **
	mpath
;

87 int 
	mfdout
;

88 int 
	mfdin
;

89 int 
	mfd
[2];

90 struct 
s_cmd
 *
	mnext
;

91 } 
	tt_cmd
;

93 typedef struct 
	ss_shell


95 
t_env
 *
	menv
;

96 int 
	mexit_status
;

97 char **
	msave_env
;

98 } 
	tt_shell
;

100 typedef struct 
	ss_bin


102 char *
	mpath
;

103 char **
	msplitted_path
;

104 char *
	mcmd
;

105 int 
	mok
;

106 
pid_t
 
	mchild
;

107 } 
	tt_bin
;

109 extern 
t_shell
 *
g_shell
;

112 int 
_pwd
(
t_cmd
 *
cmd
);

113 int 
_env
(
t_env
 *
env
);

114 int 
_echo
(
t_cmd
 *
cmd
);

117 void 
check_then_execute
(
t_token
 *
token
, 
t_cmd
 **
cmd
);

118 char **
copy_env_tab
(
t_env
 *
env
);

121 int 
cmd_is_bin
(
t_token
 *
token
, 
t_bin
 *
bin
);

122 int 
cmd_is_builtin
(
t_token
 *
token
);

125 
t_cmd
 *
init_cmd
(
t_token
 **
head
);

126 void 
create_cmd
(
t_token
 **
token
, 
t_cmd
 *
cmd
);

127 
t_cmd
 *
cmd_linked_list
(
t_token
 **
token
);

128 void 
free_cmd
(
t_cmd
 **
head
);

131 int 
expansion
(
t_token
 **
token
, t_token *
curr
, int 
pos
);

132 int 
check_dollar
(
t_token
 *
curr
, int 
i
);

133 int 
trim_dollar
(
t_token
 *
curr
, int 
pos
);

136 int 
is_dollar_to_expand
(
t_token
 *
curr
, int 
i
);

137 int 
not_within_squotes
(
t_token
 *
curr
, int 
pos
);

140 int 
trim_dollar
(
t_token
 *
curr
, int 
pos
);

143 int 
loop_dollars
(char *
s
, int 
i
);

144 int 
loop_through
(char *
s
, int 
i
);

147 int 
size_var
(char *
s
);

148 int 
check_var_exist
(
t_token
 *
tmp
);

151 int 
join_tokens
(
t_token
 **
new
, t_token *
curr
);

154 int 
prepare_expand
(
t_token
 *
tmp
, int 
i
);

155 int 
set_id_expansion
(
t_token
 *
token
);

158 int 
quote_removing
(
t_token
 **
head
, t_token *
curr
, int 
pos
);

160 
t_token
 *
delete_token
(t_token **
head
);

161 int 
token_list_size
(
t_token
 **
head
);

164 
t_token
 *
parsing
(char *
line
);

165 int 
syntax_error_check
(char *
s
);

166 int 
check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
);

167 int 
check_quotes_errors
(char *
s
, char 
c
, int *
i
);

168 int 
count_metachar
(char *
s
, char 
c
, int 
num
);

169 int 
check_multiple_operators_error
(int 
i
, int 
num
, char 
c
);

170 void 
print_syntax_error_char
(char 
c
);

171 void 
print_syntax_error_dchar
(char 
c
);

172 void 
print_syntax_error_str
(char *
s
);

175 int 
character_extraction
(char *
line
, int 
ind
);

176 int 
token_extraction
(char *
line
, int 
ind
);

177 
t_token
 *
get_tokens
(char *
line
);

178 int 
get_tokens_size
(char *
line
, int *
i
);

179 
t_token
 *
create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
);

182 void 
malloc_error_print_message
(char *
s
);

185 
t_token
 *
new_token
(char *
line
, int 
start
, int 
len
);

186 void 
set_id
(
t_token
 *
token
);

187 int 
token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
);

188 int 
link_token
(
t_token
 **
head
, t_token *
new
);

189 void 
free_token
(
t_token
 **
head
);

192 int 
is_dollar
(char 
c
);

193 int 
is_pipeline
(char 
c
);

194 int 
is_chevron
(char 
c
);

195 int 
is_lchevron
(char 
c
);

196 int 
is_rchevron
(char 
c
);

197 int 
is_operator
(char 
c
);

198 int 
is_newline
(char 
c
);

199 int 
is_white_space
(char 
c
);

200 int 
is_blank
(char 
c
);

201 int 
is_metacharacter
(char 
c
);

202 int 
is_delimiter
(char 
c
);

203 int 
is_word
(char 
c
);

204 int 
is_double_quote
(char 
c
);

205 int 
is_simple_quote
(char 
c
);

206 int 
is_quote
(char 
c
);

207 int 
is_question
(char 
c
);

208 int 
is_punct
(char 
c
);

211 int 
init_shell
(char **
envp
);

212 int 
shell_no_env
();

213 void 
free_shell
(void);

216 int 
sig_handler
(void);

219 void 
handler_ctr_c
(int 
code
);

222 char **
ft_splitpath
(char *
s
, char 
c
);

226 
t_env
 *
get_envp
(char **
envp
);

227 void 
free_env
(
t_env
 **
head
);

	@sauvegarde/parsing/expansion.c

12 #include 
	~"minishell.h
"

41 int 
	$check_dollar
(
t_token
 *
curr
, int 
i
)

43 int 
res
;

45 while (
curr
->
content
[
i
])

47 if (
	`is_dollar
(
curr
->
content
[
i
]) && 
	`not_within_squotes
(curr, i))

49 if (
	`is_dollar_to_expand
(
curr
, 
i
))

50 return (
	`prepare_expand
(
curr
, 
i
));

51 else if (
	`is_dollar
(
curr
->
content
[
i
 + 1]))

52 
i
 = 
	`loop_dollars
(
curr
->
content
, i);

53 else if (
	`is_quote
(
curr
->
content
[
i
 + 1]))

55 
res
 = 
	`trim_dollar
(
curr
, 
i
);

56 if (
res
 == 
ERROR_EXIT
)

57 return (
ERROR_EXIT
);

58 
i
 += 
res
;

60 else if (
curr
->
content
[
i
 + 1] == '\0')

63 
i
++;

66 
i
++;

68 
curr
->
id
 = 
WORD
;

69 return (
i
);

70 
	}
}

72 static void 
	$expansion_next_token
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

74 
pos
 = 0;

75 if (
curr
->
next
)

77 
curr
 = curr->
next
;

78 
	`expansion
(
head
, 
curr
, 
pos
);

80 
	}
}

106 int 
	$expansion
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

108 if (
curr
)

110 if (
curr
->
id
 == 
DOLLAR
)

112 
pos
 = 
	`check_dollar
(
curr
, pos);

113 if (
pos
 == 
ERROR_EXIT
)

114 return (
	`free_token
(
head
), 0);

115 if (
curr
->
id
 == 
DELETE
)

117 
curr
 = 
	`delete_token
(
head
);

118 if (!
curr
)

120 
head
 = 
NULL
;

123 
pos
 = 0;

125 
	`expansion
(
head
, 
curr
, 
pos
);

128 
	`expansion_next_token
(
head
, 
curr
, 
pos
);

131 
	}
}

	@sauvegarde/parsing/expansion_dollar_conditions.c

12 #include 
	~"minishell.h
"

14 int 
	$not_within_squotes
(
t_token
 *
curr
, int 
pos
)

16 int 
i
;

17 int 
start
;

19 
i
 = 0;

20 
start
 = 0;

21 if (!
	`is_dollar
(
curr
->
content
[
pos
]))

23 while (
curr
->
content
[
i
])

25 if (
	`is_double_quote
(
curr
->
content
[
i
]))

26 
i
 = 
	`loop_through
(
curr
->
content
, i);

27 else if (
	`is_simple_quote
(
curr
->
content
[
i
]))

29 
start
 = 
i
;

30 
i
 = 
	`loop_through
(
curr
->
content
, i);

31 if (
pos
 > 
start
 && pos < 
i
)

34 
i
++;

37 
	}
}

39 int 
	$is_dollar_to_expand
(
t_token
 *
curr
, int 
i
)

41 if (
	`is_question
(
curr
->
content
[
i
 + 1]) || \

42 (!
	`is_dollar
(
curr
->
content
[
i
 + 1]) && \

43 !
	`is_quote
(
curr
->
content
[
i
 + 1]) && \

44 !
	`is_punct
(
curr
->
content
[
i
 + 1]) && \

45 !
	`is_white_space
(
curr
->
content
[
i
 + 1]) && \

46 
curr
->
content
[
i
 + 1] != '\0'))

51 
	}
}

	@sauvegarde/parsing/expansion_expand_var_helper.c

12 #include 
	~"minishell.h
"

14 static int 
	$replace_content
(
t_token
 *
tmp
, char *
s
)

16 
	`free
(
tmp
->
content
);

17 
tmp
->
content
 = 
NULL
;

18 
tmp
->
content
 = 
	`ft_strdup
(
s
);

19 if (!
tmp
->
content
)

21 
	`malloc_error_print_message
("ft_strdup failed");

22 return (
ERROR_EXIT
);

25 
	}
}

27 int 
	$check_var_exist
(
t_token
 *
tmp
)

29 if (
	`ft_strncmp
(&
tmp
->
content
[1], "?", 1) == 0)

31 return (
	`replace_content
(
tmp
, 
	`ft_itoa
(
g_shell
->
exit_status
)));

33 else if (
g_shell
 && g_shell->
env
 && g_shell->env->
var_name
)

35 if (
	`ft_strncmp
(
g_shell
->
env
->
var_name
, &
tmp
->
content
[1], \

36 
	`ft_strlen
(
tmp
->
content
)) == 0)

38 return (
	`replace_content
(
tmp
, 
g_shell
->
env
->
var_value
));

42 
	}
}

44 int 
	$size_var
(char *
s
)

46 int 
i
;

47 int 
count
;

49 
i
 = 0;

50 
count
 = 0;

51 while (
s
[
i
] && 
	`is_white_space
(s[i]))

52 
i
++;

53 while (
s
[
i
] && !
	`is_white_space
(s[i]))

55 
count
++;

56 
i
++;

58 return (
count
);

59 
	}
}

	@sauvegarde/parsing/expansion_helper.c

12 #include 
	~"minishell.h
"

14 int 
	$expand_var
(
t_token
 **
new
)

16 
t_token
 *
tmp
;

17 
t_env
 *
save
;

18 int 
res
;

20 
tmp
 = *
new
;

21 
save
 = 
g_shell
->
env
;

22 while (
tmp
->
id
 != 
EXPAND
)

23 
tmp
 = tmp->
next
;

24 while (
g_shell
->
env
)

26 
res
 = 
	`check_var_exist
(
tmp
);

27 if (
res
 == 
ERROR_EXIT
)

28 return (
ERROR_EXIT
);

29 else if (
res
 == 1)

31 
tmp
->
id
 = 
EXPANDED
;

32 
g_shell
->
env
 = 
save
;

33 return (
	`size_var
(
tmp
->
content
));

35 
g_shell
->
env
 = g_shell->env->
next
;

37 
tmp
->
id
 = 
DELETE
;

38 
g_shell
->
env
 = 
save
;

40 
	}
}

42 int 
	$split_tokens
(
t_token
 **
new
, char *
s
, int 
start
, int 
len
)

44 if (
start
 != 0)

46 *
new
 = 
	`new_token
(
s
, 0, 
start
);

47 if (!*
new
)

48 return (
ERROR_EXIT
);

49 (*
new
)->
id
 = 
WORD
;

50 if (!
	`token_linked_list
(
new
, 
s
, 
start
, 
len
))

51 return (
ERROR_EXIT
);

52 (*
new
)->
next
->
id
 = 
EXPAND
;

56 *
new
 = 
	`new_token
(
s
, 
start
, 
len
);

57 if (!*
new
)

58 return (
ERROR_EXIT
);

59 (*
new
)->
id
 = 
EXPAND
;

61 
start
 += 
len
;

62 
len
 = 
start
;

63 while (
s
[
len
])

64 
len
++;

65 if (
len
 != 
start
)

66 if (!
	`token_linked_list
(
new
, 
s
, 
start
, 
len
))

67 return (
ERROR_EXIT
);

69 
	}
}

71 static int 
	$var_len
(char *
s
, int 
i
)

73 int 
len
;

75 
len
 = 0;

76 
i
++;

77 if (
	`is_question
(
s
[
i
]))

81 while (
s
[
i
] && \

82 !
	`is_white_space
(
s
[
i
]) && \

83 !
	`is_quote
(
s
[
i
]) && \

84 !
	`is_question
(
s
[
i
]) && \

85 !
	`is_dollar
(
s
[
i
]) && \

86 !
	`is_punct
(
s
[
i
]))

88 
i
++;

89 
len
++;

92 return (
len
);

93 
	}
}

95 int 
	$new_id
(
t_token
 **
new
)

97 
t_token
 *
ptr
;

99 
ptr
 = *
new
;

100 while (
ptr
)

102 if (
ptr
->
id
 == 
DELETE
 || ptr->id == 
EXPANDED
)

104 
ptr
 = ptr->
next
;

106 if (
ptr
->
next
 == 
NULL
)

107 return (
WORD
);

108 return (
	`set_id_expansion
(
ptr
->
next
));

109 
	}
}

116 int 
	$prepare_expand
(
t_token
 *
curr
, int 
i
)

118 
t_token
 *
new
;

119 int 
len
;

120 int 
id
;

122 
new
 = 
NULL
;

123 
len
 = 
	`var_len
(
curr
->
content
, 
i
);

124 if (
	`split_tokens
(&
new
, 
curr
->
content
, 
i
, 
len
 + 1) == 
ERROR_EXIT
)

125 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

126 
len
 = 
	`expand_var
(&
new
);

127 if (
len
 == 
ERROR_EXIT
)

128 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

129 
id
 = 
	`new_id
 (&
new
);

130 if (
	`join_tokens
(&
new
, 
curr
) == 
ERROR_EXIT
)

131 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

132 if (
curr
->
id
 == 
DELETE
)

134 
curr
->
id
 = id ;

135 return (
len
 + 
i
);

136 
	}
}

	@sauvegarde/parsing/expansion_join_tokens.c

12 #include 
	~"minishell.h
"

14 static int 
	$get_expanded_size
(char *
s
, int 
i
)

16 int 
size
;

18 
size
 = 0;

19 while (
	`is_white_space
(
s
[
i
]))

20 
i
++;

21 while (
s
[
i
] && !
	`is_white_space
(s[i]))

23 
i
++;

24 
size
++;

26 return (
size
);

27 
	}
}

29 static int 
	$get_new_size
(
t_token
 **
new
)

31 
t_token
 *
ptr
;

32 int 
size
;

33 int 
i
;

35 
size
 = 0;

36 
ptr
 = *
new
;

37 while (
ptr
)

39 
i
 = 0;

40 if (
ptr
->
id
 == 
EXPANDED
)

41 
size
 += 
	`get_expanded_size
(
ptr
->
content
, 
i
);

42 else if (
ptr
->
id
 != 
DELETE
)

44 while (
ptr
->
content
[
i
])

46 
size
++;

47 
i
++;

50 
ptr
 = ptr->
next
;

52 return (
size
);

53 
	}
}

55 static void 
	$copy_helper
(
t_token
 **
new
, t_token *
curr
)

57 int 
i
;

58 int 
j
;

59 
t_token
 *
ptr
;

61 
i
 = 0;

62 
j
 = 0;

63 
ptr
 = *
new
;

64 while (
ptr
)

66 if (
ptr
->
id
 == 
EXPANDED
)

68 while (
ptr
->
content
[
j
] && 
	`is_white_space
(ptr->content[j]))

69 
j
++;

70 while (
ptr
->
content
[
j
] && !
	`is_white_space
(ptr->content[j]))

71 
curr
->
content
[
i
++] = 
ptr
->content[
j
++];

73 else if (
ptr
->
id
 != 
DELETE
)

74 while (
ptr
->
content
[
j
])

75 
curr
->
content
[
i
++] = 
ptr
->content[
j
++];

76 
ptr
 = ptr->
next
;

77 
j
 = 0;

79 
curr
->
content
[
i
] = '\0';

80 
	}
}

82 static int 
	$copy_join_tokens
(
t_token
 **
new
, t_token *
curr
, int 
size
)

84 
	`free
(
curr
->
content
);

85 
curr
->
content
 = 
NULL
;

86 
curr
->
content
 = 
	`malloc
((
size
 + 1) * sizeof(char));

87 if (!
curr
->
content
)

89 
	`malloc_error_print_message
(
	`strerror
(
errno
));

90 return (
ERROR_EXIT
);

92 
	`copy_helper
(
new
, 
curr
);

93 
	`free_token
(
new
);

95 
	}
}

97 int 
	$join_tokens
(
t_token
 **
new
, t_token *
curr
)

99 int 
size
;

101 
size
 = 
	`get_new_size
(
new
);

102 if (
size
 == 0)

104 
	`free_token
(
new
);

105 
curr
->
id
 = 
DELETE
;

108 if (
	`copy_join_tokens
(
new
, 
curr
, 
size
) == 
ERROR_EXIT
)

109 return (
ERROR_EXIT
);

111 
	}
}

	@sauvegarde/parsing/expansion_looping.c

12 #include 
	~"minishell.h
"

53 int 
	$loop_dollars
(char *
s
, int 
i
)

55 while (
	`is_dollar
(
s
[
i
]) && s[i])

56 
i
++;

57 if (
s
[
i
] != '\0' && !
	`is_white_space
(s[i]))

58 
i
--;

59 return (
i
);

60 
	}
}

68 int 
	$loop_through
(char *
s
, int 
i
)

70 char 
c
;

72 
c
 = 
s
[
i
];

73 
i
++;

74 while (
s
[
i
] != 
c
)

75 
i
++;

76 return (
i
);

77 
	}
}

	@sauvegarde/parsing/expansion_test/copy_env_tab.c

12 #include 
	~"minishell.h
"

14 int 
	$column_size
(
t_env
 **
head
)

16 
t_env
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

29 char *
	$name_plus_value
(char *
name
, char *
value
)

31 char *
joined
;

32 int 
len_name
;

33 int 
len_value
;

34 int 
i
;

35 int 
j
;

37 
i
 = 0;

38 
j
 = 0;

39 
len_name
 = 
	`ft_strlen
(
name
);

40 
len_value
 = 
	`ft_strlen
(
value
);

41 
joined
 = 
	`malloc
(sizeof(char) * (
len_name
 + 
len_value
 + 2));

42 if (!
joined
)

43 return (
NULL
);

44 while (
i
 < 
len_name
)

45 
joined
[
i
++] = 
name
[
j
++];

46 
joined
[
i
] = '=';

47 
j
 = 0;

48 while (
j
 < 
len_value
)

49 
joined
[
i
++] = 
value
[
j
++];

50 
joined
[
i
] = '\0';

51 return (
joined
);

52 
	}
}

54 char **
	$copy_env_tab
(
t_env
 *
env
)

56 char **
res
;

57 int 
column
;

58 int 
i
;

60 
i
 = 0;

61 
column
 = 
	`column_size
(&
env
);

63 
res
 = 
	`malloc
(sizeof(char *) * (
column
 + 1));

64 if (!
res
)

65 return (
NULL
);

66 while (
env
)

68 
res
[
i
] = 
	`name_plus_value
(
env
->
var_name
, env->
var_value
);

70 if (!
res
[
i
])

71 return (
NULL
);

72 
i
++;

73 
env
 = env->
next
;

75 
res
 = 
NULL
;

76 return (
res
);

77 
	}
}

	@sauvegarde/parsing/expansion_test/envp_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_env
(
t_env
 **
head
)

16 
t_env
 *
ptr
;

17 
t_env
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
var_name
);

27 
	`free
(
tmp
->
var_value
);

28 
	`free
(
tmp
);

30 *
head
 = 
NULL
;

31 
	}
}

40 
t_env
 *
	$new_env
(char *
envp
)

42 
t_env
 *
env
;

43 int 
end
;

44 int 
start
;

46 if (!
envp
)

47 return (
NULL
);

48 
start
 = 0;

49 
end
 = 0;

50 
env
 = 
	`malloc
(sizeof(
t_env
));

51 if (!
env
)

52 return (
	`malloc_error_print_message
(
	`strerror
(
errno
)), 
NULL
);

53 while (
envp
[
end
] != '=')

54 
end
++;

55 
env
->
var_name
 = 
	`ft_substr
(
envp
, 0, 
end
);

56 if (!
env
->
var_name
)

57 return (
NULL
);

58 
end
++;

59 
start
 = 
end
;

60 while (
envp
[
end
] != '\0')

61 
end
++;

62 
env
->
var_value
 = 
	`ft_substr
(
envp
, 
start
, 
end
 - start);

63 if (!
env
->
var_value
)

64 return (
	`malloc_error_print_message
("ft stubstr failed"), 
NULL
);

65 
env
->
next
 = 
NULL
;

66 return (
env
);

67 
	}
}

72 int 
	$link_env
(
t_env
 **
head
, t_env *
last
)

74 
t_env
 *
ptr
;

76 if (!
last
)

78 
ptr
 = *
head
;

79 while (
ptr
)

81 if (!
ptr
->
next
)

83 
ptr
 = ptr->
next
;

85 
ptr
->
next
 = 
last
;

87 
	}
}

100 
t_env
 *
	$get_envp
(char **
envp
)

102 
t_env
 **
head
;

103 
t_env
 *
env
;

104 int 
i
;

106 
i
 = 0;

107 
head
 = 
NULL
;

108 if (!
envp
)

109 return (
NULL
);

110 
env
 = 
	`new_env
(
envp
[
i
]);

111 if (!
env
)

112 return (
NULL
);

113 
head
 = &
env
;

114 
i
++;

115 while (
envp
[
i
])

117 if (
	`link_env
(
head
, 
	`new_env
(
envp
[
i
])) < 0)

118 return (
	`free_env
(
head
), 
NULL
);

119 
i
++;

121 return (*
head
);

122 
	}
}

	@sauvegarde/parsing/expansion_test/is_dollar.c

12 #include 
	~"minishell.h
"

16 int 
	$is_dollar
(char 
c
)

18 if (
c
 == '$')

21 
	}
}

	@sauvegarde/parsing/expansion_test/is_operator.c

12 #include 
	~"minishell.h
"

16 int 
	$is_pipeline
(char 
c
)

18 if (
c
 == '|')

21 
	}
}

25 int 
	$is_lchevron
(char 
c
)

27 if (
c
 == '<')

30 
	}
}

32 int 
	$is_rchevron
(char 
c
)

34 if (
c
 == '>')

37 
	}
}

39 int 
	$is_chevron
(char 
c
)

41 if (
	`is_lchevron
(
c
) || 
	`is_rchevron
(c))

44 
	}
}

48 int 
	$is_operator
(char 
c
)

50 if (
	`is_pipeline
(
c
) || 
	`is_chevron
(c))

53 
	}
}

	@sauvegarde/parsing/expansion_test/is_question.c

12 #include 
	~"minishell.h
"

14 int 
	$is_question
(char 
c
)

16 if (
c
 == '?')

19 
	}
}

21 int 
	$is_punct
(char 
c
)

23 if ((
c
 >= 33 && c <= 47) || \

24 (
c
 >= 58 && c <= 64) || \

25 (
c
 >= 91 && c <= 94) || \

26 (
c
 == 96) || \

27 (
c
 >= 123 && c <= 126))

30 
	}
}

	@sauvegarde/parsing/expansion_test/is_quote.c

12 #include 
	~"minishell.h
"

16 int 
	$is_double_quote
(char 
c
)

18 if (
c
 == '\"')

21 
	}
}

23 int 
	$is_simple_quote
(char 
c
)

25 if (
c
 == '\'')

28 
	}
}

30 int 
	$is_quote
(char 
c
)

32 if (
	`is_double_quote
(
c
) || 
	`is_simple_quote
(c))

35 
	}
}

	@sauvegarde/parsing/expansion_test/is_token.c

12 #include 
	~"minishell.h
"

16 int 
	$is_metacharacter
(char 
c
)

18 if (
	`is_blank
(
c
) || 
	`is_newline
(c) || 
	`is_operator
(c))

21 
	}
}

25 int 
	$is_delimiter
(char 
c
)

27 if (
	`is_metacharacter
(
c
))

30 
	}
}

34 int 
	$is_word
(char 
c
)

36 if (!
	`is_delimiter
(
c
))

39 
	}
}

	@sauvegarde/parsing/expansion_test/is_white_space.c

12 #include 
	~"minishell.h
"

14 int 
	$is_blank
(char 
c
)

16 if (
c
 == ' ' || c == '\t')

19 
	}
}

21 int 
	$is_newline
(char 
c
)

23 if (
c
 == '\n')

26 
	}
}

28 int 
	$is_white_space
(char 
c
)

30 if (
	`is_blank
(
c
) || 
	`is_newline
(c))

33 
	}
}

	@sauvegarde/parsing/expansion_test/libft/ft_printf/ft_count_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_int
(int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

	@sauvegarde/parsing/expansion_test/libft/ft_printf/ft_count_unsigned_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_count_unsigned_int
(unsigned int 
n
)

16 int 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 else if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 return (
count
);

30 
	}
}

	@sauvegarde/parsing/expansion_test/libft/ft_printf/ft_dprintf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 
fd
, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 
fd
, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 
fd
, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 
fd
, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 
fd
, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 
fd
, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_dprintf
(int 
fd
, const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 
fd
, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 
fd
, &
count
);

50 
	`ft_format_specifier_fd
(
last
[
i
 + 1], 
ap
, &
count
, 
fd
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@sauvegarde/parsing/expansion_test/libft/ft_printf/ft_printf.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_format_specifier
(char 
format
, 
va_list
 
ap
, int *
count
)

16 if (
format
 == '%')

17 
	`ft_printf_char
(
format
, 1, 
count
);

18 else if (
format
 == 'c')

19 
	`ft_printf_char
(
	`va_arg
(
ap
, int), 1, 
count
);

20 else if (
format
 == 's')

21 
	`ft_printf_str
(
	`va_arg
(
ap
, char *), 1, 
count
);

22 else if (
format
 == 'd' || format == 'i')

23 
	`ft_printf_int
(
	`va_arg
(
ap
, int), 1, 
count
);

24 else if (
format
 == 'u')

25 
	`ft_printf_unsint
(
	`va_arg
(
ap
, unsigned int), 1, 
count
);

26 else if (
format
 == 'p')

27 
	`ft_printf_address
(
	`va_arg
(
ap
, 
uintptr_t
), 1, 
count
);

28 else if (
format
 == 'x' || format == 'X')

29 
	`ft_printf_hexa
(
	`va_arg
(
ap
, int), 1, 
count
, 
format
);

30 
	}
}

32 int 
	$ft_printf
(const char *
last
, ...)

34 
va_list
 
ap
;

35 
size_t
 
i
;

36 int 
count
;

38 
	`va_start
(
ap
, 
last
);

39 
i
 = 0;

40 
count
 = 0;

41 while (
last
[
i
] != '\0')

43 if (
last
[
i
] != '%')

44 
	`ft_printf_char
(
last
[
i
], 1, &
count
);

45 else if (
last
[
i
] == '%')

47 if (
last
[
i
 + 1] == '%')

48 
	`ft_printf_char
(
last
[
i
 + 1], 1, &
count
);

50 
	`ft_format_specifier
(
last
[
i
 + 1], 
ap
, &
count
);

51 
i
++;

53 
i
++;

55 
	`va_end
(
ap
);

56 return (
count
);

57 
	}
}

	@sauvegarde/parsing/expansion_test/libft/ft_printf/ft_printf_address.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
);

16 void 
	$ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
)

18 
	`ft_printf_str
("0x", 
fd
, 
count
);

19 
	`ft_put_uintptr_fd
(
n
, 
fd
, 
count
);

20 
	}
}

22 void 
	$ft_put_uintptr_fd
(
uintptr_t
 
n
, int 
fd
, int *
count
)

24 if (
n
 > 15)

26 
	`ft_put_uintptr_fd
(
n
 / 16, 
fd
, 
count
);

27 
	`ft_put_uintptr_fd
(
n
 % 16, 
fd
, 
count
);

29 if (
n
 < 10)

30 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

31 else if (
n
 > 9 && n < 16)

32 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

33 
	}
}

	@sauvegarde/parsing/expansion_test/libft/ft_printf/ft_printf_char.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_char
(char 
c
, int 
fd
, int *
count
)

16 
	`ft_putchar_fd
(
c
, 
fd
);

17 *
count
 += 1;

18 
	}
}

	@sauvegarde/parsing/expansion_test/libft/ft_printf/ft_printf_hexa.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
)

16 if (
n
 > 15)

18 
	`ft_printf_hexa
(
n
 / 16, 
fd
, 
count
, 
c
);

19 
	`ft_printf_hexa
(
n
 % 16, 
fd
, 
count
, 
c
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

25 if (
c
 == 'x')

26 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

27 else if (
c
 == 'X')

28 
	`ft_printf_char
(
n
 + 55, 
fd
, 
count
);

30 
	}
}

	@sauvegarde/parsing/expansion_test/libft/ft_printf/ft_printf_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_int
(int 
n
, int 
fd
, int *
count
)

16 
	`ft_putnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_int
(
n
);

18 
	}
}

	@sauvegarde/parsing/expansion_test/libft/ft_printf/ft_printf_str.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_str
(char *
s
, int 
fd
, int *
count
)

16 int 
i
;

18 
i
 = 0;

19 if (
s
 != 
NULL
)

21 while (
s
[
i
] != '\0')

22 
i
++;

23 
	`ft_putstr_fd
(
s
, 
fd
);

27 
	`ft_putstr_fd
("(null)", 1);

28 
i
 = 6;

30 *
count
 += 
i
;

31 
	}
}

	@sauvegarde/parsing/expansion_test/libft/ft_printf/ft_printf_unsint.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
)

16 
	`ft_put_unsnbr_fd
(
n
, 
fd
);

17 *
count
 += 
	`ft_count_unsigned_int
(
n
);

18 
	}
}

	@sauvegarde/parsing/expansion_test/libft/ft_printf/ft_put_hexanbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_hexanbr_fd
(unsigned int 
n
, int 
fd
, int *
count
)

16 if (
n
 > 15)

18 
	`ft_put_hexanbr_fd
(
n
 / 16, 
fd
, 
count
);

19 
	`ft_put_hexanbr_fd
(
n
 % 16, 
fd
, 
count
);

21 if (
n
 < 10)

22 
	`ft_printf_char
(
n
 + 48, 
fd
, 
count
);

23 else if (
n
 > 9 && n < 16)

24 
	`ft_printf_char
(
n
 + 87, 
fd
, 
count
);

25 
	}
}

	@sauvegarde/parsing/expansion_test/libft/ft_printf/ft_put_int.c

12 #include 
	~"../includes/ft_printf.h
"

14 int 
	$ft_put_int
(int 
n
, int 
fd
, int *
count
)

16 int 
a
;

18 
a
 = *
count
;

19 
	`ft_putnbr_fd
(
n
, 
fd
);

20 
a
 += 
	`ft_count_int
(
n
);

21 return (
a
);

22 
	}
}

	@sauvegarde/parsing/expansion_test/libft/ft_printf/ft_put_unsnbr_fd.c

12 #include 
	~"../includes/ft_printf.h
"

14 void 
	$ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
)

16 if (
n
 > 9)

18 
	`ft_put_unsnbr_fd
(
n
 / 10, 
fd
);

19 
	`ft_put_unsnbr_fd
((
n
 % 10), 
fd
);

22 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

23 
	}
}

	@sauvegarde/parsing/expansion_test/libft/get_next_line/get_next_line.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$create_nextline
(char *
result
, char *
line
)

16 int 
start
;

17 int 
size
;

18 char *
nextline
;

20 
start
 = 
	`ft_strlen_int
(
result
);

21 
size
 = 
	`ft_strlen_int
(
line
);

22 
size
 = size - 
start
;

23 if (
size
 == 0)

25 
	`free
 (
line
);

26 return (
NULL
);

28 
nextline
 = 
	`malloc
((
size
 + 1) * sizeof(char));

29 if (!
nextline
)

30 return (
NULL
);

31 
size
 = 0;

32 while (
line
[
start
] != '\0')

34 
nextline
[
size
] = 
line
[
start
];

35 
size
++;

36 
start
++;

38 
nextline
[
size
] = '\0';

39 
	`free
(
line
);

40 return (
nextline
);

41 
	}
}

55 char *
	$create_result
(char *
line
)

57 int 
i
;

58 char *
result
;

60 
i
 = 
	`there_is_n
(
line
);

61 if (
i
 == -1 && *
line
)

62 
i
 = 
	`ft_strlen_int
(
line
);

63 else if (
i
 == -1 && !*
line
)

64 return (
NULL
);

65 
result
 = 
	`malloc
((
i
 + 1) * sizeof(char));

66 if (!
result
)

67 return (
NULL
);

68 
i
 = 0;

69 while (
line
[
i
] != '\0')

71 
result
[
i
] = 
line
[i];

72 if (
line
[
i
] == '\n')

74 
i
++;

77 
i
++;

79 
result
[
i
] = '\0';

80 return (
result
);

81 
	}
}

94 char *
	$read_fd
(char *
line
, int 
fd
, int *
error
)

96 char *
buffer
;

97 int 
ret
;

99 
ret
 = 1;

100 
	`prepare_forstash
(&
line
, &
buffer
);

101 while (
ret
 > 0 && 
	`there_is_n
(
buffer
) == -1 && there_is_n(
line
) == -1)

103 
ret
 = (int)
	`read
(
fd
, 
buffer
, 
BUFFER_SIZE
);

104 if (
ret
 < 0)

106 
	`free
(
buffer
);

107 *
error
 = -1;

108 return (
NULL
);

110 if (
ret
 == 0)

112 *
error
 = 0;

115 
buffer
[
ret
] = '\0';

116 
line
 = 
	`ft_join
(line, 
buffer
);

118 
	`free
(
buffer
);

119 return (
line
);

120 
	}
}

130 int 
	$check_errors
(int 
fd
, char **
line
)

132 if (
fd
 < 0 || 
BUFFER_SIZE
 <= 0 || 
	`read
(fd, 0, 0) < 0)

134 
	`free
(*
line
);

135 *
line
 = 0;

139 
	}
}

150 char *
	$get_next_line
(int 
fd
)

152 static char *
line
;

153 char *
result
;

154 int 
error
;

156 
error
 = 
	`check_errors
(
fd
, &
line
);

157 if (
error
 == 0)

158 return (
NULL
);

159 
line
 = 
	`read_fd
(line, 
fd
, &
error
);

160 if (
error
 == -1 || (error == 0 && !*
line
))

162 
	`free
(
line
);

163 
line
 = 0;

164 return (
NULL
);

166 if (!
line
)

167 return (
NULL
);

168 
result
 = 
	`create_result
(
line
);

169 if (!
result
)

171 
line
 = 0;

172 
	`free
(
line
);

174 
line
 = 
	`create_nextline
(
result
, line);

175 return (
result
);

176 
	}
}

	@sauvegarde/parsing/expansion_test/libft/get_next_line/get_next_line_bonus.c

12 #include 
	~"../includes/get_next_line.h
"

14 char *
	$get_next_line_maxopen
(int 
fd
)

16 static char *
line
[
OPEN_MAX
];

17 char *
result
;

18 int 
error
;

20 
error
 = 
	`check_errors
(
fd
, &
line
[fd]);

21 if (
error
 == 0)

22 return (
NULL
);

23 
line
[
fd
] = 
	`read_fd
(line[fd], fd, &
error
);

24 if (
error
 == -1 || (error == 0 && !*
line
[
fd
]))

26 
	`free
(
line
[
fd
]);

27 
line
[
fd
] = 0;

28 return (
NULL
);

30 if (!
line
[
fd
])

31 return (
NULL
);

32 
result
 = 
	`create_result
(
line
[
fd
]);

33 if (!
result
)

35 
line
[
fd
] = 0;

36 
	`free
(
line
[
fd
]);

38 
line
[
fd
] = 
	`create_nextline
(
result
, line[fd]);

39 return (
result
);

40 
	}
}

	@sauvegarde/parsing/expansion_test/libft/get_next_line/get_next_line_utils.c

12 #include 
	~"../includes/get_next_line.h
"

14 void 
	$prepare_forstash
(char **
line
, char **
buffer
)

16 *
buffer
 = 
	`ft_calloc_count
(
BUFFER_SIZE
);

17 if (*
line
 == 
NULL
)

18 *
line
 = 
	`ft_calloc_count
(0);

19 
	}
}

21 char *
	$ft_join
(char *
line
, char *
buffer
)

23 int 
i
;

24 int 
j
;

25 char *
stash
;

27 if (!
line
 || !
buffer
)

28 return (
NULL
);

29 
i
 = 
	`ft_strlen_int
(
line
);

30 
j
 = 
	`ft_strlen_int
(
buffer
);

31 
stash
 = 
	`malloc
((
i
 + 
j
 + 1) * sizeof(char));

32 if (!
stash
)

33 return (
NULL
);

34 
i
 = 0;

35 
j
 = 0;

36 while (
line
[
i
] != '\0')

38 
stash
[
i
] = 
line
[i];

39 
i
++;

41 while (
buffer
[
j
] != '\0')

42 
stash
[
i
++] = 
buffer
[
j
++];

43 
stash
[
i
] = '\0';

44 
	`free
(
line
);

45 return (
stash
);

46 
	}
}

48 char *
	$ft_calloc_count
(int 
count
)

50 char *
string
;

51 int 
i
;

53 
i
 = 0;

54 
string
 = 
	`malloc
((
count
 + 1) * sizeof(char));

55 if (!
string
)

56 return (
NULL
);

57 while (
i
 <= 
count
)

59 
string
[
i
] = '\0';

60 
i
++;

62 return (
string
);

63 
	}
}

65 int 
	$ft_strlen_int
(const char *
string
)

67 int 
i
;

69 
i
 = 0;

70 while (
string
[
i
] != '\0')

71 
i
++;

72 return (
i
);

73 
	}
}

75 int 
	$there_is_n
(char *
line
)

77 int 
i
;

79 
i
 = 0;

80 while (
line
[
i
] != '\0')

82 if (
line
[
i
] == '\n')

83 return (
i
 + 1);

84 
i
++;

87 
	}
}

	@sauvegarde/parsing/expansion_test/libft/includes/ft_printf.h

12 #ifndef 
FT_PRINTF_H


13 #define 
	#FT_PRINTF_H


	)

15 #include 
	~"libft.h
"

16 #include 
	~<stdarg.h
>

18 int 
ft_printf
(const char *
last
, ...);

19 void 
ft_printf_char
(char 
c
, int 
fd
, int *
count
);

20 void 
ft_printf_str
(char *
s
, int 
fd
, int *
count
);

21 void 
ft_printf_int
(int 
n
, int 
fd
, int *
count
);

22 int 
ft_count_int
(int 
n
);

23 void 
ft_put_unsnbr_fd
(unsigned int 
n
, int 
fd
);

24 void 
ft_printf_unsint
(unsigned int 
n
, int 
fd
, int *
count
);

25 int 
ft_count_unsigned_int
(unsigned int 
n
);

26 void 
ft_printf_address
(
uintptr_t
 
n
, int 
fd
, int *
count
);

27 void 
ft_printf_hexa
(unsigned int 
n
, int 
fd
, int *
count
, char 
c
);

31 void 
ft_format_specifier_fd
(char 
format
, 
va_list
 
ap
, int *
count
, int 
fd
);

32 int 
ft_dprintf
(int 
fd
, const char *
last
, ...);

	@sauvegarde/parsing/expansion_test/libft/includes/get_next_line.h

12 #ifndef 
GET_NEXT_LINE_H


13 #define 
	#GET_NEXT_LINE_H


	)

15 #include 
	~<unistd.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<limits.h
>

19 #ifndef 
BUFFER_SIZE


20 #define 
	#BUFFER_SIZE
 42

	)

23 char *
ft_calloc_count
(int 
count
);

24 int 
ft_strlen_int
(const char *
string
);

25 char *
ft_join
(char *
nextline
, char *
buffer
);

26 int 
there_is_n
(char *
line
);

27 char *
read_fd
(char *
nextline
, int 
fd
, int *
error
);

28 char *
create_result
(char *
line
);

29 char *
create_nextline
(char *
result
, char *
line
);

30 char *
get_next_line
(int 
fd
);

31 char *
get_next_line_maxopen
(int 
fd
);

32 int 
check_errors
(int 
fd
, char **
line
);

33 void 
prepare_forstash
(char **
line
, char **
buffer
);

	@sauvegarde/parsing/expansion_test/libft/includes/libft.h

12 #ifndef 
LIBFT_H


13 #define 
	#LIBFT_H


	)

15 #include 
	~<stddef.h
>

16 #include 
	~<stdlib.h
>

17 #include 
	~<unistd.h
>

18 #include 
	~"ft_printf.h
"

19 #include 
	~"get_next_line.h
"

21 typedef struct 
	ss_list


23 void *
	mcontent
;

24 struct 
s_list
 *
	mnext
;

25 } 
	tt_list
;

27 void *
ft_memset
(void *
b
, int 
c
, 
size_t
 
len
);

28 void 
ft_bzero
(void *
s
, 
size_t
 
n
);

29 void *
ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
);

30 void *
ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
);

31 void *
ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
);

32 int 
ft_isalpha
(int 
c
);

33 int 
ft_isdigit
(int 
c
);

34 int 
ft_isalnum
(int 
c
);

35 int 
ft_isascii
(int 
c
);

36 int 
ft_isprint
(int 
c
);

37 
size_t
 
ft_strlen
(const char *
s
);

38 int 
ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
);

39 char *
ft_strcpy
(char *
dst
, const char *
src
);

40 
size_t
 
ft_strlcpy
(char *
dst
, const char *
src
, size_t 
dstsize
);

41 
size_t
 
ft_strlcat
(char *
dst
, const char *
src
, size_t 
dstsize
);

42 char *
ft_strchr
(const char *
s
, int 
c
);

43 char *
ft_strrchr
(const char *
s
, int 
c
);

44 char *
ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
);

45 int 
ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
);

46 int 
ft_toupper
(int 
c
);

47 int 
ft_tolower
(int 
c
);

48 int 
ft_atoi
(const char *
str
);

49 void *
ft_calloc
(
size_t
 
count
, size_t 
size
);

50 char *
ft_strdup
(const char *
s1
);

51 char *
ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
);

52 char *
ft_strjoin
(char const *
s1
, char const *
s2
);

53 char *
ft_strtrim
(char const *
s1
, char const *
set
);

54 char **
ft_split
(char const *
s
, char 
c
);

55 char *
ft_itoa
(int 
n
);

56 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char));

57 void 
	`ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*));

58 void 
	`ft_putchar_fd
(char 
c
, int 
fd
);

59 void 
	`ft_putstr_fd
(char *
s
, int 
fd
);

60 void 
	`ft_putendl_fd
(char *
s
, int 
fd
);

61 void 
	`ft_putnbr_fd
(int 
n
, int 
fd
);

64 
t_list
 *
	`ft_lstnew
(void *
content
);

65 void 
	`ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
);

66 int 
	`ft_lstsize
(
t_list
 *
lst
);

67 
t_list
 *
	`ft_lstlast
(t_list *
lst
);

68 void 
	`ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
);

69 void 
	`ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*));

70 void 
	`ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*));

71 void 
	`ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *));

72 
t_list
 *
	`ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *));

73 void 
	`delete_first_el
(
t_list
 **
a
);

74 void 
	`delete_last_el
(
t_list
 **
a
);

75 void 
	`del
(void *
content
);

78 int 
	`power
(int 
str_base
, int 
power
);

79 int 
	`ft_atoi_base
(const char *
str
, int 
str_base
);

80 int 
	`transform
(char 
c
);

81 
size_t
 
	`ft_strcspn
(const char *
s
, const char *
reject
);

82 char *
	`ft_strpbrk
(const char *
s1
, const char *
s2
);

83 
size_t
 
	`ft_strspn
(const char *
s
, const char *
accept
);

84 char *
	`str_lowercase
(char *
str
);

	@sauvegarde/parsing/expansion_test/libft/libft/del.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$del
(void *
content
)

16 if (
content
)

17 
	`free
(
content
);

18 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_atoi.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_atoi
(const char *
str
)

16 int 
i
;

17 int 
result
;

18 int 
sign
;

20 
i
 = 0;

21 
result
 = 0;

22 
sign
 = 1;

23 while (
str
[
i
] == 32 || (str[i] >= 9 && str[i] <= 13))

24 
i
++;

25 if (
str
[
i
] == '-')

27 
sign
 *= (-1);

28 
i
++;

30 else if (
str
[
i
] == '+')

31 
i
++;

32 while (
str
[
i
] >= '0' && str[i] <= '9')

34 
result
 *= 10;

35 
result
 += 
str
[
i
] - 48;

36 
i
++;

38 return (
sign
 * 
result
);

39 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_atoi_base.c

12 #include 
	~"../includes/libft.h
"

13 #include 
	~"../includes/get_next_line.h
"

15 int 
	$transform
(char 
c
)

17 int 
i
;

18 char 
c2
;

20 
i
 = 10;

21 if (
c
 >= 'A' && c <= 'F')

22 
c2
 = 'A';

23 if (
c
 >= 'a' && c <= 'f')

24 
c2
 = 'a';

25 while (
c
 != 
c2
)

27 
c2
++;

28 
i
++;

30 return (
i
);

31 
	}
}

33 int 
	$ft_atoi_base
(const char *
str
, int 
str_base
)

35 int 
i
;

36 int 
count
;

37 int 
result
;

38 int 
sign
;

40 
i
 = 0;

41 
result
 = 0;

42 
count
 = 
	`ft_strlen_int
(
str
) - 1;

43 
sign
 = 1;

44 if (
str
[
i
] == '-')

46 
i
++;

47 
sign
 = -1;

48 
count
--;

50 while (
str
[
i
++] != 0)

52 if (
str
[
i
] >= '0' && str[i] <= '9')

53 
result
 = result + (
str
[
i
] - '0') * 
	`power
(
str_base
, 
count
);

54 if ((
str
[
i
] >= 'A' && str[i] <= 'F') || \

55 (
str
[
i
] >= 'a' && str[i] <= 'f'))

56 
result
 = result + 
	`transform
(
str
[
i
]) * 
	`power
(
str_base
, 
count
);

57 
count
--;

59 return (
result
 * 
sign
);

60 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_bzero.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_bzero
(void *
s
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (
n
 == 0)

21 while (
i
 < 
n
)

23 *(char *)(
s
 + 
i
) = 0;

24 
i
++;

26 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_calloc.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_calloc
(
size_t
 
count
, size_t 
size
)

16 void *
ptr
;

18 
ptr
 = (void *)
	`malloc
(
count
 * 
size
);

19 if (!
ptr
)

20 return (
NULL
);

21 
	`ft_bzero
(
ptr
, (
count
 * 
size
));

22 return (
ptr
);

23 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_isalnum.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalnum
(int 
c
)

16 if (
	`ft_isalpha
(
c
) == 1 || 
	`ft_isdigit
(c) == 1)

20 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_isalpha.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isalpha
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

18 else if (
c
 >= 'a' && c <= 'z')

22 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_isascii.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isascii
(int 
c
)

16 if (
c
 >= 0 && c <= 127)

20 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_isdigit.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isdigit
(int 
c
)

16 if (
c
 >= '0' && c <= '9')

20 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_isprint.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_isprint
(int 
c
)

16 if (
c
 >= 32 && c <= 126)

20 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_itoa.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbchar
(int 
n
)

16 
size_t
 
count
;

18 
count
 = 0;

19 if (
n
 == 0)

20 
count
++;

21 if (
n
 > 0)

23 while (
n
 > 0)

25 
n
 = n / 10;

26 
count
++;

29 if (
n
 < 0)

31 while (
n
 < 0)

33 
n
 = n / 10;

34 
count
++;

36 
count
++;

38 return (
count
);

39 
	}
}

41 char *
	$ft_nb_is_negative
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

43 int 
result
;

45 
result
 = 0;

46 if (
n
 == -2147483648)

48 
n
 = -214748364;

49 
itoa_str
[
nb_char
 - 1] = (char)(8 + 48);

50 
nb_char
--;

52 
n
 *= (-1);

53 while (
n
 > 0)

55 
result
 = (
n
 % 10);

56 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

57 
n
 = n / 10;

58 
nb_char
--;

60 
itoa_str
[--
nb_char
] = '-';

61 return (
itoa_str
);

62 
	}
}

64 char *
	$ft_nb_is_positive
(int 
n
, char *
itoa_str
, 
size_t
 
nb_char
)

66 int 
result
;

68 
result
 = 0;

69 while (
n
 > 0)

71 
result
 = 
n
 % 10;

72 
itoa_str
[
nb_char
 - 1] = (char)(
result
 + 48);

73 
n
 = n / 10;

74 
nb_char
--;

76 return (
itoa_str
);

77 
	}
}

79 char *
	$ft_itoa
(int 
n
)

81 
size_t
 
nb_char
;

82 
size_t
 
buff
;

83 char *
itoa_str
;

85 
buff
 = 0;

86 
nb_char
 = 
	`ft_count_nbchar
(
n
);

87 
itoa_str
 = (char *)
	`ft_calloc
((
nb_char
 + 1), sizeof(char));

88 if (!
itoa_str
)

89 return (
NULL
);

90 while (
buff
 < 
nb_char
)

92 
itoa_str
[
buff
] = '0';

93 
buff
++;

95 if (
n
 == 0)

96 
itoa_str
[0] = (char)(0 + 48);

97 else if (
n
 < 0)

98 
itoa_str
 = 
	`ft_nb_is_negative
(
n
, itoa_str, 
nb_char
);

99 else if (
n
 > 0)

100 
itoa_str
 = 
	`ft_nb_is_positive
(
n
, itoa_str, 
nb_char
);

101 return (
itoa_str
);

102 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_lstadd_back.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_back
(
t_list
 **
lst
, t_list *
new
)

16 
t_list
 *
lstlast
;

18 if (*
lst
 == 
NULL
)

19 *
lst
 = 
new
;

20 else if (!
lst
 || !
new
)

24 
lstlast
 = 
	`ft_lstlast
(*
lst
);

25 
lstlast
->
next
 = 
new
;

27 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_lstadd_front.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_lstadd_front
(
t_list
 **
lst
, t_list *
new
)

16 if (*
lst
 == 
NULL
)

18 
new
->
next
 = 
NULL
;

19 *
lst
 = 
new
;

21 else if (*
lst
 != 
NULL
)

23 
new
->
next
 = *
lst
;

24 *
lst
 = 
new
;

26 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_lstclear.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstclear
(
t_list
 **
lst
, void (*
del
)(void*))

16 
t_list
 *
temp
;

17 
t_list
 *
ptr
;

19 
ptr
 = *
lst
;

20 if (!
del
)

22 while (
ptr
 != 
NULL
)

24 
temp
 = 
ptr
->
next
;

25 
	`ft_lstdelone
(
ptr
, 
del
);

26 
ptr
 = 
temp
;

28 *
lst
 = 
NULL
;

29 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_lstdel_first_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_first_el
(
t_list
 **
a
)

16 
t_list
 *
tmp
;

18 
tmp
 = (*
a
)->
next
;

19 
	`free
 (*
a
);

20 *
a
 = 
tmp
;

21 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_lstdel_last_el.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$delete_last_el
(
t_list
 **
a
)

16 
t_list
 *
end
;

17 
t_list
 *
prev
;

19 
end
 = *
a
;

20 
prev
 = 
NULL
;

21 while (
end
->
next
)

23 
prev
 = 
end
;

24 
end
 = end->
next
;

26 
prev
->
next
 = 
NULL
;

27 
	`free
 (
end
);

28 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_lstdelone.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstdelone
(
t_list
 *
lst
, void (*
del
)(void*))

16 if (!
lst
 || !
del
)

18 
	`del
(
lst
->
content
);

19 
	`free
(
lst
);

20 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_lstiter.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_lstiter
(
t_list
 *
lst
, void (*
f
)(void *))

16 
t_list
 *
ptr
;

18 
ptr
 = 
lst
;

19 while (
ptr
 != 
NULL
)

21 
	`f
(
ptr
->
content
);

22 
ptr
 = ptr->
next
;

24 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_lstlast.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstlast
(
t_list
 *
lst
)

16 while (
lst
 != 
NULL
 && lst->
next
 != NULL)

18 
lst
 = lst->
next
;

20 return (
lst
);

21 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_lstmap.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
ft_lstmap
(t_list *
lst
, void *(*
f
)(void *), void (*
del
)(void *))

16 
t_list
 *
new_list
;

17 
t_list
 *
head
;

19 if (!
lst
 || !
f
)

20 return (
NULL
);

21 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

22 if (!
new_list
)

23 return (
NULL
);

24 
head
 = 
new_list
;

25 
lst
 = lst->
next
;

26 while (
lst
 != 
NULL
)

28 
new_list
 = 
	`ft_lstnew
(
	`f
(
lst
->
content
));

29 if (!
new_list
)

31 
	`ft_lstclear
(&
head
, 
del
);

32 return (
NULL
);

34 
	`ft_lstadd_back
(&
head
, 
new_list
);

35 
lst
 = lst->
next
;

37 return (
head
);

38 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_lstnew.c

12 #include 
	~"../includes/libft.h
"

14 
t_list
 *
	$ft_lstnew
(void *
content
)

16 
t_list
 *
lstnew
;

18 
lstnew
 = (
t_list
 *)
	`malloc
(sizeof(t_list));

19 if (!
lstnew
)

20 return (
NULL
);

21 
lstnew
->
next
 = 
NULL
;

22 
lstnew
->
content
 = (void *)content;

23 return (
lstnew
);

24 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_lstsize.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_lstsize
(
t_list
 *
lst
)

16 int 
i
;

17 
t_list
 *
ptr
;

19 
i
 = 0;

20 
ptr
 = 
NULL
;

21 
ptr
 = 
lst
;

22 while (
ptr
 != 
NULL
)

24 
ptr
 = ptr->
next
;

25 
i
++;

27 return (
i
);

28 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_memchr.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memchr
(const void *
s
, int 
c
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s
 + 
i
) == (unsigned char) 
c
)

23 return ((unsigned char *)(
s
 + 
i
));

26 
i
++;

28 return (
NULL
);

29 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_memcmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_memcmp
(const void *
s1
, const void *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
n
)

21 if (*(unsigned char *)(
s1
 + 
i
) != *(unsigned char *)(
s2
 + i))

23 return (*(unsigned char *)(
s1
 + 
i
) - *(unsigned char *)(
s2
 + i));

26 
i
++;

29 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_memcpy.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memcpy
(void *
dst
, const void *
src
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 while (
i
 < 
n
)

23 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

24 
i
++;

26 return (
dst
);

27 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_memmove.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memmove
(void *
dst
, const void *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 if (!
dst
 && !
src
)

20 return (
NULL
);

21 if (
dst
 > 
src
)

23 while (
len
--)

25 *(char *)(
dst
 + 
len
) = *(char *)(
src
 + len);

27 return (
dst
);

29 while (
i
 < 
len
)

31 *(char *)(
dst
 + 
i
) = *(char *)(
src
 + i);

32 
i
++;

34 return (
dst
);

35 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_memset.c

12 #include 
	~"../includes/libft.h
"

14 void *
	$ft_memset
(void *
b
, int 
c
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
i
 < 
len
)

21 *(unsigned char *)(
b
 + 
i
) = (unsigned char)
c
;

22 
i
++;

24 return (
b
);

25 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_putchar_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putchar_fd
(char 
c
, int 
fd
)

16 
	`write
(
fd
, &
c
, 1);

17 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_putendl_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putendl_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

26 
	`write
(
fd
, "\n", 1);

28 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_putnbr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putnbr_fd
(int 
n
, int 
fd
)

16 if (
n
 == -2147483648)

18 
	`ft_putstr_fd
("-2147483648", 
fd
);

20 else if (
n
 < 0)

22 
	`ft_putchar_fd
('-', 
fd
);

23 
n
 = n * (-1);

24 
	`ft_putnbr_fd
(
n
, 
fd
);

26 else if (
n
 > 9)

28 
	`ft_putnbr_fd
(
n
 / 10, 
fd
);

29 
	`ft_putnbr_fd
((
n
 % 10), 
fd
);

32 
	`ft_putchar_fd
((char)(
n
 + 48), 
fd
);

33 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_putstr_fd.c

12 #include 
	~"../includes/libft.h
"

14 void 
	$ft_putstr_fd
(char *
s
, int 
fd
)

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`write
(
fd
, &
s
[
i
], 1);

24 
i
++;

27 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_split.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_count_nbsubstr
(const char *
s
, char 
c
)

16 unsigned int 
i
;

17 
size_t
 
count
;

19 
i
 = 0;

20 
count
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] != 
c
)

25 while (
s
[
i
] != 
c
 && s[i] != '\0')

26 
i
++;

27 
count
++;

29 while (
s
[
i
] == 
c
)

30 
i
++;

32 return (
count
);

33 
	}
}

35 unsigned int 
	$ft_start_index_substr
(char const *
s
, char 
c
, unsigned int 
start
)

37 while (
s
[
start
] == 
c
 && s[start] != '\0')

38 
start
++;

39 return (
start
);

40 
	}
}

42 unsigned int 
	$ft_nb_char_substr
(char const *
s
, char 
c
, unsigned int 
start
)

44 unsigned int 
nb_char_substr
;

46 
nb_char_substr
 = 0;

47 while (
s
[
start
] != 
c
 && s[start] != '\0')

49 
start
++;

50 
nb_char_substr
++;

52 return (
nb_char_substr
);

53 
	}
}

55 char *
ft_create_substr
(\

56 char const *
s
, char 
c
, unsigned int 
start
, unsigned int 
nb_char_substr
)

58 unsigned int 
	gi
;

59 char *
	gsubstr
;

61 
	gi
 = 0;

62 
	gsubstr
 = (char *)
ft_calloc
((
nb_char_substr
 + 1), sizeof(char));

63 if (!
	gsubstr
)

64 return (
	gNULL
);

65 while (
	gs
[
start
] != 
c
 && 
s
[start] != '\0' && 
i
 < 
nb_char_substr
)

66 
substr
[
i
++] = 
s
[
start
++];

67 return (
	gsubstr
);

70 char **
	$ft_split
(char const *
s
, char 
c
)

72 
size_t
 
nb_substr
;

73 
size_t
 
i
;

74 char **
tab2d
;

75 unsigned int 
start
;

76 unsigned int 
nb_char_substr
;

78 
i
 = 0;

79 
start
 = 0;

80 
nb_substr
 = 
	`ft_count_nbsubstr
(
s
, 
c
);

81 
tab2d
 = (char **)
	`ft_calloc
((
nb_substr
 + 1), sizeof(char *));

82 if (!
tab2d
)

83 return (
NULL
);

84 while (
s
[
start
] != '\0' && 
i
 < 
nb_substr
)

86 
start
 = 
	`ft_start_index_substr
(
s
, 
c
, start);

87 
nb_char_substr
 = 
	`ft_nb_char_substr
(
s
, 
c
, 
start
);

88 
tab2d
[
i
] = 
	`ft_create_substr
(
s
, 
c
, 
start
, 
nb_char_substr
);

89 
start
 = start + 
nb_char_substr
;

90 
i
++;

92 return (
tab2d
);

93 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_strchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strchr
(const char *
s
, int 
c
)

16 int 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 if ((char)
c
 == 
s
[
i
])

22 return ((char *)(
s
 + 
i
));

23 
i
++;

25 if ((char)
c
 == '\0')

26 return ((char *)(
s
 + 
i
));

28 return (
NULL
);

29 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_strcpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strcpy
(char *
dst
, const char *
src
)

16 int 
i
;

18 
i
 = 0;

19 while (
src
[
i
])

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 
dst
[
i
] = '\0';

25 return (
dst
);

26 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_strcspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strcspn
(const char *
s
, const char *
reject
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
])

21 if (
	`ft_strchr
(
reject
, 
s
[
i
]) != 
NULL
)

22 return (
i
);

23 
i
++;

25 return (
i
);

26 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_strdup.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strdup
(const char *
s1
)

16 int 
size
;

17 char *
s1_copie
;

19 
size
 = 
	`ft_strlen
(
s1
) + 1;

20 
s1_copie
 = (char *)
	`malloc
(
size
 * sizeof(char));

21 if (!
s1_copie
)

22 return (
NULL
);

23 
	`ft_strlcpy
(
s1_copie
, 
s1
, 
size
);

24 return (
s1_copie
);

25 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_striteri.c

12 #include 
	~"../includes/libft.h
"

14 void 
ft_striteri
(char *
s
, void (*
f
)(unsigned int, char*))

16 unsigned int 
i
;

18 
i
 = 0;

19 if (
s
)

21 while (
s
[
i
] != '\0')

23 
	`f
(
i
, &
s
[i]);

24 
i
++;

27 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_strjoin.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strjoin
(char const *
s1
, char const *
s2
)

16 
size_t
 
size_s1
;

17 
size_t
 
size_s2
;

18 char *
strjoin
;

20 
size_s1
 = 
	`ft_strlen
(
s1
);

21 
size_s2
 = 
	`ft_strlen
(
s2
);

22 
strjoin
 = (char *)
	`malloc
((
size_s1
 + 
size_s2
 + 1) * sizeof(char));

23 if (!
strjoin
)

24 return (
NULL
);

25 
	`ft_memcpy
(
strjoin
, 
s1
, 
size_s1
);

26 
	`ft_memcpy
((
strjoin
 + 
size_s1
), 
s2
, 
size_s2
);

27 
	`ft_memset
((
strjoin
 + 
size_s1
 + 
size_s2
), 0, 1);

28 return (
strjoin
);

29 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_strlcat.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcat
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
strlen_src
;

18 
size_t
 
strlen_dst
;

19 
size_t
 
temp
;

21 
i
 = 0;

22 
strlen_src
 = 
	`ft_strlen
(
src
);

23 
strlen_dst
 = 
	`ft_strlen
(
dst
);

24 
temp
 = 
strlen_dst
;

25 if (
dstsize
 < 
strlen_dst
)

26 return (
dstsize
 + 
strlen_src
);

27 if (
dstsize
 > 
strlen_dst
 + 1)

29 while (
src
[
i
] && 
strlen_dst
 != (
dstsize
 - 1))

31 
dst
[
strlen_dst
++] = 
src
[
i
++];

33 
dst
[
strlen_dst
] = '\0';

35 return (
temp
 + 
strlen_src
);

36 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_strlcpy.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlcpy
(char *
dst
, const char *
src
, 
size_t
 
dstsize
)

16 
size_t
 
i
;

17 
size_t
 
j
;

19 
i
 = 0;

20 
j
 = 0;

21 while (
src
[
i
] != '\0')

23 
i
++;

25 if (
dstsize
 > 0)

27 while (
j
 < (
dstsize
 - 1) && 
src
[j] != '\0')

29 
dst
[
j
] = 
src
[j];

30 
j
++;

32 
dst
[
j
] = '\0';

34 return (
i
);

35 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_strlen.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strlen
(const char *
s
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
s
[
i
] != '\0')

21 
i
++;

23 return (
i
);

24 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_strmapi.c

12 #include 
	~"../includes/libft.h
"

14 char *
ft_strmapi
(char const *
s
, char (*
f
)(unsigned int, char))

16 unsigned int 
i
;

17 
size_t
 
size
;

18 char *
strmapi
;

20 
i
 = 0;

21 
size
 = 
	`ft_strlen
(
s
);

22 
strmapi
 = (char *)
	`malloc
((
size
 + 1) * sizeof(char));

23 if (!
strmapi
)

24 return (
NULL
);

25 while (
s
[
i
] != '\0')

27 
strmapi
[
i
] = 
	`f
(i, 
s
[i]);

28 
i
++;

30 
strmapi
[
i
] = '\0';

31 return (
strmapi
);

32 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_strncmp.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_strncmp
(const char *
s1
, const char *
s2
, 
size_t
 
n
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (((unsigned char)
s1
[
i
] || (unsigned char)
s2
[i]) && i < 
n
)

21 if (
s1
[
i
] != 
s2
[i])

22 return ((unsigned char)
s1
[
i
] - (unsigned char)
s2
[i]);

23 
i
++;

26 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_strncpy.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strncpy
(char *
dst
, const char *
src
, 
size_t
 
len
)

16 
size_t
 
i
;

18 
i
 = 0;

19 while (
src
[
i
] && i < 
len
)

21 
dst
[
i
] = 
src
[i];

22 
i
++;

24 while (
i
 < 
len
)

26 
dst
[
i
] = '\0';

27 
i
++;

29 return (
dst
);

30 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_strnstr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strnstr
(const char *
haystack
, const char *
needle
, 
size_t
 
len
)

16 
size_t
 
len_needle
;

17 
size_t
 
len_haystack
;

19 
len_needle
 = 
	`ft_strlen
(
needle
);

20 
len_haystack
 = 
	`ft_strlen
(
haystack
);

21 if (
needle
[0] == '\0')

22 return ((char *)(
haystack
));

23 if (
len_needle
 > 
len_haystack
 || 
len
 < len_needle)

24 return (
NULL
);

25 if (
len
 > 
len_haystack
)

26 
len
 = 
len_haystack
;

27 while (
len
 >= 
len_needle
 && 
haystack
)

29 if (
	`ft_memcmp
(
haystack
, 
needle
, 
len_needle
) == 0)

30 return ((char *)(
haystack
));

33 
haystack
++;

34 
len
--;

37 return (
NULL
);

38 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_strpbrk.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strpbrk
(const char *
s1
, const char *
s2
)

16 int 
i
;

18 
i
 = 0;

19 while (
s1
[
i
] != '\0')

21 if (
	`ft_strchr
(
s2
, 
s1
[
i
]) != 0)

23 return ((char *) &
s1
[
i
]);

25 ++
i
;

28 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_strrchr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strrchr
(const char *
s
, int 
c
)

16 int 
i
;

17 int 
k
;

19 
i
 = 0;

20 
k
 = 0;

21 while (
s
[
i
] != '\0')

23 if (
s
[
i
] == (char)
c
)

24 
k
 = 
i
;

25 
i
++;

27 if (
s
[
k
] == (char)
c
)

28 return ((char *)(
s
 + 
k
));

29 else if ((char)
c
 == 
s
[
i
])

30 return ((char *)(
s
 + 
i
));

32 return (
NULL
);

33 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_strspn.c

12 #include 
	~"../includes/libft.h
"

14 
size_t
 
	$ft_strspn
(const char *
s
, const char *
accept
)

16 
size_t
 
count
;

17 
size_t
 
i
;

19 
count
 = 0;

20 
i
 = 0;

21 while (
s
[
i
] && 
	`ft_strchr
(
accept
, s[i]) != 0)

23 
count
++;

24 
i
++;

26 return (
count
);

27 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_strtrim.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_strtrim
(char const *
s1
, char const *
set
)

16 unsigned int 
front
;

17 unsigned int 
end
;

18 unsigned int 
i
;

19 char *
strtrim
;

21 
front
 = 0;

22 
i
 = 0;

23 
end
 = (unsigned int)(
	`ft_strlen
(
s1
));

24 while (
s1
[
front
] != '\0' && 
	`ft_strchr
(
set
, *(s1 + front)) != 
NULL
)

25 
front
++;

26 while (
front
 < 
end
 && 
	`ft_strrchr
(
set
, *(
s1
 + end - 1)) != 
NULL
)

27 
end
--;

28 
strtrim
 = (char *)
	`malloc
((
end
 - 
front
 + 1) * sizeof(char));

29 if (!
strtrim
)

30 return (
NULL
);

31 
i
 = 0;

32 while (
front
 < 
end
)

33 
strtrim
[
i
++] = 
s1
[
front
++];

34 
strtrim
[
i
] = 0;

35 return (
strtrim
);

36 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_substr.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$ft_substr
(char const *
s
, unsigned int 
start
, 
size_t
 
len
)

16 char *
substr
;

17 unsigned int 
i
;

18 
size_t
 
size
;

20 
i
 = 0;

21 if (!
s
)

22 return (
NULL
);

23 
size
 = 
	`ft_strlen
(
s
);

24 if (
len
 > 
size
)

25 
len
 = 
size
;

26 if (
start
 >= (unsigned int)
size
)

28 
substr
 = (char *)
	`malloc
(1 * sizeof(char));

29 if (!
substr
)

30 return (
NULL
);

31 
substr
[0] = '\0';

32 return (
substr
);

34 
substr
 = (char *)
	`malloc
((
len
 + 1) * sizeof(char));

35 if (!
substr
)

36 return (
NULL
);

37 while (
i
 < (unsigned int)
len
 && 
s
[
start
] != '\0' )

38 
substr
[
i
++] = 
s
[
start
++];

39 
substr
[
i
] = '\0';

40 return (
substr
);

41 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_tolower.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_tolower
(int 
c
)

16 if (
c
 >= 'A' && c <= 'Z')

17 return (
c
 + 32);

19 return (
c
);

20 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/ft_toupper.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$ft_toupper
(int 
c
)

16 if (
c
 >= 'a' && c <= 'z')

17 return (
c
 - 32);

19 return (
c
);

20 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/power.c

12 #include 
	~"../includes/libft.h
"

14 int 
	$power
(int 
str_base
, int 
power
)

16 int 
result
;

18 
result
 = 1;

19 if (
power
 < 0 || 
str_base
 == 0)

23 while (
power
 > 0)

25 
result
 = result * 
str_base
;

26 
power
--;

28 return (
result
);

29 
	}
}

	@sauvegarde/parsing/expansion_test/libft/libft/str_lowercase.c

12 #include 
	~"../includes/libft.h
"

14 char *
	$str_lowercase
(char *
str
)

16 int 
i
;

18 
i
 = 0;

19 while (
str
[
i
])

21 if (
str
[
i
] >= 'A' && str[i] <= 'Z')

22 
str
[
i
] += 32;

23 
i
++;

25 return (
str
);

26 
	}
}

	@sauvegarde/parsing/expansion_test/main.c

13 #include 
	~"minishell.h
"

15 
t_shell
 *
	gg_shell
;

21 void 
	$print_env
(
t_env
 **
head
)

23 
t_env
 *
ptr
;

25 
ptr
 = *
head
;

26 if (!
head
 || !*head)

28 while (
ptr
)

30 
	`ft_printf
("print_env function: %s\n", 
ptr
->
var_name
);

31 
	`ft_printf
("print_env function: %s\n", 
ptr
->
var_value
);

32 
ptr
 = ptr->
next
;

34 
	}
}

37 void 
	$free_shell
(void)

39 
	`free_env
(&
g_shell
->
env
);

41 if (
g_shell
)

42 
	`free
(
g_shell
);

43 
	}
}

45 int 
	$init_shell
(char **
envp
)

47 
g_shell
 = 
	`ft_calloc
(1, sizeof(
t_shell
));

48 if (!
g_shell
)

50 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

53 if (!*
envp
)

58 
g_shell
->
env
 = 
	`get_envp
(
envp
);

59 if (!
g_shell
->
env
)

61 
	`free_shell
();

62 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
	`strerror
(
errno
));

65 
g_shell
->
exit_status
 = 0;

67 
g_shell
->
save_env
 = 
	`copy_env_tab
(g_shell->
env
);

69 
	}
}

72 int 
	$main
(int 
ac
, char **
av
, char **
envp
)

74 (void)
av
;

75 (void)
ac
;

76 char *
line
;

77 
t_token
 *
token
;

79 if (!
	`init_shell
(
envp
))

81 
line
 = 
NULL
;

83 
line
 = 
	`ft_strdup
("\"$USER\"");

85 
	`printf
("LINE = %s\n", 
line
);

86 
token
 = 
	`parsing
(
line
);

88 
g_shell
->
exit_status
 = 0;

89 if (
token
)

90 
	`free_token
(&
token
);

91 
	`free_shell
();

93 
	}
}

	@sauvegarde/parsing/expansion_test/malloc_error_print_message.c

12 #include 
	~"minishell.h
"

14 void 
	$malloc_error_print_message
(char *
s
)

16 
	`ft_dprintf
(2, "minishell: malloc: %s\n", 
s
);

17 
g_shell
->
exit_status
 = 1;

18 
	}
}

	@sauvegarde/parsing/expansion_test/minishell.h

13 #ifndef 
MINISHELL_H


14 #define 
	#MINISHELL_H


	)

16 #include 
	~<stdio.h
>

17 #include 
	~<string.h
>

18 #include 
	~<stdlib.h
>

19 #include 
	~<errno.h
>

20 #include 
	~<curses.h
>

21 #include 
	~<term.h
>

22 #include 
	~<signal.h
>

23 #include 
	~<unistd.h
>

24 #include 
	~<fcntl.h
>

25 #include 
	~<stdarg.h
>

26 #include 
	~<sys/wait.h
>

27 #include 
	~<sys/stat.h
>

28 #include 
	~<sys/types.h
>

29 #include 
	~<readline/readline.h
>

30 #include 
	~<readline/history.h
>

31 #include 
	~"libft/includes/libft.h
"

34 #define 
	#RED
 "\x1b[31m"

	)

35 #define 
	#BLU
 "\x1B[34m"

	)

36 #define 
	#BLU_2
 "\e[1;34m"

	)

37 #define 
	#GRN
 "\x1B[32m"

	)

38 #define 
	#YEL
 "\x1B[33m"

	)

39 #define 
	#MAG
 "\x1B[35m"

	)

40 #define 
	#CYN
 "\x1B[36m"

	)

41 #define 
	#WHT
 "\x1B[37m"

	)

42 #define 
	#RESET
 "\x1B[0m"

	)

44 #define 
	#WORD
 1

	)

45 #define 
	#PIPELINE
 2

	)

46 #define 
	#L_CHEVRON
 3

	)

47 #define 
	#R_CHEVRON
 4

	)

48 #define 
	#APPEND
 5

	)

49 #define 
	#HERE_DOC
 6

	)

50 #define 
	#DOLLAR
 7

	)

51 #define 
	#QUESTION
 8

	)

52 #define 
	#EXPAND
 9

	)

53 #define 
	#DELETE
 10

	)

54 #define 
	#EXPANDED
 11

	)

55 #define 
	#CONTINUE
 -1

	)

56 #define 
	#ERROR_EXIT
 -169

	)

57 #define 
	#ERROR_EXIT_
 0

	)

62 typedef struct 
	ss_env


64 char *
	mvar_name
;

65 char *
	mvar_value
;

66 struct 
s_env
 *
	mnext
;

67 } 
	tt_env
;

69 typedef struct 
	ss_token


71 char *
	mcontent
;

72 int 
	mid
;

73 struct 
s_token
 *
	mnext
;

74 } 
	tt_token
;

77 typedef struct 
	ss_cmd


80 char **
	mcmd
;

81 char **
	mredir
;

82 char **
	mpath
;

86 int 
	mfdout
;

87 int 
	mfdin
;

88 int 
	mfd
[2];

89 } 
	tt_cmd
;

91 typedef struct 
	ss_shell


93 
t_env
 *
	menv
;

94 int 
	mexit_status
;

95 char **
	msave_env
;

96 } 
	tt_shell
;

99 extern 
t_shell
 *
g_shell
;

101 int 
expansion
(
t_token
 **
token
, t_token *
curr
, int 
pos
);

102 int 
check_dollar
(
t_token
 *
curr
, int 
i
);

103 int 
trim_dollar
(
t_token
 *
curr
, int 
pos
);

106 int 
is_dollar_to_expand
(
t_token
 *
curr
, int 
i
);

107 int 
not_within_squotes
(
t_token
 *
curr
, int 
pos
);

110 int 
trim_dollar
(
t_token
 *
curr
, int 
pos
);

113 int 
loop_dollars
(char *
s
, int 
i
);

114 int 
loop_through
(char *
s
, int 
i
);

119 int 
size_var
(char *
s
);

120 int 
check_var_exist
(
t_token
 *
tmp
);

123 int 
join_tokens
(
t_token
 **
new
, t_token *
curr
);

126 int 
prepare_expand
(
t_token
 *
tmp
, int 
i
);

127 int 
set_id_expansion
(
t_token
 *
token
);

130 int 
quote_removing
(
t_token
 **
head
, t_token *
curr
, int 
pos
);

132 
t_token
 *
delete_token
(t_token **
head
);

133 int 
token_list_size
(
t_token
 **
head
);

136 int 
_pwd
(
t_cmd
 *
cmd
);

137 int 
_env
(
t_env
 *
env
);

140 char **
env_copied
(char **
envp
);

141 void 
free_tab
(char **
table
);

144 
t_env
 *
get_envp
(char **
envp
);

145 void 
free_env
(
t_env
 **
head
);

149 
t_token
 *
parsing
(char *
line
);

150 int 
syntax_error_check
(char *
s
);

151 int 
check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
);

152 int 
check_quotes_errors
(char *
s
, char 
c
, int *
i
);

153 int 
count_metachar
(char *
s
, char 
c
, int 
num
);

154 int 
check_multiple_operators_error
(int 
i
, int 
num
, char 
c
);

155 void 
print_syntax_error_char
(char 
c
);

156 void 
print_syntax_error_dchar
(char 
c
);

157 void 
print_syntax_error_str
(char *
s
);

160 int 
character_extraction
(char *
line
, int 
ind
);

161 int 
token_extraction
(char *
line
, int 
ind
);

162 
t_token
 *
get_tokens
(char *
line
);

163 int 
get_tokens_size
(char *
line
, int *
i
);

164 
t_token
 *
create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
);

167 void 
malloc_error_print_message
(char *
s
);

170 
t_token
 *
new_token
(char *
line
, int 
start
, int 
len
);

171 void 
set_id
(
t_token
 *
token
);

172 int 
token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
);

173 int 
link_token
(
t_token
 **
head
, t_token *
new
);

174 void 
free_token
(
t_token
 **
head
);

177 int 
is_dollar
(char 
c
);

178 int 
is_pipeline
(char 
c
);

179 int 
is_chevron
(char 
c
);

180 int 
is_lchevron
(char 
c
);

181 int 
is_rchevron
(char 
c
);

182 int 
is_operator
(char 
c
);

183 int 
is_newline
(char 
c
);

184 int 
is_white_space
(char 
c
);

185 int 
is_blank
(char 
c
);

186 int 
is_metacharacter
(char 
c
);

187 int 
is_delimiter
(char 
c
);

188 int 
is_word
(char 
c
);

189 int 
is_double_quote
(char 
c
);

190 int 
is_simple_quote
(char 
c
);

191 int 
is_quote
(char 
c
);

192 int 
is_question
(char 
c
);

193 int 
is_punct
(char 
c
);

196 int 
sig_handler
(void);

199 void 
handler_ctr_c
(int 
code
);

202 char **
ft_splitpath
(char *
s
, char 
c
);

205 char **
copy_env_tab
(
t_env
 *
env
);

	@sauvegarde/parsing/expansion_test/parsing.c

12 #include 
	~"minishell.h
"

16 void 
	$print_token
(
t_token
 **
head
)

18 int 
i
;

19 
t_token
 *
tmp
;

21 
i
 = 0;

22 if (!*
head
 || !head)

24 
tmp
 = *
head
;

25 while (
tmp
)

27 if (
tmp
->
id
 == 
L_CHEVRON
)

28 
	`printf
("L_CHEVRON: ");

29 else if (
tmp
->
id
 == 
R_CHEVRON
)

30 
	`printf
("R_CHEVRON: ");

31 else if (
tmp
->
id
 == 
PIPELINE
)

32 
	`printf
("PIPELINE: ");

33 else if (
tmp
->
id
 == 
WORD
)

34 
	`printf
("WORD: ");

35 else if (
tmp
->
id
 == 
APPEND
)

36 
	`printf
("APPEND: ");

37 else if (
tmp
->
id
 == 
HERE_DOC
)

38 
	`printf
("HERE_DOC: ");

39 else if (
tmp
->
id
 == 
DOLLAR
)

40 
	`printf
("DOLLAR: ");

41 while (
tmp
->
content
[
i
])

43 
	`printf
 ("%c", 
tmp
->
content
[
i
]);

44 
i
++;

46 
	`printf
 ("%c", 
tmp
->
content
[
i
]);

47 
	`printf
 ("\n");

48 
i
 = 0;

49 
tmp
 = tmp->
next
;

51 
	}
}

89 
t_token
 *
	$parsing
(char *
line
)

91 
t_token
 *
token
;

93 if (!
	`syntax_error_check
(
line
))

94 return (
NULL
);

95 
token
 = 
	`get_tokens
(
line
);

96 if (!
token
)

97 return (
NULL
);

98 if (!
	`expansion
(&
token
, token, 0))

99 return (
NULL
);

100 if (!
	`quote_removing
(&
token
, token, 0))

101 return (
NULL
);

102 
	`print_token
(&
token
);

103 return (
token
);

104 
	}
}

	@sauvegarde/parsing/expansion_test/parsing_expansion.c

12 #include 
	~"minishell.h
"

42 int 
	$check_dollar
(
t_token
 *
curr
, int 
i
)

44 int 
res
;

46 while (
curr
->
content
[
i
])

48 if (
	`is_dollar
(
curr
->
content
[
i
]) && 
	`not_within_squotes
(curr, i))

50 if (
	`is_dollar_to_expand
(
curr
, 
i
))

51 return (
	`prepare_expand
(
curr
, 
i
));

52 else if (
	`is_dollar
(
curr
->
content
[
i
 + 1]))

53 
i
 = 
	`loop_dollars
(
curr
->
content
, i);

54 else if (
	`is_quote
(
curr
->
content
[
i
 + 1]))

56 
res
 = 
	`trim_dollar
(
curr
, 
i
);

57 if (
res
 == 
ERROR_EXIT
)

58 return (
ERROR_EXIT
);

59 
i
 += 
res
;

61 else if (
curr
->
content
[
i
 + 1] == '\0')

64 
i
++;

67 
i
++;

69 
curr
->
id
 = 
WORD
;

70 return (
i
);

71 
	}
}

73 static void 
	$expansion_next_token
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

75 
pos
 = 0;

76 if (
curr
->
next
)

78 
curr
 = curr->
next
;

79 
	`expansion
(
head
, 
curr
, 
pos
);

81 
	}
}

107 int 
	$expansion
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

109 if (
curr
)

111 if (
curr
->
id
 == 
DOLLAR
)

113 
pos
 = 
	`check_dollar
(
curr
, pos);

114 if (
pos
 == 
ERROR_EXIT
)

115 return (
	`free_token
(
head
), 0);

116 if (
curr
->
id
 == 
DELETE
)

118 
curr
 = 
	`delete_token
(
head
);

119 if (!
curr
)

121 
head
 = 
NULL
;

124 
pos
 = 0;

126 
	`expansion
(
head
, 
curr
, 
pos
);

129 
	`expansion_next_token
(
head
, 
curr
, 
pos
);

132 
	}
}

	@sauvegarde/parsing/expansion_test/parsing_expansion_dollar_conditions.c

12 #include 
	~"minishell.h
"

18 int 
	$not_within_squotes
(
t_token
 *
curr
, int 
pos
)

20 int 
i
;

21 int 
start
;

23 
i
 = 0;

24 
start
 = 0;

25 if (!
	`is_dollar
(
curr
->
content
[
pos
]))

27 while (
curr
->
content
[
i
])

29 if (
	`is_double_quote
(
curr
->
content
[
i
]))

30 
i
 = 
	`loop_through
(
curr
->
content
, i);

31 else if (
	`is_simple_quote
(
curr
->
content
[
i
]))

33 
start
 = 
i
;

34 
i
 = 
	`loop_through
(
curr
->
content
, i);

35 if (
pos
 > 
start
 && pos < 
i
)

38 
i
++;

41 
	}
}

43 int 
	$is_dollar_to_expand
(
t_token
 *
curr
, int 
i
)

45 if (
	`is_question
(
curr
->
content
[
i
 + 1]) || \

46 (!
	`is_dollar
(
curr
->
content
[
i
 + 1]) && \

47 !
	`is_quote
(
curr
->
content
[
i
 + 1]) && \

48 !
	`is_punct
(
curr
->
content
[
i
 + 1]) && \

49 !
	`is_white_space
(
curr
->
content
[
i
 + 1]) && \

50 
curr
->
content
[
i
 + 1] != '\0'))

55 
	}
}

	@sauvegarde/parsing/expansion_test/parsing_expansion_expand_var_helper.c

12 #include 
	~"minishell.h
"

14 static int 
	$replace_content
(
t_token
 *
tmp
, char *
s
)

16 
	`free
(
tmp
->
content
);

17 
tmp
->
content
 = 
NULL
;

18 
tmp
->
content
 = 
	`ft_strdup
(
s
);

19 if (!
tmp
->
content
)

21 
	`malloc_error_print_message
("ft_strdup failed");

22 return (
ERROR_EXIT
);

25 
	}
}

27 int 
	$check_var_exist
(
t_token
 *
tmp
)

29 if (
	`ft_strncmp
(&
tmp
->
content
[1], "?", 1) == 0)

31 return (
	`replace_content
(
tmp
, 
	`ft_itoa
(
g_shell
->
exit_status
)));

33 else if (
g_shell
 && g_shell->
env
 && g_shell->env->
var_name
)

35 if (
	`ft_strncmp
(
g_shell
->
env
->
var_name
, &
tmp
->
content
[1], \

36 
	`ft_strlen
(
tmp
->
content
)) == 0)

38 return (
	`replace_content
(
tmp
, 
g_shell
->
env
->
var_value
));

42 
	}
}

44 int 
	$size_var
(char *
s
)

46 int 
i
;

47 int 
count
;

49 
i
 = 0;

50 
count
 = 0;

51 while (
s
[
i
] && 
	`is_white_space
(s[i]))

52 
i
++;

53 while (
s
[
i
] && !
	`is_white_space
(s[i]))

55 
count
++;

56 
i
++;

58 return (
count
);

59 
	}
}

	@sauvegarde/parsing/expansion_test/parsing_expansion_helper.c

12 #include 
	~"minishell.h
"

14 int 
	$expand_var
(
t_token
 **
new
)

16 
t_token
 *
tmp
;

17 
t_env
 *
save
;

18 int 
res
;

20 
tmp
 = *
new
;

21 
save
 = 
g_shell
->
env
;

22 while (
tmp
->
id
 != 
EXPAND
)

23 
tmp
 = tmp->
next
;

24 while (
g_shell
->
env
)

26 
res
 = 
	`check_var_exist
(
tmp
);

27 if (
res
 == 
ERROR_EXIT
)

28 return (
ERROR_EXIT
);

29 else if (
res
 == 1)

31 
tmp
->
id
 = 
EXPANDED
;

32 
g_shell
->
env
 = 
save
;

33 return (
	`size_var
(
tmp
->
content
));

35 
g_shell
->
env
 = g_shell->env->
next
;

37 
tmp
->
id
 = 
DELETE
;

38 
g_shell
->
env
 = 
save
;

40 
	}
}

42 int 
	$split_tokens
(
t_token
 **
new
, char *
s
, int 
start
, int 
len
)

44 if (
start
 != 0)

46 *
new
 = 
	`new_token
(
s
, 0, 
start
);

47 if (!*
new
)

48 return (
ERROR_EXIT
);

49 (*
new
)->
id
 = 
WORD
;

50 if (!
	`token_linked_list
(
new
, 
s
, 
start
, 
len
))

51 return (
ERROR_EXIT
);

52 (*
new
)->
next
->
id
 = 
EXPAND
;

56 *
new
 = 
	`new_token
(
s
, 
start
, 
len
);

57 if (!*
new
)

58 return (
ERROR_EXIT
);

59 (*
new
)->
id
 = 
EXPAND
;

61 
start
 += 
len
;

62 
len
 = 
start
;

63 while (
s
[
len
])

64 
len
++;

65 if (
len
 != 
start
)

66 if (!
	`token_linked_list
(
new
, 
s
, 
start
, 
len
))

67 return (
ERROR_EXIT
);

69 
	}
}

71 static int 
	$var_len
(char *
s
, int 
i
)

73 int 
len
;

75 
len
 = 0;

76 
i
++;

77 if (
	`is_question
(
s
[
i
]))

81 while (
s
[
i
] && \

82 !
	`is_white_space
(
s
[
i
]) && \

83 !
	`is_quote
(
s
[
i
]) && \

84 !
	`is_question
(
s
[
i
]) && \

85 !
	`is_dollar
(
s
[
i
]) && \

86 !
	`is_punct
(
s
[
i
]))

88 
i
++;

89 
len
++;

92 return (
len
);

93 
	}
}

95 int 
	$new_id
(
t_token
 **
new
)

97 
t_token
 *
ptr
;

99 
ptr
 = *
new
;

100 while (
ptr
)

102 if (
ptr
->
id
 == 
DELETE
 || ptr->id == 
EXPANDED
)

104 
ptr
 = ptr->
next
;

106 if (
ptr
->
next
 == 
NULL
)

107 return (
WORD
);

108 return(
	`set_id_expansion
(
ptr
->
next
));

109 
	}
}

116 int 
	$prepare_expand
(
t_token
 *
curr
, int 
i
)

118 
t_token
 *
new
;

119 int 
len
;

120 int 
id
;

122 
new
 = 
NULL
;

123 
len
 = 
	`var_len
(
curr
->
content
, 
i
);

124 if (
	`split_tokens
(&
new
, 
curr
->
content
, 
i
, 
len
 + 1) == 
ERROR_EXIT
)

125 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

126 
len
 = 
	`expand_var
(&
new
);

127 if (
len
 == 
ERROR_EXIT
)

128 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

129 
id
 = 
	`new_id
 (&
new
);

130 if (
	`join_tokens
(&
new
, 
curr
) == 
ERROR_EXIT
)

131 return (
	`free_token
(&
new
), 
ERROR_EXIT
);

132 if (
curr
->
id
 == 
DELETE
)

134 
curr
->
id
 = id ;

135 return (
len
 + 
i
);

136 
	}
}

	@sauvegarde/parsing/expansion_test/parsing_expansion_join_tokens.c

12 #include 
	~"minishell.h
"

14 static int 
	$get_expanded_size
(char *
s
, int 
i
)

16 int 
size
;

18 
size
 = 0;

19 while (
	`is_white_space
(
s
[
i
]))

20 
i
++;

21 while (
s
[
i
] && !
	`is_white_space
(s[i]))

23 
i
++;

24 
size
++;

26 return (
size
);

27 
	}
}

29 static int 
	$get_new_size
(
t_token
 **
new
)

31 
t_token
 *
ptr
;

32 int 
size
;

33 int 
i
;

35 
size
 = 0;

36 
ptr
 = *
new
;

37 while (
ptr
)

39 
i
 = 0;

40 if (
ptr
->
id
 == 
EXPANDED
)

41 
size
 += 
	`get_expanded_size
(
ptr
->
content
, 
i
);

42 else if (
ptr
->
id
 != 
DELETE
)

44 while (
ptr
->
content
[
i
])

46 
size
++;

47 
i
++;

50 
ptr
 = ptr->
next
;

52 return (
size
);

53 
	}
}

55 static void 
	$copy_helper
(
t_token
 **
new
, t_token *
curr
)

57 int 
i
;

58 int 
j
;

59 
t_token
 *
ptr
;

61 
i
 = 0;

62 
j
 = 0;

63 
ptr
 = *
new
;

64 while (
ptr
)

66 if (
ptr
->
id
 == 
EXPANDED
)

68 while (
ptr
->
content
[
j
] && 
	`is_white_space
(ptr->content[j]))

69 
j
++;

70 while (
ptr
->
content
[
j
] && !
	`is_white_space
(ptr->content[j]))

71 
curr
->
content
[
i
++] = 
ptr
->content[
j
++];

73 else if (
ptr
->
id
 != 
DELETE
)

74 while (
ptr
->
content
[
j
])

75 
curr
->
content
[
i
++] = 
ptr
->content[
j
++];

76 
ptr
 = ptr->
next
;

77 
j
 = 0;

79 
curr
->
content
[
i
] = '\0';

80 
	}
}

82 static int 
	$copy_join_tokens
(
t_token
 **
new
, t_token *
curr
, int 
size
)

84 
	`free
(
curr
->
content
);

85 
curr
->
content
 = 
NULL
;

86 
curr
->
content
 = 
	`malloc
((
size
 + 1) * sizeof(char));

87 if (!
curr
->
content
)

89 
	`malloc_error_print_message
(
	`strerror
(
errno
));

90 return (
ERROR_EXIT
);

92 
	`copy_helper
(
new
, 
curr
);

93 
	`free_token
(
new
);

95 
	}
}

97 int 
	$join_tokens
(
t_token
 **
new
, t_token *
curr
)

99 int 
size
;

101 
size
 = 
	`get_new_size
(
new
);

102 if (
size
 == 0)

104 
	`free_token
(
new
);

105 
curr
->
id
 = 
DELETE
;

108 if (
	`copy_join_tokens
(
new
, 
curr
, 
size
) == 
ERROR_EXIT
)

109 return (
ERROR_EXIT
);

111 
	}
}

	@sauvegarde/parsing/expansion_test/parsing_expansion_looping.c

12 #include 
	~"minishell.h
"

53 int 
	$loop_dollars
(char *
s
, int 
i
)

55 while (
	`is_dollar
(
s
[
i
]) && s[i])

56 
i
++;

57 if (
s
[
i
] != '\0' && !
	`is_white_space
(s[i]))

58 
i
--;

59 return (
i
);

60 
	}
}

68 int 
	$loop_through
(char *
s
, int 
i
)

70 char 
c
;

72 
c
 = 
s
[
i
];

73 
i
++;

74 while (
s
[
i
] != 
c
)

75 
i
++;

76 return (
i
);

77 
	}
}

	@sauvegarde/parsing/expansion_test/parsing_expansion_trim_dollar.c

12 #include 
	~"minishell.h
"

17 static int 
	$copy_string
(
t_token
 *
curr
, char **
s
, int 
pos
)

19 int 
i
;

20 int 
j
;

22 
i
 = 0;

23 
j
 = 0;

24 *
s
 = 
	`malloc
(sizeof(char) * 
	`ft_strlen
(
curr
->
content
));

25 if (!*
s
)

27 
i
 = 0;

28 while (
curr
->
content
[
i
])

30 if (
i
 == 
pos
)

31 
i
++;

32 (*
s
)[
j
] = 
curr
->
content
[
i
];

33 
i
++;

34 
j
++;

36 (*
s
)[
j
] = '\0';

37 
	`free
(
curr
->
content
);

38 
curr
->
content
 = *
s
;

40 
	}
}

46 int 
	$trim_dollar
(
t_token
 *
curr
, int 
pos
)

48 int 
i
;

49 int 
start
;

50 char *
s
;

52 
s
 = 
NULL
;

53 
i
 = 0;

54 
start
 = 0;

55 while (
curr
->
content
[
i
])

57 if (
	`is_double_quote
(
curr
->
content
[
i
]))

59 
start
 = 
i
;

60 
i
 = 
	`loop_through
(
curr
->
content
, i);

61 if (
pos
 > 
start
 && pos < 
i
)

64 
i
++;

66 if (!
	`copy_string
(
curr
, &
s
, 
pos
))

67 return (
ERROR_EXIT
);

69 
	}
}

	@sauvegarde/parsing/expansion_test/parsing_quote_removing.c

12 #include 
	~"minishell.h
"

14 static int 
copy_string_unquoted
(
t_token
 *
curr
, char *
new_str
, \

15 int 
start
, int 
pos
)

17 int 
	gj
;

18 int 
	gi
;

19 int 
	gsave
;

21 
	gj
 = 0;

22 
	gi
 = 0;

23 
	gsave
 = 0;

24 while (
	gcurr
->
	gcontent
[
i
])

26 if (
	gi
 == 
start
)

27 
i
++;

28 else if (
	gi
 == 
pos
)

30 
i
++;

31 
	gsave
 = 
j
;

35 
	gnew_str
[
j
] = 
curr
->
content
[
i
];

36 
	gi
++;

37 
	gj
++;

40 
	gnew_str
[
j
] = '\0';

41 return (
	gsave
);

44 int 
	$string_replace
(
t_token
 *
curr
, int 
start
, int 
pos
)

46 int 
save
;

47 char *
new_str
;

49 
new_str
 = 
	`malloc
(sizeof(char) * (
	`ft_strlen
(
curr
->
content
) - 2 + 1));

50 if (!
new_str
)

52 
	`malloc_error_print_message
(
	`strerror
(
errno
));

53 return (
ERROR_EXIT
);

55 
save
 = 
	`copy_string_unquoted
(
curr
, 
new_str
, 
start
, 
pos
);

56 
	`free
(
curr
->
content
);

57 
curr
->
content
 = 
NULL
;

58 
curr
->
content
 = 
new_str
;

59 return (
save
);

60 
	}
}

62 int 
	$remove_q
(
t_token
 *
curr
, int 
pos
)

64 int 
start
;

66 
start
 = 
pos
;

67 
pos
 = 
	`loop_through
(
curr
->
content
, pos);

68 
pos
 = 
	`string_replace
(
curr
, 
start
, pos);

69 if (
pos
 == 
ERROR_EXIT
)

70 return (
ERROR_EXIT
);

71 return (
pos
++);

72 
	}
}

74 int 
	$quote_removing
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

76 if (!
head
 || !*head)

78 if (
curr
->
content
[
pos
] == '\0')

80 if (
curr
->
next
)

82 
pos
 = 0;

83 
curr
 = curr->
next
;

84 
	`quote_removing
(
head
, 
curr
, 
pos
);

88 else if (
	`is_quote
(
curr
->
content
[
pos
]))

90 
pos
 = 
	`remove_q
(
curr
, pos);

91 if (
pos
 == 
ERROR_EXIT
)

92 return (
	`free_token
(
head
), 0);

93 
	`quote_removing
(
head
, 
curr
, 
pos
);

97 
pos
++;

98 
	`quote_removing
(
head
, 
curr
, 
pos
);

101 
	}
}

	@sauvegarde/parsing/expansion_test/parsing_syntax_errors.c

12 #include 
	~"minishell.h
"

14 int 
	$check_multiple_operators_error
(int 
i
, int 
num
, char 
c
)

16 if (
i
 > 
num
)

18 if (
	`is_chevron
(
c
))

19 
	`print_syntax_error_dchar
(
c
);

20 else if (
	`is_pipeline
(
c
))

21 
	`print_syntax_error_char
(
c
);

25 
	}
}

27 int 
	$count_metachar
(char *
s
, char 
c
, int 
num
)

29 int 
i
;

31 
i
 = 1;

32 while (
s
[
i
] && s[i] == 
c
)

33 
i
++;

34 if (!
	`check_multiple_operators_error
(
i
, 
num
, 
c
))

36 while (
s
[
i
] && 
	`is_blank
(s[i]))

37 
i
++;

38 if (
	`is_operator
(
s
[
i
]) && !
	`is_pipeline
(
c
))

40 
c
 = 
s
[
i
];

41 if (
	`is_chevron
(
c
) && is_chevron(
s
[
i
 + 1]))

42 return (
	`print_syntax_error_dchar
(
c
), 0);

44 
	`print_syntax_error_char
(
c
);

47 else if (
s
[
i
] == '\0')

48 return (
	`print_syntax_error_str
("newline"), 0);

50 
	}
}

52 int 
	$check_quotes_errors
(char *
s
, char 
c
, int *
i
)

54 int 
j
;

56 
j
 = *
i
 + 1;

57 while (
s
[
j
] && s[j] != 
c
)

58 
j
++;

59 if (
s
[
j
] != 
c
)

61 
	`print_syntax_error_char
(
c
);

64 (*
i
)++;

65 while (
s
[*
i
] && s[*i] != 
c
)

66 (*
i
)++;

68 
	}
}

70 int 
	$check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
)

72 int 
j
;

74 
j
 = 0;

75 while (
s
[
j
] && 
	`is_blank
(s[j]))

76 
j
++;

77 if (
s
[
j
] == 
c
)

79 
	`print_syntax_error_char
(
c
);

82 if (!
	`count_metachar
(&
s
[
i
], 
c
, 
num
))

85 
	}
}

132 int 
	$syntax_error_check
(char *
s
)

134 int 
i
;

136 
i
 = 0;

137 while (
s
[
i
])

139 if (
	`is_quote
(
s
[
i
]))

141 if (!
	`check_quotes_errors
(
s
, s[
i
], &i))

142 return (
	`free
(
s
), 0);

144 else if ((
	`is_lchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '<', 2)) || \

145 (
	`is_rchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '>', 2)))

146 return (
	`free
(
s
), 0);

147 else if (
	`is_pipeline
(
s
[
i
]) && !
	`check_pipeline_errors
(s, i, '|', 1))

148 return (
	`free
(
s
), 0);

149 
i
++;

152 
	}
}

	@sauvegarde/parsing/expansion_test/parsing_syntax_errors_print_message.c

12 #include 
	~"minishell.h
"

19 void 
	$print_syntax_error_char
(char 
c
)

21 
	`ft_dprintf
(2, "minishell: ");

22 
	`ft_dprintf
(2, "syntax error near unexpected token ");

23 
	`ft_dprintf
(2, "\'%c\'\n", 
c
);

24 
g_shell
->
exit_status
 = 258;

25 
	}
}

27 void 
	$print_syntax_error_dchar
(char 
c
)

29 
	`ft_dprintf
(2, "minishell: ");

30 
	`ft_dprintf
(2, "syntax error near unexpected token ");

31 
	`ft_dprintf
(2, "\'%c%c\'\n", 
c
, c);

32 
g_shell
->
exit_status
 = 258;

33 
	}
}

35 void 
	$print_syntax_error_str
(char *
s
)

37 
	`ft_dprintf
(2, "minishell: ");

38 
	`ft_dprintf
(2, "syntax error near unexpected token ");

39 
	`ft_dprintf
(2, "\'%s\'\n", 
s
);

40 
g_shell
->
exit_status
 = 258;

41 
	}
}

	@sauvegarde/parsing/expansion_test/parsing_token_extraction.c

12 #include 
	~"minishell.h
"

21 int 
	$character_extraction
(char *
line
, int 
ind
)

23 if ((
line
[
ind
] == '>' && line[ind + 1] == '>') || \

24 (
line
[
ind
] == '<' && line[ind + 1] == '<'))

27 
	}
}

43 int 
	$word_extraction
(char *
line
, int 
ind
)

45 int 
start
;

46 char 
c
;

48 
start
 = 
ind
;

49 while (
	`is_word
(
line
[
ind
]) && line[ind])

51 if (
	`is_quote
(
line
[
ind
]))

53 
c
 = 
line
[
ind
];

54 
ind
++;

55 while (
line
[
ind
] && line[ind] != 
c
)

56 
ind
++;

58 
ind
++;

60 return (
ind
 - 
start
);

61 
	}
}

64 int 
	$get_tokens_size
(char *
line
, int *
i
)

66 int 
len
;

68 
len
 = 0;

69 while (
	`is_blank
(
line
[*
i
]))

70 (*
i
)++;

71 if (
	`is_word
(
line
[*
i
]))

72 
len
 = 
	`word_extraction
(
line
, *
i
);

73 else if (
	`is_operator
(
line
[*
i
]))

74 
len
 = 
	`character_extraction
(
line
, *
i
);

75 return (
len
);

76 
	}
}

83 
t_token
 *
	$create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
)

85 
t_token
 *
head
;

87 
head
 = 
	`new_token
(
line
, 
i
, 
len
);

88 if (!
head
)

89 return (
NULL
);

90 *
flag
 = 1;

91 return (
head
);

92 
	}
}

122 
t_token
 *
	$get_tokens
(char *
line
)

124 int 
i
;

125 int 
len
;

126 int 
flag
;

127 
t_token
 *
head
;

129 
i
 = 0;

130 
flag
 = 0;

131 
head
 = 
NULL
;

132 while (
line
[
i
])

134 
len
 = 
	`get_tokens_size
(
line
, &
i
);

135 if (
len
 == 0)

137 if (!
flag
)

139 
head
 = 
	`create_token_head
(
line
, 
i
, 
len
, &
flag
);

140 if (!
head
)

141 return (
	`free
(
line
), 
NULL
);

144 if (!
	`token_linked_list
(&
head
, 
line
, 
i
, 
len
))

145 return (
	`free_token
(&
head
), 
	`free
(
line
), 
NULL
);

146 
i
 += 
len
;

148 return (
	`free
(
line
), 
head
);

149 
	}
}

	@sauvegarde/parsing/expansion_test/token_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_token
(
t_token
 **
head
)

16 
t_token
 *
ptr
;

17 
t_token
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
content
);

27 
	`free
(
tmp
);

29 *
head
 = 
NULL
;

30 
head
 = 
NULL
;

31 
	}
}

46 
t_token
 *
	$new_token
(char *
line
, int 
start
, int 
len
)

48 
t_token
 *
token
;

50 
token
 = 
NULL
;

51 
token
 = 
	`malloc
(sizeof(
t_token
));

52 if (!
token
)

54 
	`malloc_error_print_message
(
	`strerror
(
errno
));

55 return (
NULL
);

57 
token
->
content
 = 
	`ft_substr
(
line
, 
start
, 
len
);

58 if (!
token
->
content
)

60 
	`malloc_error_print_message
(
	`strerror
(
errno
));

61 return (
	`free_token
(&
token
), 
NULL
);

63 
	`set_id
(
token
);

64 
token
->
next
 = 
NULL
;

65 return (
token
);

66 
	}
}

75 int 
	$link_token
(
t_token
 **
head
, t_token *
new
)

77 
t_token
 *
ptr
;

79 if (!
new
)

81 
ptr
 = *
head
;

82 while (
ptr
)

84 if (!
ptr
->
next
)

86 
ptr
 = ptr->
next
;

88 
ptr
->
next
 = 
new
;

90 
	}
}

113 int 
	$token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
)

115 
t_token
 *
new
;

117 if (!
head
)

119 
new
 = 
	`new_token
(
line
, 
start
, 
len
);

120 if (!
new
)

122 if (!
	`link_token
(
head
, 
new
))

125 
	}
}

	@sauvegarde/parsing/expansion_test/token_routine_delete.c

12 #include 
	~"minishell.h
"

14 int 
	$token_list_size
(
t_token
 **
head
)

16 
t_token
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

29 static 
t_token
 *
delete_helper
(t_token **
head
, t_token *
curr
, \

30 
t_token
 *
prev
, int 
i
)

32 int 
	gsize
;

34 
	gsize
 = 
token_list_size
(
head
);

35 if (
	gi
 == 0 && 
size
 == 1)

37 
free
(
curr
->
content
);

38 
free
(
curr
);

39 *
	ghead
 = 
NULL
;

40 return (*
	ghead
);

42 else if (
	gi
 == 0 && 
size
 > 1)

44 *
head
 = 
curr
->
next
;

45 
	gprev
 = *
head
;

47 else if (
	gi
 == 
size
 - 1)

48 
prev
->
next
 = 
NULL
;

50 
	gprev
->
	gnext
 = 
curr
->
next
;

51 
free
(
curr
->
content
);

52 
free
(
curr
);

53 
	gcurr
 = 
NULL
;

54 return (
	gprev
);

57 
t_token
 *
	$delete_token
(
t_token
 **
head
)

59 int 
i
;

60 
t_token
 *
curr
;

61 
t_token
 *
prev
;

63 
i
 = 0;

64 
curr
 = *
head
;

65 
prev
 = 
NULL
;

66 while (
curr
->
id
 != 
DELETE
)

68 
prev
 = 
curr
;

69 
curr
 = curr->
next
;

70 
i
++;

72 return (
	`delete_helper
(
head
, 
curr
, 
prev
, 
i
));

73 
	}
}

	@sauvegarde/parsing/expansion_test/token_routine_set_id.c

12 #include 
	~"minishell.h
"

14 int 
	$set_id_expansion
(
t_token
 *
token
)

16 if (
	`ft_strchr
(
token
->
content
, '$'))

17 return(
DOLLAR
);

18 return (
WORD
);

19 
	}
}

21 void 
	$set_id
(
t_token
 *
token
)

23 if (
	`ft_strncmp
(
token
->
content
, "|", 2) == 0)

24 
token
->
id
 = 
PIPELINE
;

25 else if (
	`ft_strncmp
(
token
->
content
, "<", 2) == 0)

26 
token
->
id
 = 
L_CHEVRON
;

27 else if (
	`ft_strncmp
(
token
->
content
, ">", 2) == 0)

28 
token
->
id
 = 
R_CHEVRON
;

29 else if (
	`ft_strncmp
(
token
->
content
, "<<", 3) == 0)

30 
token
->
id
 = 
HERE_DOC
;

31 else if (
	`ft_strncmp
(
token
->
content
, ">>", 3) == 0)

32 
token
->
id
 = 
APPEND
;

33 else if (
	`ft_strchr
(
token
->
content
, '$'))

34 
token
->
id
 = 
DOLLAR
;

36 
token
->
id
 = 
WORD
;

38 
	}
}

	@sauvegarde/parsing/expansion_trim_dollar.c

12 #include 
	~"minishell.h
"

17 static int 
	$copy_string
(
t_token
 *
curr
, char **
s
, int 
pos
)

19 int 
i
;

20 int 
j
;

22 
i
 = 0;

23 
j
 = 0;

24 *
s
 = 
	`malloc
(sizeof(char) * 
	`ft_strlen
(
curr
->
content
));

25 if (!*
s
)

27 
i
 = 0;

28 while (
curr
->
content
[
i
])

30 if (
i
 == 
pos
)

31 
i
++;

32 (*
s
)[
j
] = 
curr
->
content
[
i
];

33 
i
++;

34 
j
++;

36 (*
s
)[
j
] = '\0';

37 
	`free
(
curr
->
content
);

38 
curr
->
content
 = *
s
;

40 
	}
}

46 int 
	$trim_dollar
(
t_token
 *
curr
, int 
pos
)

48 int 
i
;

49 int 
start
;

50 char *
s
;

52 
s
 = 
NULL
;

53 
i
 = 0;

54 
start
 = 0;

55 while (
curr
->
content
[
i
])

57 if (
	`is_double_quote
(
curr
->
content
[
i
]))

59 
start
 = 
i
;

60 
i
 = 
	`loop_through
(
curr
->
content
, i);

61 if (
pos
 > 
start
 && pos < 
i
)

64 
i
++;

66 if (!
	`copy_string
(
curr
, &
s
, 
pos
))

67 return (
ERROR_EXIT
);

69 
	}
}

	@sauvegarde/parsing/parsing.c

12 #include 
	~"minishell.h
"

16 void 
	$print_token
(
t_token
 **
head
)

18 int 
i
;

19 
t_token
 *
tmp
;

21 
i
 = 0;

22 if (!*
head
 || !head)

24 
tmp
 = *
head
;

25 
	`printf
("----PARSING---\n");

26 while (
tmp
)

28 if (
tmp
->
id
 == 
L_CHEVRON
)

29 
	`printf
("L_CHEVRON :");

30 else if (
tmp
->
id
 == 
R_CHEVRON
)

31 
	`printf
("R_CHEVRON :");

32 else if (
tmp
->
id
 == 
PIPELINE
)

33 
	`printf
("PIPELINE :");

34 else if (
tmp
->
id
 == 
WORD
)

35 
	`printf
("WORD :");

36 else if (
tmp
->
id
 == 
APPEND
)

37 
	`printf
("APPEND :");

38 else if (
tmp
->
id
 == 
HERE_DOC
)

39 
	`printf
("HERE_DOC :");

40 else if (
tmp
->
id
 == 
DOLLAR
)

41 
	`printf
("DOLLAR :");

42 while (
tmp
->
content
[
i
])

44 
	`printf
 ("%c", 
tmp
->
content
[
i
]);

45 
i
++;

47 
	`printf
 ("%c", 
tmp
->
content
[
i
]);

48 
	`printf
 ("\n");

49 
i
 = 0;

50 
tmp
 = tmp->
next
;

52 
	`printf
("----END----\n");

53 
	}
}

91 
t_token
 *
	$parsing
(char *
line
)

93 
t_token
 *
token
;

95 if (!
	`syntax_error_check
(
line
))

96 return (
NULL
);

97 
token
 = 
	`get_tokens
(
line
);

98 if (!
token
)

99 return (
NULL
);

100 if (!
	`expansion
(&
token
, token, 0))

101 return (
NULL
);

102 if (!
	`quote_removing
(&
token
, token, 0))

103 return (
NULL
);

105 return (
token
);

106 
	}
}

	@sauvegarde/parsing/quote_removing.c

12 #include 
	~"minishell.h
"

14 static int 
copy_string_unquoted
(
t_token
 *
curr
, char *
new_str
, \

15 int 
start
, int 
pos
)

17 int 
	gj
;

18 int 
	gi
;

19 int 
	gsave
;

21 
	gj
 = 0;

22 
	gi
 = 0;

23 
	gsave
 = 0;

24 while (
	gcurr
->
	gcontent
[
i
])

26 if (
	gi
 == 
start
)

27 
i
++;

28 else if (
	gi
 == 
pos
)

30 
i
++;

31 
	gsave
 = 
j
;

35 
	gnew_str
[
j
] = 
curr
->
content
[
i
];

36 
	gi
++;

37 
	gj
++;

40 
	gnew_str
[
j
] = '\0';

41 return (
	gsave
);

44 int 
	$string_replace
(
t_token
 *
curr
, int 
start
, int 
pos
)

46 int 
save
;

47 char *
new_str
;

49 
new_str
 = 
	`malloc
(sizeof(char) * (
	`ft_strlen
(
curr
->
content
) - 2 + 1));

50 if (!
new_str
)

52 
	`malloc_error_print_message
(
	`strerror
(
errno
));

53 return (
ERROR_EXIT
);

55 
save
 = 
	`copy_string_unquoted
(
curr
, 
new_str
, 
start
, 
pos
);

56 
	`free
(
curr
->
content
);

57 
curr
->
content
 = 
NULL
;

58 
curr
->
content
 = 
new_str
;

59 return (
save
);

60 
	}
}

62 int 
	$remove_q
(
t_token
 *
curr
, int 
pos
)

64 int 
start
;

66 
start
 = 
pos
;

67 
pos
 = 
	`loop_through
(
curr
->
content
, pos);

68 
pos
 = 
	`string_replace
(
curr
, 
start
, pos);

69 if (
pos
 == 
ERROR_EXIT
)

70 return (
ERROR_EXIT
);

71 return (
pos
++);

72 
	}
}

74 int 
	$quote_removing
(
t_token
 **
head
, t_token *
curr
, int 
pos
)

76 if (!
head
 || !*head)

78 if (
curr
->
content
[
pos
] == '\0')

80 if (
curr
->
next
)

82 
pos
 = 0;

83 
curr
 = curr->
next
;

84 
	`quote_removing
(
head
, 
curr
, 
pos
);

88 else if (
	`is_quote
(
curr
->
content
[
pos
]))

90 
pos
 = 
	`remove_q
(
curr
, pos);

91 if (
pos
 == 
ERROR_EXIT
)

92 return (
	`free_token
(
head
), 0);

93 
	`quote_removing
(
head
, 
curr
, 
pos
);

97 
pos
++;

98 
	`quote_removing
(
head
, 
curr
, 
pos
);

101 
	}
}

	@sauvegarde/parsing/syntax_errors.c

12 #include 
	~"minishell.h
"

14 int 
	$check_multiple_operators_error
(int 
i
, int 
num
, char 
c
)

16 if (
i
 > 
num
)

18 if (
	`is_chevron
(
c
))

19 
	`print_syntax_error_dchar
(
c
);

20 else if (
	`is_pipeline
(
c
))

21 
	`print_syntax_error_char
(
c
);

25 
	}
}

27 int 
	$count_metachar
(char *
s
, char 
c
, int 
num
)

29 int 
i
;

31 
i
 = 1;

32 while (
s
[
i
] && s[i] == 
c
)

33 
i
++;

34 if (!
	`check_multiple_operators_error
(
i
, 
num
, 
c
))

36 while (
s
[
i
] && 
	`is_blank
(s[i]))

37 
i
++;

38 if (
	`is_operator
(
s
[
i
]) && !
	`is_pipeline
(
c
))

40 
c
 = 
s
[
i
];

41 if (
	`is_chevron
(
c
) && is_chevron(
s
[
i
 + 1]))

42 return (
	`print_syntax_error_dchar
(
c
), 0);

44 
	`print_syntax_error_char
(
c
);

47 else if (
s
[
i
] == '\0')

48 return (
	`print_syntax_error_str
("newline"), 0);

50 
	}
}

52 int 
	$check_quotes_errors
(char *
s
, char 
c
, int *
i
)

54 int 
j
;

56 
j
 = *
i
 + 1;

57 while (
s
[
j
] && s[j] != 
c
)

58 
j
++;

59 if (
s
[
j
] != 
c
)

61 
	`print_syntax_error_char
(
c
);

64 (*
i
)++;

65 while (
s
[*
i
] && s[*i] != 
c
)

66 (*
i
)++;

68 
	}
}

70 int 
	$check_pipeline_errors
(char *
s
, int 
i
, char 
c
, int 
num
)

72 int 
j
;

74 
j
 = 0;

75 while (
s
[
j
] && 
	`is_blank
(s[j]))

76 
j
++;

77 if (
s
[
j
] == 
c
)

79 
	`print_syntax_error_char
(
c
);

82 if (!
	`count_metachar
(&
s
[
i
], 
c
, 
num
))

85 
	}
}

132 int 
	$syntax_error_check
(char *
s
)

134 int 
i
;

136 
i
 = 0;

137 while (
s
[
i
])

139 if (
	`is_quote
(
s
[
i
]))

141 if (!
	`check_quotes_errors
(
s
, s[
i
], &i))

142 return (
	`free
(
s
), 0);

144 else if ((
	`is_lchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '<', 2)) || \

145 (
	`is_rchevron
(
s
[
i
]) && !
	`count_metachar
(&s[i], '>', 2)))

146 return (
	`free
(
s
), 0);

147 else if (
	`is_pipeline
(
s
[
i
]) && !
	`check_pipeline_errors
(s, i, '|', 1))

148 return (
	`free
(
s
), 0);

149 
i
++;

152 
	}
}

	@sauvegarde/parsing/syntax_errors_print_message.c

12 #include 
	~"minishell.h
"

19 void 
	$print_syntax_error_char
(char 
c
)

21 
	`ft_dprintf
(2, "minishell: ");

22 
	`ft_dprintf
(2, "syntax error near unexpected token ");

23 
	`ft_dprintf
(2, "\'%c\'\n", 
c
);

24 
g_shell
->
exit_status
 = 258;

25 
	}
}

27 void 
	$print_syntax_error_dchar
(char 
c
)

29 
	`ft_dprintf
(2, "minishell: ");

30 
	`ft_dprintf
(2, "syntax error near unexpected token ");

31 
	`ft_dprintf
(2, "\'%c%c\'\n", 
c
, c);

32 
g_shell
->
exit_status
 = 258;

33 
	}
}

35 void 
	$print_syntax_error_str
(char *
s
)

37 
	`ft_dprintf
(2, "minishell: ");

38 
	`ft_dprintf
(2, "syntax error near unexpected token ");

39 
	`ft_dprintf
(2, "\'%s\'\n", 
s
);

40 
g_shell
->
exit_status
 = 258;

41 
	}
}

	@sauvegarde/parsing/tests/main_parsing_syntax_errors.c

12 #include 
	~"minishell.h
"

14 int 
	gg_exit_status
 = 0;

18 int 
	$main
(int 
ac
, char **
av
)

20 (void)
ac
;

21 char *
line
;

22 
line
 = 
	`ft_strdup
(
av
[1]);

23 
	`syntax_error_check
(
line
);

24 
	`printf
("exit_status = %d\n", 
exit_status
);

25 return (
exit_status
);

26 
	}
}

	@sauvegarde/parsing/tests/main_parsing_token_extraction.c

12 #include 
	~"minishell.h
"

14 int 
	gexit_status
 = 0;

26 int 
	$main
(int 
ac
, char **
av
)

28 (void)
ac
;

29 
t_token
 *
head
;

30 
t_token
 *
ptr
;

31 char *
line
;

33 
line
 = 
NULL
;

34 
head
 = 
NULL
;

35 
line
 = 
	`ft_strdup
(
av
[1]);

36 
head
 = 
	`get_words
(
line
);

37 if (!
head
)

39 
	`printf
(" exit from main\n");

40 return (
exit_status
);

42 
ptr
 = 
head
;

43 while (
ptr
)

45 
	`printf
("from main: %s\n", 
ptr
->
content
);

46 
ptr
 = ptr->
next
;

48 
	`free_token
(&
head
);

49 return (
exit_status
);

50 
	}
}

	@sauvegarde/parsing/tests/main_token_routine.c

12 #include 
	~"minishell.h
"

14 int 
	gg_exit_status
 = 0;

18 int 
	$main
(int 
ac
, char **
av
)

20 (void)
ac
;

21 
t_token
 *
head
;

22 
t_token
 *
ptr
;

23 int 
i
;

24 int 
j
;

25 char **
line
;

27 
i
 = 0;

28 
j
 = 1;

29 
line
 = 
	`malloc
(sizeof(char *) * 
ac
);

30 while (
av
[
j
])

32 
line
[
i
] = 
	`ft_strdup
(
av
[
j
]);

33 
i
++;

34 
j
++;

36 
line
[
i
] = 
NULL
;

37 
head
 = 
NULL
;

38 
head
 = 
	`new_token
(
line
[0], 0, 
	`ft_strlen
(line[0]));

39 if (!
head
)

41 
	`printf
("malloc: %s\n", 
	`strerror
(
errno
));

44 
i
 = 1;

45 while (
line
[
i
])

47 
	`token_linked_list
(&
head
, 
line
[
i
], 0, 
	`ft_strlen
(line[i]));

48 
i
++;

50 
i
 = 0;

51 
ptr
 = 
head
;

52 while (
ptr
)

54 
	`printf
("%s\n", 
ptr
->
content
);

55 
ptr
 = ptr->
next
;

56 
i
++;

58 
	`free_token
(&
head
);

59 return (
exit_status
);

60 
	}
}

	@sauvegarde/parsing/token_extraction.c

12 #include 
	~"minishell.h
"

21 int 
	$character_extraction
(char *
line
, int 
ind
)

23 if ((
line
[
ind
] == '>' && line[ind + 1] == '>') || \

24 (
line
[
ind
] == '<' && line[ind + 1] == '<'))

27 
	}
}

43 int 
	$word_extraction
(char *
line
, int 
ind
)

45 int 
start
;

46 char 
c
;

48 
start
 = 
ind
;

49 while (
	`is_word
(
line
[
ind
]) && line[ind])

51 if (
	`is_quote
(
line
[
ind
]))

53 
c
 = 
line
[
ind
];

54 
ind
++;

55 while (
line
[
ind
] && line[ind] != 
c
)

56 
ind
++;

58 
ind
++;

60 return (
ind
 - 
start
);

61 
	}
}

64 int 
	$get_tokens_size
(char *
line
, int *
i
)

66 int 
len
;

68 
len
 = 0;

69 while (
	`is_blank
(
line
[*
i
]))

70 (*
i
)++;

71 if (
	`is_word
(
line
[*
i
]))

72 
len
 = 
	`word_extraction
(
line
, *
i
);

73 else if (
	`is_operator
(
line
[*
i
]))

74 
len
 = 
	`character_extraction
(
line
, *
i
);

75 return (
len
);

76 
	}
}

83 
t_token
 *
	$create_token_head
(char *
line
, int 
i
, int 
len
, int *
flag
)

85 
t_token
 *
head
;

87 
head
 = 
	`new_token
(
line
, 
i
, 
len
);

88 if (!
head
)

89 return (
NULL
);

90 *
flag
 = 1;

91 return (
head
);

92 
	}
}

122 
t_token
 *
	$get_tokens
(char *
line
)

124 int 
i
;

125 int 
len
;

126 int 
flag
;

127 
t_token
 *
head
;

129 
i
 = 0;

130 
flag
 = 0;

131 
head
 = 
NULL
;

132 while (
line
[
i
])

134 
len
 = 
	`get_tokens_size
(
line
, &
i
);

135 if (
len
 == 0)

137 if (!
flag
)

139 
head
 = 
	`create_token_head
(
line
, 
i
, 
len
, &
flag
);

140 if (!
head
)

141 return (
	`free
(
line
), 
NULL
);

144 if (!
	`token_linked_list
(&
head
, 
line
, 
i
, 
len
))

145 return (
	`free_token
(&
head
), 
	`free
(
line
), 
NULL
);

146 
i
 += 
len
;

148 return (
	`free
(
line
), 
head
);

149 
	}
}

	@sauvegarde/test_getenv.c

1 #include 
	~"minishell.h
"

6 int 
	$main
(int 
ac
, char **
av
, char **
envp
)

8 (void)
ac
;

9 (void)
av
;

11 
t_env
 **
env
;

12 
t_env
 *
ptr
;

13 
env
 = 
	`get_envp
(
envp
);

14 if (!
env
)

16 
ptr
 = *
env
;

17 while (
ptr
 != 
NULL
)

19 
	`printf
("%s", 
ptr
->
var_name
);

20 
	`printf
("%s\n", 
ptr
->
var_value
);

21 
ptr
 = ptr->
next
;

24 
	}
}

	@sauvegarde/test_tgetent.c

1 #include 
	~<stdio.h
>

2 #include 
	~<stdlib.h
>

3 #include 
	~<termcap.h
>

5 int 
	$main
() {

6 char 
term_buffer
[2048];

7 char *
term_type
 = 
	`getenv
("TERM");

9 if (
term_type
 == 
NULL
) {

10 
	`fprintf
(
stderr
, "La variable d'environnement TERM n'est pas dfinie.\n");

15 if (
	`tgetent
(
term_buffer
, 
term_type
) != 1) {

16 
	`fprintf
(
stderr
, "Impossible d'obtenir les informations du terminal.\n");

21 char *
cursor_motion
 = 
	`tgetstr
("cm", 
NULL
);

22 if (
cursor_motion
 == 
NULL
) {

23 
	`fprintf
(
stderr
, "La capacit cm (dplacement du curseur) n'est pas prise en charge par ce terminal.\n");

27 
	`printf
("Les informations du terminal %s ont t rcupres avec succs.\n", 
term_type
);

28 
	`printf
("La capacit cm (dplacement du curseur) est : %s\n", 
cursor_motion
);

31 
	}
}

	@sauvegarde/tokens/token_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_token
(
t_token
 **
head
)

16 
t_token
 *
ptr
;

17 
t_token
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
content
);

27 
	`free
(
tmp
);

29 *
head
 = 
NULL
;

30 
head
 = 
NULL
;

31 
	}
}

46 
t_token
 *
	$new_token
(char *
line
, int 
start
, int 
len
)

48 
t_token
 *
token
;

50 
token
 = 
NULL
;

51 
token
 = 
	`malloc
(sizeof(
t_token
));

52 if (!
token
)

54 
	`malloc_error_print_message
(
	`strerror
(
errno
));

55 return (
NULL
);

57 
token
->
content
 = 
	`ft_substr
(
line
, 
start
, 
len
);

58 if (!
token
->
content
)

60 
	`malloc_error_print_message
(
	`strerror
(
errno
));

61 return (
	`free_token
(&
token
), 
NULL
);

63 
	`set_id
(
token
);

64 
token
->
next
 = 
NULL
;

65 return (
token
);

66 
	}
}

75 int 
	$link_token
(
t_token
 **
head
, t_token *
new
)

77 
t_token
 *
ptr
;

79 if (!
new
)

81 
ptr
 = *
head
;

82 while (
ptr
)

84 if (!
ptr
->
next
)

86 
ptr
 = ptr->
next
;

88 
ptr
->
next
 = 
new
;

90 
	}
}

113 int 
	$token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
)

115 
t_token
 *
new
;

117 if (!
head
)

119 
new
 = 
	`new_token
(
line
, 
start
, 
len
);

120 if (!
new
)

122 if (!
	`link_token
(
head
, 
new
))

125 
	}
}

	@sauvegarde/tokens/token_routine_delete.c

12 #include 
	~"minishell.h
"

14 int 
	$token_list_size
(
t_token
 **
head
)

16 
t_token
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

29 static 
t_token
 *
delete_helper
(t_token **
head
, t_token *
curr
, \

30 
t_token
 *
prev
, int 
i
)

32 int 
	gsize
;

34 
	gsize
 = 
token_list_size
(
head
);

35 if (
	gi
 == 0 && 
size
 == 1)

37 
free
(
curr
->
content
);

38 
free
(
curr
);

39 *
	ghead
 = 
NULL
;

40 return (*
	ghead
);

42 else if (
	gi
 == 0 && 
size
 > 1)

44 *
head
 = 
curr
->
next
;

45 
	gprev
 = *
head
;

47 else if (
	gi
 == 
size
 - 1)

48 
prev
->
next
 = 
NULL
;

50 
	gprev
->
	gnext
 = 
curr
->
next
;

51 
free
(
curr
->
content
);

52 
free
(
curr
);

53 
	gcurr
 = 
NULL
;

54 return (
	gprev
);

57 
t_token
 *
	$delete_token
(
t_token
 **
head
)

59 int 
i
;

60 
t_token
 *
curr
;

61 
t_token
 *
prev
;

63 
i
 = 0;

64 
curr
 = *
head
;

65 
prev
 = 
NULL
;

66 while (
curr
->
id
 != 
DELETE
)

68 
prev
 = 
curr
;

69 
curr
 = curr->
next
;

70 
i
++;

72 return (
	`delete_helper
(
head
, 
curr
, 
prev
, 
i
));

73 
	}
}

	@sauvegarde/tokens/token_routine_set_id.c

12 #include 
	~"minishell.h
"

14 int 
	$set_id_expansion
(
t_token
 *
token
)

16 if (
	`ft_strchr
(
token
->
content
, '$'))

17 return (
DOLLAR
);

18 return (
WORD
);

19 
	}
}

21 void 
	$set_id
(
t_token
 *
token
)

23 if (
	`ft_strncmp
(
token
->
content
, "|", 2) == 0)

24 
token
->
id
 = 
PIPELINE
;

25 else if (
	`ft_strncmp
(
token
->
content
, "<", 2) == 0)

26 
token
->
id
 = 
L_CHEVRON
;

27 else if (
	`ft_strncmp
(
token
->
content
, ">", 2) == 0)

28 
token
->
id
 = 
R_CHEVRON
;

29 else if (
	`ft_strncmp
(
token
->
content
, "<<", 3) == 0)

30 
token
->
id
 = 
HERE_DOC
;

31 else if (
	`ft_strncmp
(
token
->
content
, ">>", 3) == 0)

32 
token
->
id
 = 
APPEND
;

33 else if (
	`ft_strchr
(
token
->
content
, '$'))

34 
token
->
id
 = 
DOLLAR
;

36 
token
->
id
 = 
WORD
;

38 
	}
}

	@signal_handler/child_sig_handler.c

12 #include 
	~"minishell.h
"

14 static void 
	$child_handler
(int 
sig_code
)

16 if (
sig_code
 == 
SIGINT
)

18 
	`printf
("\n");

20 else if (
sig_code
 == 
SIGQUIT
)

22 
	`printf
("QUIT: 3\n");

24 else if (
sig_code
 == 
SIGTSTP
)

26 
	`ft_printf
("\n");

27 
g_shell
->
suspended
++;

28 
	`ft_printf
("[%d]+ Stopped", 
g_shell
->
suspended
);

30 else if (
sig_code
 == 
SIGSTOP
)

32 
	`printf
("sig stop recieved\n");

34 
g_shell
->
exit_status
 = 
sig_code
 + 128;

36 
	}
}

38 void 
	$child_signals_init
(
sigset_t
 *
set
)

40 
	`sigemptyset
(
set
);

41 
	`sigaddset
(
set
, 
SIGINT
);

42 
	`sigaddset
(
set
, 
SIGQUIT
);

43 
	`sigaddset
(
set
, 
SIGTERM
);

44 
	`sigaddset
(
set
, 
SIGTSTP
);

45 
	`sigaddset
(
set
, 
SIGSTOP
);

47 
	}
}

49 void 
	$child_signal_handler
(int 
pid
)

51 (void)
pid
;

52 struct 
sigaction
 
act
;

54 
	`ft_memset
(&
act
, 0, sizeof(struct 
sigaction
));

55 
	`child_signals_init
(&
act
.
sa_mask
);

56 
act
.
sa_handler
 = &
child_handler
;

57 
	`sigaction
(
SIGQUIT
, &
act
, 0);

58 
	`sigaction
(
SIGINT
, &
act
, 0);

59 
	`sigaction
(
SIGTSTP
, &
act
, 0);

60 
	`sigaction
(
SIGTERM
, &
act
, 0);

61 
	`sigaction
(
SIGSTOP
, &
act
, &
g_shell
->
sig_term
);

62 
	}
}

	@signal_handler/parent_sig_handler.c

12 #include 
	~"minishell.h
"

21 static void 
	$handler
(int 
sig_code
)

23 if (
sig_code
 == 
SIGINT
)

25 
	`printf
("\n");

26 
g_shell
->
exit_status
 = 1;

27 
	`rl_replace_line
("", 0);

28 
	`rl_on_new_line
();

29 
	`rl_redisplay
();

31 
	}
}

33 void 
	$signals_init
(
sigset_t
 *
set
)

35 
	`sigemptyset
(
set
);

36 
	`sigaddset
(
set
, 
SIGINT
);

37 
	`sigaddset
(
set
, 
SIGQUIT
);

38 
	`sigaddset
(
set
, 
SIGTERM
);

39 
	`sigaddset
(
set
, 
SIGTSTP
);

40 
	`sigaddset
(
set
, 
SIGSTOP
);

42 
	}
}

44 void 
	$parent_signal_handler
(void)

46 struct 
sigaction
 
act
;

48 
	`ft_memset
(&
act
, 0, sizeof(struct 
sigaction
));

49 
	`signals_init
(&
act
.
sa_mask
);

50 
act
.
sa_handler
 = 
SIG_IGN
;

51 
	`sigaction
(
SIGQUIT
, &
act
, &
g_shell
->
sig_quit
);

52 
	`sigaction
(
SIGTERM
, &
act
, &
g_shell
->
sig_term
);

53 
	`sigaction
(
SIGTSTP
, &
act
, &
g_shell
->
sig_tstp
);

54 
act
.
sa_handler
 = 
handler
;

55 
	`sigaction
(
SIGINT
, &
act
, &
g_shell
->
sig_int
);

56 
	}
}

	@test.c

1 #include 
	~<fcntl.h
>

2 #include 
	~"libft/includes/libft.h
"

3 #include 
	~<unistd.h
>

4 #include 
	~<stdio.h
>

5 #include 
	~<sys/errno.h
>

6 #include 
	~<string.h
>

8 int 
	$main
(void)

10 char *
file
 = "file";

11 char *
file1
 = ".file1";

12 char *
file2
 = "../file2";

13 char *
file3
 = ".file3";

14 char *
file4
 = ".file4";

15 char *
file5
 = ".file5";

16 char *
file6
 = ".file6";

17 int 
fd_file
;

18 int 
fd_file1
;

19 int 
fd_file2
;

20 int 
fd_file3
;

21 int 
fd_file4
;

22 int 
fd_file5
;

23 int 
fd_file6
;

24 int 
save_fd_out
;

27 
fd_file
 = 
	`open
(
file
, 
O_WRONLY
 | 
O_CREAT
 | 
O_TRUNC
 , 0644 );

28 
fd_file1
 = 
	`open
(
file1
, 
O_WRONLY
 | 
O_CREAT
 | 
O_TRUNC
 , 0644 );

29 
fd_file2
 = 
	`open
(
file2
, 
O_WRONLY
 | 
O_CREAT
 | 
O_TRUNC
 , 0644 );

30 
fd_file3
 = 
	`open
(
file3
, 
O_WRONLY
 | 
O_CREAT
 | 
O_TRUNC
 , 0644 );

31 
fd_file4
 = 
	`open
(
file4
, 
O_WRONLY
 | 
O_CREAT
 | 
O_TRUNC
 , 0644 );

32 
fd_file5
 = 
	`open
(
file5
, 
O_WRONLY
 | 
O_CREAT
 | 
O_TRUNC
 , 0644 );

33 
fd_file6
 = 
	`open
(
file6
, 
O_WRONLY
 | 
O_CREAT
 | 
O_TRUNC
 , 0644 );

35 
save_fd_out
 = 
	`dup
(
STDOUT_FILENO
);

36 
	`dup2
(
fd_file
, 
STDOUT_FILENO
);

38 
	`ft_printf
("fd_file = %d\n", 
fd_file
);

39 
	`ft_printf
("fd_file1 = %d\n", 
fd_file1
);

40 
	`ft_printf
("fd_file2 = %d\n", 
fd_file2
);

41 
	`ft_printf
("fd_file3 = %d\n", 
fd_file3
);

42 
	`ft_printf
("fd_file4 = %d\n", 
fd_file4
);

43 
	`ft_printf
("fd_file5 = %d\n", 
fd_file5
);

44 
	`ft_printf
("fd_file6 = %d\n", 
fd_file6
);

45 
	`ft_printf
("save_fd_out = %d\n", 
save_fd_out
);

47 
	`close
(
fd_file
);

48 
	`ft_putstr_fd
("coucou\n", 
STDOUT_FILENO
);

50 
	`dup2
(
save_fd_out
, 
STDOUT_FILENO
);

51 
	`ft_dprintf
(
STDOUT_FILENO
,"hello\n");

53 int 
err
 = 
	`open
("errorfile", 
O_WRONLY
 | 
O_CREAT
 | 
O_TRUNC
 , 0644 );

54 int 
save_fd_err
 = 
	`dup
(
STDERR_FILENO
);

55 
	`dup2
(
err
, 
STDERR_FILENO
);

56 
	`close
(
err
);

58 
	`access
("refdw", 
F_OK
);

59 
	`ft_dprintf
(
STDERR_FILENO
, "%s\n", 
	`strerror
(
errno
));

60 
	`access
("refdw", 
F_OK
);

61 
	`ft_dprintf
(
STDERR_FILENO
, "%s\n", 
	`strerror
(
errno
));

62 
	`access
("refdw", 
F_OK
);

63 
	`ft_dprintf
(
STDERR_FILENO
, "%s\n", 
	`strerror
(
errno
));

64 
	`access
("refdw", 
F_OK
);

65 
	`ft_dprintf
(
STDERR_FILENO
, "%s\n", 
	`strerror
(
errno
));

67 
	`dup2
(
save_fd_err
, 
STDERR_FILENO
);

68 
	`access
("refdw", 
F_OK
);

69 
	`ft_dprintf
(
STDERR_FILENO
, "%s\n", 
	`strerror
(
errno
));

70 
	}
}

	@tokens/token_routine.c

12 #include 
	~"minishell.h
"

14 void 
	$free_token
(
t_token
 **
head
)

16 
t_token
 *
ptr
;

17 
t_token
 *
tmp
;

19 if (!
head
 || !*head)

21 
ptr
 = *
head
;

22 while (
ptr
 != 
NULL
)

24 
tmp
 = 
ptr
;

25 
ptr
 = 
tmp
->
next
;

26 
	`free
(
tmp
->
content
);

27 
	`free
(
tmp
);

29 *
head
 = 
NULL
;

30 
head
 = 
NULL
;

31 
	}
}

46 
t_token
 *
	$new_token
(char *
line
, int 
start
, int 
len
)

48 
t_token
 *
token
;

50 
token
 = 
NULL
;

51 
token
 = 
	`malloc
(sizeof(
t_token
));

52 if (!
token
)

54 
	`malloc_error_print_message
(
	`strerror
(
errno
));

55 return (
NULL
);

57 
token
->
content
 = 
	`ft_substr
(
line
, 
start
, 
len
);

58 if (!
token
->
content
)

60 
	`malloc_error_print_message
(
	`strerror
(
errno
));

61 return (
	`free_token
(&
token
), 
NULL
);

63 
	`set_id
(
token
);

64 
token
->
next
 = 
NULL
;

65 return (
token
);

66 
	}
}

75 int 
	$link_token
(
t_token
 **
head
, t_token *
new
)

77 
t_token
 *
ptr
;

79 if (!
new
)

81 
ptr
 = *
head
;

82 while (
ptr
)

84 if (!
ptr
->
next
)

86 
ptr
 = ptr->
next
;

88 
ptr
->
next
 = 
new
;

90 
	}
}

113 int 
	$token_linked_list
(
t_token
 **
head
, char *
line
, int 
start
, int 
len
)

115 
t_token
 *
new
;

117 if (!
head
)

119 
new
 = 
	`new_token
(
line
, 
start
, 
len
);

120 if (!
new
)

122 if (!
	`link_token
(
head
, 
new
))

125 
	}
}

	@tokens/token_routine_delete.c

12 #include 
	~"minishell.h
"

14 int 
	$token_list_size
(
t_token
 **
head
)

16 
t_token
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

29 static 
t_token
 *
delete_helper
(t_token **
head
, t_token *
curr
, \

30 
t_token
 *
prev
, int 
i
)

32 int 
	gsize
;

34 
	gsize
 = 
token_list_size
(
head
);

35 if (
	gi
 == 0 && 
size
 == 1)

37 
free
(
curr
->
content
);

38 
free
(
curr
);

39 *
	ghead
 = 
NULL
;

40 return (*
	ghead
);

42 else if (
	gi
 == 0 && 
size
 > 1)

44 *
head
 = 
curr
->
next
;

45 
	gprev
 = *
head
;

47 else if (
	gi
 == 
size
 - 1)

48 
prev
->
next
 = 
NULL
;

50 
	gprev
->
	gnext
 = 
curr
->
next
;

51 
free
(
curr
->
content
);

52 
free
(
curr
);

53 
	gcurr
 = 
NULL
;

54 return (
	gprev
);

57 
t_token
 *
	$delete_token
(
t_token
 **
head
)

59 int 
i
;

60 
t_token
 *
curr
;

61 
t_token
 *
prev
;

63 
i
 = 0;

64 
curr
 = *
head
;

65 
prev
 = 
NULL
;

66 while (
curr
->
id
 != 
DELETE
)

68 
prev
 = 
curr
;

69 
curr
 = curr->
next
;

70 
i
++;

72 return (
	`delete_helper
(
head
, 
curr
, 
prev
, 
i
));

73 
	}
}

	@tokens/token_routine_set_id.c

12 #include 
	~"minishell.h
"

14 int 
	$set_id_expansion
(
t_token
 *
token
)

16 if (
	`ft_strchr
(
token
->
content
, '$'))

17 return (
DOLLAR
);

18 return (
WORD
);

19 
	}
}

21 void 
	$set_id
(
t_token
 *
token
)

23 if (
	`ft_strncmp
(
token
->
content
, "|", 2) == 0)

24 
token
->
id
 = 
PIPELINE
;

25 else if (
	`ft_strncmp
(
token
->
content
, "<", 2) == 0)

26 
token
->
id
 = 
L_CHEVRON
;

27 else if (
	`ft_strncmp
(
token
->
content
, ">", 2) == 0)

28 
token
->
id
 = 
R_CHEVRON
;

29 else if (
	`ft_strncmp
(
token
->
content
, "<<", 3) == 0)

30 
token
->
id
 = 
HERE_DOC
;

31 else if (
	`ft_strncmp
(
token
->
content
, ">>", 3) == 0)

32 
token
->
id
 = 
APPEND
;

33 else if (
	`ft_strchr
(
token
->
content
, '$'))

34 
token
->
id
 = 
DOLLAR
;

36 
token
->
id
 = 
WORD
;

38 
	}
}

	@utils.c

12 #include 
	~"minishell.h
"

14 void 
	$free_before_exit
(
t_cmd
 **
head
)

16 
	`free_shell
();

17 
	`free_cmd
(
head
);

18 
	}
}

20 int 
	$size_tab2d
(char **
s
)

22 int 
i
;

24 
i
 = 0;

25 while (
s
[
i
])

26 
i
++;

27 return (
i
);

28 
	}
}

30 void 
	$free_and_exit_prog
(
t_cmd
 **
head
, int 
exit_code
)

32 
	`free_cmd
(
head
);

33 
	`free_shell
();

34 
	`exit
 (
exit_code
);

35 
	}
}

	@
1
.
0
654
28419
TESTS/execution_test/cmd_is_bin.c
TESTS/execution_test/copy_env_tab.c
TESTS/execution_test/envp_routine.c
TESTS/execution_test/execution.c
TESTS/execution_test/handler_ctr_c.c
TESTS/execution_test/is_dollar.c
TESTS/execution_test/is_operator.c
TESTS/execution_test/is_question.c
TESTS/execution_test/is_quote.c
TESTS/execution_test/is_token.c
TESTS/execution_test/is_white_space.c
TESTS/execution_test/launch_setup.c
TESTS/execution_test/libft/ft_printf/ft_count_int.c
TESTS/execution_test/libft/ft_printf/ft_count_unsigned_int.c
TESTS/execution_test/libft/ft_printf/ft_dprintf.c
TESTS/execution_test/libft/ft_printf/ft_printf.c
TESTS/execution_test/libft/ft_printf/ft_printf_address.c
TESTS/execution_test/libft/ft_printf/ft_printf_char.c
TESTS/execution_test/libft/ft_printf/ft_printf_hexa.c
TESTS/execution_test/libft/ft_printf/ft_printf_int.c
TESTS/execution_test/libft/ft_printf/ft_printf_str.c
TESTS/execution_test/libft/ft_printf/ft_printf_unsint.c
TESTS/execution_test/libft/ft_printf/ft_put_hexanbr_fd.c
TESTS/execution_test/libft/ft_printf/ft_put_int.c
TESTS/execution_test/libft/ft_printf/ft_put_unsnbr_fd.c
TESTS/execution_test/libft/get_next_line/get_next_line.c
TESTS/execution_test/libft/get_next_line/get_next_line_bonus.c
TESTS/execution_test/libft/get_next_line/get_next_line_utils.c
TESTS/execution_test/libft/includes/ft_printf.h
TESTS/execution_test/libft/includes/get_next_line.h
TESTS/execution_test/libft/includes/libft.h
TESTS/execution_test/libft/libft/del.c
TESTS/execution_test/libft/libft/ft_atoi.c
TESTS/execution_test/libft/libft/ft_atoi_base.c
TESTS/execution_test/libft/libft/ft_bzero.c
TESTS/execution_test/libft/libft/ft_calloc.c
TESTS/execution_test/libft/libft/ft_isalnum.c
TESTS/execution_test/libft/libft/ft_isalpha.c
TESTS/execution_test/libft/libft/ft_isascii.c
TESTS/execution_test/libft/libft/ft_isdigit.c
TESTS/execution_test/libft/libft/ft_isprint.c
TESTS/execution_test/libft/libft/ft_itoa.c
TESTS/execution_test/libft/libft/ft_lstadd_back.c
TESTS/execution_test/libft/libft/ft_lstadd_front.c
TESTS/execution_test/libft/libft/ft_lstclear.c
TESTS/execution_test/libft/libft/ft_lstdel_first_el.c
TESTS/execution_test/libft/libft/ft_lstdel_last_el.c
TESTS/execution_test/libft/libft/ft_lstdelone.c
TESTS/execution_test/libft/libft/ft_lstiter.c
TESTS/execution_test/libft/libft/ft_lstlast.c
TESTS/execution_test/libft/libft/ft_lstmap.c
TESTS/execution_test/libft/libft/ft_lstnew.c
TESTS/execution_test/libft/libft/ft_lstsize.c
TESTS/execution_test/libft/libft/ft_memchr.c
TESTS/execution_test/libft/libft/ft_memcmp.c
TESTS/execution_test/libft/libft/ft_memcpy.c
TESTS/execution_test/libft/libft/ft_memmove.c
TESTS/execution_test/libft/libft/ft_memset.c
TESTS/execution_test/libft/libft/ft_putchar_fd.c
TESTS/execution_test/libft/libft/ft_putendl_fd.c
TESTS/execution_test/libft/libft/ft_putnbr_fd.c
TESTS/execution_test/libft/libft/ft_putstr_fd.c
TESTS/execution_test/libft/libft/ft_split.c
TESTS/execution_test/libft/libft/ft_strchr.c
TESTS/execution_test/libft/libft/ft_strcpy.c
TESTS/execution_test/libft/libft/ft_strcspn.c
TESTS/execution_test/libft/libft/ft_strdup.c
TESTS/execution_test/libft/libft/ft_striteri.c
TESTS/execution_test/libft/libft/ft_strjoin.c
TESTS/execution_test/libft/libft/ft_strlcat.c
TESTS/execution_test/libft/libft/ft_strlcpy.c
TESTS/execution_test/libft/libft/ft_strlen.c
TESTS/execution_test/libft/libft/ft_strmapi.c
TESTS/execution_test/libft/libft/ft_strncmp.c
TESTS/execution_test/libft/libft/ft_strncpy.c
TESTS/execution_test/libft/libft/ft_strnstr.c
TESTS/execution_test/libft/libft/ft_strpbrk.c
TESTS/execution_test/libft/libft/ft_strrchr.c
TESTS/execution_test/libft/libft/ft_strspn.c
TESTS/execution_test/libft/libft/ft_strtrim.c
TESTS/execution_test/libft/libft/ft_substr.c
TESTS/execution_test/libft/libft/ft_tolower.c
TESTS/execution_test/libft/libft/ft_toupper.c
TESTS/execution_test/libft/libft/power.c
TESTS/execution_test/libft/libft/str_lowercase.c
TESTS/execution_test/main.c
TESTS/execution_test/malloc_error_print_message.c
TESTS/execution_test/minishell.h
TESTS/execution_test/parsing.c
TESTS/execution_test/parsing_expansion.c
TESTS/execution_test/parsing_expansion_dollar_conditions.c
TESTS/execution_test/parsing_expansion_expand_var_helper.c
TESTS/execution_test/parsing_expansion_helper.c
TESTS/execution_test/parsing_expansion_join_tokens.c
TESTS/execution_test/parsing_expansion_looping.c
TESTS/execution_test/parsing_expansion_trim_dollar.c
TESTS/execution_test/parsing_quote_removing.c
TESTS/execution_test/parsing_syntax_errors.c
TESTS/execution_test/parsing_syntax_errors_print_message.c
TESTS/execution_test/parsing_token_extraction.c
TESTS/execution_test/sans_readline_main.c
TESTS/execution_test/token_routine.c
TESTS/execution_test/token_routine_delete.c
TESTS/execution_test/token_routine_set_id.c
TESTS/expansion_test/copy_env_tab.c
TESTS/expansion_test/envp_routine.c
TESTS/expansion_test/is_dollar.c
TESTS/expansion_test/is_operator.c
TESTS/expansion_test/is_question.c
TESTS/expansion_test/is_quote.c
TESTS/expansion_test/is_token.c
TESTS/expansion_test/is_white_space.c
TESTS/expansion_test/libft/ft_printf/ft_count_int.c
TESTS/expansion_test/libft/ft_printf/ft_count_unsigned_int.c
TESTS/expansion_test/libft/ft_printf/ft_dprintf.c
TESTS/expansion_test/libft/ft_printf/ft_printf.c
TESTS/expansion_test/libft/ft_printf/ft_printf_address.c
TESTS/expansion_test/libft/ft_printf/ft_printf_char.c
TESTS/expansion_test/libft/ft_printf/ft_printf_hexa.c
TESTS/expansion_test/libft/ft_printf/ft_printf_int.c
TESTS/expansion_test/libft/ft_printf/ft_printf_str.c
TESTS/expansion_test/libft/ft_printf/ft_printf_unsint.c
TESTS/expansion_test/libft/ft_printf/ft_put_hexanbr_fd.c
TESTS/expansion_test/libft/ft_printf/ft_put_int.c
TESTS/expansion_test/libft/ft_printf/ft_put_unsnbr_fd.c
TESTS/expansion_test/libft/get_next_line/get_next_line.c
TESTS/expansion_test/libft/get_next_line/get_next_line_bonus.c
TESTS/expansion_test/libft/get_next_line/get_next_line_utils.c
TESTS/expansion_test/libft/includes/ft_printf.h
TESTS/expansion_test/libft/includes/get_next_line.h
TESTS/expansion_test/libft/includes/libft.h
TESTS/expansion_test/libft/libft/del.c
TESTS/expansion_test/libft/libft/ft_atoi.c
TESTS/expansion_test/libft/libft/ft_atoi_base.c
TESTS/expansion_test/libft/libft/ft_bzero.c
TESTS/expansion_test/libft/libft/ft_calloc.c
TESTS/expansion_test/libft/libft/ft_isalnum.c
TESTS/expansion_test/libft/libft/ft_isalpha.c
TESTS/expansion_test/libft/libft/ft_isascii.c
TESTS/expansion_test/libft/libft/ft_isdigit.c
TESTS/expansion_test/libft/libft/ft_isprint.c
TESTS/expansion_test/libft/libft/ft_itoa.c
TESTS/expansion_test/libft/libft/ft_lstadd_back.c
TESTS/expansion_test/libft/libft/ft_lstadd_front.c
TESTS/expansion_test/libft/libft/ft_lstclear.c
TESTS/expansion_test/libft/libft/ft_lstdel_first_el.c
TESTS/expansion_test/libft/libft/ft_lstdel_last_el.c
TESTS/expansion_test/libft/libft/ft_lstdelone.c
TESTS/expansion_test/libft/libft/ft_lstiter.c
TESTS/expansion_test/libft/libft/ft_lstlast.c
TESTS/expansion_test/libft/libft/ft_lstmap.c
TESTS/expansion_test/libft/libft/ft_lstnew.c
TESTS/expansion_test/libft/libft/ft_lstsize.c
TESTS/expansion_test/libft/libft/ft_memchr.c
TESTS/expansion_test/libft/libft/ft_memcmp.c
TESTS/expansion_test/libft/libft/ft_memcpy.c
TESTS/expansion_test/libft/libft/ft_memmove.c
TESTS/expansion_test/libft/libft/ft_memset.c
TESTS/expansion_test/libft/libft/ft_putchar_fd.c
TESTS/expansion_test/libft/libft/ft_putendl_fd.c
TESTS/expansion_test/libft/libft/ft_putnbr_fd.c
TESTS/expansion_test/libft/libft/ft_putstr_fd.c
TESTS/expansion_test/libft/libft/ft_split.c
TESTS/expansion_test/libft/libft/ft_strchr.c
TESTS/expansion_test/libft/libft/ft_strcpy.c
TESTS/expansion_test/libft/libft/ft_strcspn.c
TESTS/expansion_test/libft/libft/ft_strdup.c
TESTS/expansion_test/libft/libft/ft_striteri.c
TESTS/expansion_test/libft/libft/ft_strjoin.c
TESTS/expansion_test/libft/libft/ft_strlcat.c
TESTS/expansion_test/libft/libft/ft_strlcpy.c
TESTS/expansion_test/libft/libft/ft_strlen.c
TESTS/expansion_test/libft/libft/ft_strmapi.c
TESTS/expansion_test/libft/libft/ft_strncmp.c
TESTS/expansion_test/libft/libft/ft_strncpy.c
TESTS/expansion_test/libft/libft/ft_strnstr.c
TESTS/expansion_test/libft/libft/ft_strpbrk.c
TESTS/expansion_test/libft/libft/ft_strrchr.c
TESTS/expansion_test/libft/libft/ft_strspn.c
TESTS/expansion_test/libft/libft/ft_strtrim.c
TESTS/expansion_test/libft/libft/ft_substr.c
TESTS/expansion_test/libft/libft/ft_tolower.c
TESTS/expansion_test/libft/libft/ft_toupper.c
TESTS/expansion_test/libft/libft/power.c
TESTS/expansion_test/libft/libft/str_lowercase.c
TESTS/expansion_test/main.c
TESTS/expansion_test/malloc_error_print_message.c
TESTS/expansion_test/minishell.h
TESTS/expansion_test/parsing.c
TESTS/expansion_test/parsing_expansion.c
TESTS/expansion_test/parsing_expansion_dollar_conditions.c
TESTS/expansion_test/parsing_expansion_expand_var_helper.c
TESTS/expansion_test/parsing_expansion_helper.c
TESTS/expansion_test/parsing_expansion_join_tokens.c
TESTS/expansion_test/parsing_expansion_looping.c
TESTS/expansion_test/parsing_expansion_trim_dollar.c
TESTS/expansion_test/parsing_quote_removing.c
TESTS/expansion_test/parsing_syntax_errors.c
TESTS/expansion_test/parsing_syntax_errors_print_message.c
TESTS/expansion_test/parsing_token_extraction.c
TESTS/expansion_test/token_routine.c
TESTS/expansion_test/token_routine_delete.c
TESTS/expansion_test/token_routine_set_id.c
TESTS/parsing tests/main_parsing_syntax_errors.c
TESTS/parsing tests/main_parsing_token_extraction.c
TESTS/parsing tests/main_token_routine.c
TESTS/test_getenv.c
TESTS/test_tgetent.c
builtins/cd.c
builtins/echo.c
builtins/env.c
builtins/exit.c
builtins/export.c
builtins/export_unset_helper.c
builtins/pwd.c
builtins/unset.c
command_struct/free_cmd.c
command_struct/init_cmd.c
command_struct/init_cmd_cmd.c
command_struct/init_cmd_redir.c
environnement/envp_routine.c
environnement/get_env.c
execution/copy_env_tab.c
execution/exec_bin.c
execution/exec_builtins.c
execution/exec_one_cmd.c
execution/execution.c
execution/get_path.c
execution/pipex.c
execution/search_path_in_env_table.c
global_variable/init_global.c
is_smth/is_dollar.c
is_smth/is_numeric.c
is_smth/is_operator.c
is_smth/is_question.c
is_smth/is_quote.c
is_smth/is_token.c
is_smth/is_white_space.c
libft/ft_printf/ft_count_int.c
libft/ft_printf/ft_count_unsigned_int.c
libft/ft_printf/ft_dprintf.c
libft/ft_printf/ft_printf.c
libft/ft_printf/ft_printf_address.c
libft/ft_printf/ft_printf_char.c
libft/ft_printf/ft_printf_hexa.c
libft/ft_printf/ft_printf_int.c
libft/ft_printf/ft_printf_str.c
libft/ft_printf/ft_printf_unsint.c
libft/ft_printf/ft_put_hexanbr_fd.c
libft/ft_printf/ft_put_int.c
libft/ft_printf/ft_put_unsnbr_fd.c
libft/get_next_line/get_next_line.c
libft/get_next_line/get_next_line_bonus.c
libft/get_next_line/get_next_line_utils.c
libft/includes/ft_printf.h
libft/includes/get_next_line.h
libft/includes/libft.h
libft/libft/del.c
libft/libft/ft_atoi.c
libft/libft/ft_atoi_base.c
libft/libft/ft_bzero.c
libft/libft/ft_calloc.c
libft/libft/ft_isalnum.c
libft/libft/ft_isalpha.c
libft/libft/ft_isascii.c
libft/libft/ft_isdigit.c
libft/libft/ft_isprint.c
libft/libft/ft_itoa.c
libft/libft/ft_lstadd_back.c
libft/libft/ft_lstadd_front.c
libft/libft/ft_lstclear.c
libft/libft/ft_lstdel_first_el.c
libft/libft/ft_lstdel_last_el.c
libft/libft/ft_lstdelone.c
libft/libft/ft_lstiter.c
libft/libft/ft_lstlast.c
libft/libft/ft_lstmap.c
libft/libft/ft_lstnew.c
libft/libft/ft_lstsize.c
libft/libft/ft_memchr.c
libft/libft/ft_memcmp.c
libft/libft/ft_memcpy.c
libft/libft/ft_memmove.c
libft/libft/ft_memset.c
libft/libft/ft_putchar_fd.c
libft/libft/ft_putendl_fd.c
libft/libft/ft_putnbr_fd.c
libft/libft/ft_putstr_fd.c
libft/libft/ft_split.c
libft/libft/ft_strchr.c
libft/libft/ft_strcpy.c
libft/libft/ft_strcspn.c
libft/libft/ft_strdup.c
libft/libft/ft_striteri.c
libft/libft/ft_strjoin.c
libft/libft/ft_strlcat.c
libft/libft/ft_strlcpy.c
libft/libft/ft_strlen.c
libft/libft/ft_strmapi.c
libft/libft/ft_strncmp.c
libft/libft/ft_strncpy.c
libft/libft/ft_strnstr.c
libft/libft/ft_strpbrk.c
libft/libft/ft_strrchr.c
libft/libft/ft_strspn.c
libft/libft/ft_strtrim.c
libft/libft/ft_substr.c
libft/libft/ft_tolower.c
libft/libft/ft_toupper.c
libft/libft/power.c
libft/libft/str_lowercase.c
main.c
malloc_error/malloc_error_print_message.c
minishell.h
parsing/expansion.c
parsing/expansion_dollar_conditions.c
parsing/expansion_expand_var_helper.c
parsing/expansion_helper.c
parsing/expansion_join_tokens.c
parsing/expansion_looping.c
parsing/expansion_trim_dollar.c
parsing/parsing.c
parsing/quote_removing.c
parsing/syntax_errors.c
parsing/syntax_errors_print_message.c
parsing/token_extraction.c
redirections/double_chevron.c
redirections/make_redirection.c
redirections/single_chevron.c
sauvegarde/builtins.c
sauvegarde/cmd_is_bin.c
sauvegarde/cmd_is_builtin.c
sauvegarde/complicated_split.c
sauvegarde/copy_env_tab.c
sauvegarde/environnement/envp_routine.c
sauvegarde/execution.c
sauvegarde/execution_test/cmd_is_bin.c
sauvegarde/execution_test/copy_env_tab.c
sauvegarde/execution_test/envp_routine.c
sauvegarde/execution_test/execution.c
sauvegarde/execution_test/handler_ctr_c.c
sauvegarde/execution_test/is_dollar.c
sauvegarde/execution_test/is_operator.c
sauvegarde/execution_test/is_question.c
sauvegarde/execution_test/is_quote.c
sauvegarde/execution_test/is_token.c
sauvegarde/execution_test/is_white_space.c
sauvegarde/execution_test/launch_setup.c
sauvegarde/execution_test/libft/ft_printf/ft_count_int.c
sauvegarde/execution_test/libft/ft_printf/ft_count_unsigned_int.c
sauvegarde/execution_test/libft/ft_printf/ft_dprintf.c
sauvegarde/execution_test/libft/ft_printf/ft_printf.c
sauvegarde/execution_test/libft/ft_printf/ft_printf_address.c
sauvegarde/execution_test/libft/ft_printf/ft_printf_char.c
sauvegarde/execution_test/libft/ft_printf/ft_printf_hexa.c
sauvegarde/execution_test/libft/ft_printf/ft_printf_int.c
sauvegarde/execution_test/libft/ft_printf/ft_printf_str.c
sauvegarde/execution_test/libft/ft_printf/ft_printf_unsint.c
sauvegarde/execution_test/libft/ft_printf/ft_put_hexanbr_fd.c
sauvegarde/execution_test/libft/ft_printf/ft_put_int.c
sauvegarde/execution_test/libft/ft_printf/ft_put_unsnbr_fd.c
sauvegarde/execution_test/libft/get_next_line/get_next_line.c
sauvegarde/execution_test/libft/get_next_line/get_next_line_bonus.c
sauvegarde/execution_test/libft/get_next_line/get_next_line_utils.c
sauvegarde/execution_test/libft/includes/ft_printf.h
sauvegarde/execution_test/libft/includes/get_next_line.h
sauvegarde/execution_test/libft/includes/libft.h
sauvegarde/execution_test/libft/libft/del.c
sauvegarde/execution_test/libft/libft/ft_atoi.c
sauvegarde/execution_test/libft/libft/ft_atoi_base.c
sauvegarde/execution_test/libft/libft/ft_bzero.c
sauvegarde/execution_test/libft/libft/ft_calloc.c
sauvegarde/execution_test/libft/libft/ft_isalnum.c
sauvegarde/execution_test/libft/libft/ft_isalpha.c
sauvegarde/execution_test/libft/libft/ft_isascii.c
sauvegarde/execution_test/libft/libft/ft_isdigit.c
sauvegarde/execution_test/libft/libft/ft_isprint.c
sauvegarde/execution_test/libft/libft/ft_itoa.c
sauvegarde/execution_test/libft/libft/ft_lstadd_back.c
sauvegarde/execution_test/libft/libft/ft_lstadd_front.c
sauvegarde/execution_test/libft/libft/ft_lstclear.c
sauvegarde/execution_test/libft/libft/ft_lstdel_first_el.c
sauvegarde/execution_test/libft/libft/ft_lstdel_last_el.c
sauvegarde/execution_test/libft/libft/ft_lstdelone.c
sauvegarde/execution_test/libft/libft/ft_lstiter.c
sauvegarde/execution_test/libft/libft/ft_lstlast.c
sauvegarde/execution_test/libft/libft/ft_lstmap.c
sauvegarde/execution_test/libft/libft/ft_lstnew.c
sauvegarde/execution_test/libft/libft/ft_lstsize.c
sauvegarde/execution_test/libft/libft/ft_memchr.c
sauvegarde/execution_test/libft/libft/ft_memcmp.c
sauvegarde/execution_test/libft/libft/ft_memcpy.c
sauvegarde/execution_test/libft/libft/ft_memmove.c
sauvegarde/execution_test/libft/libft/ft_memset.c
sauvegarde/execution_test/libft/libft/ft_putchar_fd.c
sauvegarde/execution_test/libft/libft/ft_putendl_fd.c
sauvegarde/execution_test/libft/libft/ft_putnbr_fd.c
sauvegarde/execution_test/libft/libft/ft_putstr_fd.c
sauvegarde/execution_test/libft/libft/ft_split.c
sauvegarde/execution_test/libft/libft/ft_strchr.c
sauvegarde/execution_test/libft/libft/ft_strcpy.c
sauvegarde/execution_test/libft/libft/ft_strcspn.c
sauvegarde/execution_test/libft/libft/ft_strdup.c
sauvegarde/execution_test/libft/libft/ft_striteri.c
sauvegarde/execution_test/libft/libft/ft_strjoin.c
sauvegarde/execution_test/libft/libft/ft_strlcat.c
sauvegarde/execution_test/libft/libft/ft_strlcpy.c
sauvegarde/execution_test/libft/libft/ft_strlen.c
sauvegarde/execution_test/libft/libft/ft_strmapi.c
sauvegarde/execution_test/libft/libft/ft_strncmp.c
sauvegarde/execution_test/libft/libft/ft_strncpy.c
sauvegarde/execution_test/libft/libft/ft_strnstr.c
sauvegarde/execution_test/libft/libft/ft_strpbrk.c
sauvegarde/execution_test/libft/libft/ft_strrchr.c
sauvegarde/execution_test/libft/libft/ft_strspn.c
sauvegarde/execution_test/libft/libft/ft_strtrim.c
sauvegarde/execution_test/libft/libft/ft_substr.c
sauvegarde/execution_test/libft/libft/ft_tolower.c
sauvegarde/execution_test/libft/libft/ft_toupper.c
sauvegarde/execution_test/libft/libft/power.c
sauvegarde/execution_test/libft/libft/str_lowercase.c
sauvegarde/execution_test/main.c
sauvegarde/execution_test/malloc_error_print_message.c
sauvegarde/execution_test/minishell.h
sauvegarde/execution_test/parsing.c
sauvegarde/execution_test/parsing_expansion.c
sauvegarde/execution_test/parsing_expansion_dollar_conditions.c
sauvegarde/execution_test/parsing_expansion_expand_var_helper.c
sauvegarde/execution_test/parsing_expansion_helper.c
sauvegarde/execution_test/parsing_expansion_join_tokens.c
sauvegarde/execution_test/parsing_expansion_looping.c
sauvegarde/execution_test/parsing_expansion_trim_dollar.c
sauvegarde/execution_test/parsing_quote_removing.c
sauvegarde/execution_test/parsing_syntax_errors.c
sauvegarde/execution_test/parsing_syntax_errors_print_message.c
sauvegarde/execution_test/parsing_token_extraction.c
sauvegarde/execution_test/sans_readline_main.c
sauvegarde/execution_test/token_routine.c
sauvegarde/execution_test/token_routine_delete.c
sauvegarde/execution_test/token_routine_set_id.c
sauvegarde/free_cmd.c
sauvegarde/global_variable/init_global.c
sauvegarde/handler_ctr_c.c
sauvegarde/init_cmd.c
sauvegarde/init_cmd_cmd.c
sauvegarde/is_smth/is_dollar.c
sauvegarde/is_smth/is_operator.c
sauvegarde/is_smth/is_question.c
sauvegarde/is_smth/is_quote.c
sauvegarde/is_smth/is_token.c
sauvegarde/is_smth/is_white_space.c
sauvegarde/launch_setup.c
sauvegarde/libft/ft_printf/ft_count_int.c
sauvegarde/libft/ft_printf/ft_count_unsigned_int.c
sauvegarde/libft/ft_printf/ft_dprintf.c
sauvegarde/libft/ft_printf/ft_printf.c
sauvegarde/libft/ft_printf/ft_printf_address.c
sauvegarde/libft/ft_printf/ft_printf_char.c
sauvegarde/libft/ft_printf/ft_printf_hexa.c
sauvegarde/libft/ft_printf/ft_printf_int.c
sauvegarde/libft/ft_printf/ft_printf_str.c
sauvegarde/libft/ft_printf/ft_printf_unsint.c
sauvegarde/libft/ft_printf/ft_put_hexanbr_fd.c
sauvegarde/libft/ft_printf/ft_put_int.c
sauvegarde/libft/ft_printf/ft_put_unsnbr_fd.c
sauvegarde/libft/get_next_line/get_next_line.c
sauvegarde/libft/get_next_line/get_next_line_bonus.c
sauvegarde/libft/get_next_line/get_next_line_utils.c
sauvegarde/libft/includes/ft_printf.h
sauvegarde/libft/includes/get_next_line.h
sauvegarde/libft/includes/libft.h
sauvegarde/libft/libft/del.c
sauvegarde/libft/libft/ft_atoi.c
sauvegarde/libft/libft/ft_atoi_base.c
sauvegarde/libft/libft/ft_bzero.c
sauvegarde/libft/libft/ft_calloc.c
sauvegarde/libft/libft/ft_isalnum.c
sauvegarde/libft/libft/ft_isalpha.c
sauvegarde/libft/libft/ft_isascii.c
sauvegarde/libft/libft/ft_isdigit.c
sauvegarde/libft/libft/ft_isprint.c
sauvegarde/libft/libft/ft_itoa.c
sauvegarde/libft/libft/ft_lstadd_back.c
sauvegarde/libft/libft/ft_lstadd_front.c
sauvegarde/libft/libft/ft_lstclear.c
sauvegarde/libft/libft/ft_lstdel_first_el.c
sauvegarde/libft/libft/ft_lstdel_last_el.c
sauvegarde/libft/libft/ft_lstdelone.c
sauvegarde/libft/libft/ft_lstiter.c
sauvegarde/libft/libft/ft_lstlast.c
sauvegarde/libft/libft/ft_lstmap.c
sauvegarde/libft/libft/ft_lstnew.c
sauvegarde/libft/libft/ft_lstsize.c
sauvegarde/libft/libft/ft_memchr.c
sauvegarde/libft/libft/ft_memcmp.c
sauvegarde/libft/libft/ft_memcpy.c
sauvegarde/libft/libft/ft_memmove.c
sauvegarde/libft/libft/ft_memset.c
sauvegarde/libft/libft/ft_putchar_fd.c
sauvegarde/libft/libft/ft_putendl_fd.c
sauvegarde/libft/libft/ft_putnbr_fd.c
sauvegarde/libft/libft/ft_putstr_fd.c
sauvegarde/libft/libft/ft_split.c
sauvegarde/libft/libft/ft_strchr.c
sauvegarde/libft/libft/ft_strcpy.c
sauvegarde/libft/libft/ft_strcspn.c
sauvegarde/libft/libft/ft_strdup.c
sauvegarde/libft/libft/ft_striteri.c
sauvegarde/libft/libft/ft_strjoin.c
sauvegarde/libft/libft/ft_strlcat.c
sauvegarde/libft/libft/ft_strlcpy.c
sauvegarde/libft/libft/ft_strlen.c
sauvegarde/libft/libft/ft_strmapi.c
sauvegarde/libft/libft/ft_strncmp.c
sauvegarde/libft/libft/ft_strncpy.c
sauvegarde/libft/libft/ft_strnstr.c
sauvegarde/libft/libft/ft_strpbrk.c
sauvegarde/libft/libft/ft_strrchr.c
sauvegarde/libft/libft/ft_strspn.c
sauvegarde/libft/libft/ft_strtrim.c
sauvegarde/libft/libft/ft_substr.c
sauvegarde/libft/libft/ft_tolower.c
sauvegarde/libft/libft/ft_toupper.c
sauvegarde/libft/libft/power.c
sauvegarde/libft/libft/str_lowercase.c
sauvegarde/main.c
sauvegarde/malloc_error_print_message.c
sauvegarde/minishell.h
sauvegarde/parsing/expansion.c
sauvegarde/parsing/expansion_dollar_conditions.c
sauvegarde/parsing/expansion_expand_var_helper.c
sauvegarde/parsing/expansion_helper.c
sauvegarde/parsing/expansion_join_tokens.c
sauvegarde/parsing/expansion_looping.c
sauvegarde/parsing/expansion_test/copy_env_tab.c
sauvegarde/parsing/expansion_test/envp_routine.c
sauvegarde/parsing/expansion_test/is_dollar.c
sauvegarde/parsing/expansion_test/is_operator.c
sauvegarde/parsing/expansion_test/is_question.c
sauvegarde/parsing/expansion_test/is_quote.c
sauvegarde/parsing/expansion_test/is_token.c
sauvegarde/parsing/expansion_test/is_white_space.c
sauvegarde/parsing/expansion_test/libft/ft_printf/ft_count_int.c
sauvegarde/parsing/expansion_test/libft/ft_printf/ft_count_unsigned_int.c
sauvegarde/parsing/expansion_test/libft/ft_printf/ft_dprintf.c
sauvegarde/parsing/expansion_test/libft/ft_printf/ft_printf.c
sauvegarde/parsing/expansion_test/libft/ft_printf/ft_printf_address.c
sauvegarde/parsing/expansion_test/libft/ft_printf/ft_printf_char.c
sauvegarde/parsing/expansion_test/libft/ft_printf/ft_printf_hexa.c
sauvegarde/parsing/expansion_test/libft/ft_printf/ft_printf_int.c
sauvegarde/parsing/expansion_test/libft/ft_printf/ft_printf_str.c
sauvegarde/parsing/expansion_test/libft/ft_printf/ft_printf_unsint.c
sauvegarde/parsing/expansion_test/libft/ft_printf/ft_put_hexanbr_fd.c
sauvegarde/parsing/expansion_test/libft/ft_printf/ft_put_int.c
sauvegarde/parsing/expansion_test/libft/ft_printf/ft_put_unsnbr_fd.c
sauvegarde/parsing/expansion_test/libft/get_next_line/get_next_line.c
sauvegarde/parsing/expansion_test/libft/get_next_line/get_next_line_bonus.c
sauvegarde/parsing/expansion_test/libft/get_next_line/get_next_line_utils.c
sauvegarde/parsing/expansion_test/libft/includes/ft_printf.h
sauvegarde/parsing/expansion_test/libft/includes/get_next_line.h
sauvegarde/parsing/expansion_test/libft/includes/libft.h
sauvegarde/parsing/expansion_test/libft/libft/del.c
sauvegarde/parsing/expansion_test/libft/libft/ft_atoi.c
sauvegarde/parsing/expansion_test/libft/libft/ft_atoi_base.c
sauvegarde/parsing/expansion_test/libft/libft/ft_bzero.c
sauvegarde/parsing/expansion_test/libft/libft/ft_calloc.c
sauvegarde/parsing/expansion_test/libft/libft/ft_isalnum.c
sauvegarde/parsing/expansion_test/libft/libft/ft_isalpha.c
sauvegarde/parsing/expansion_test/libft/libft/ft_isascii.c
sauvegarde/parsing/expansion_test/libft/libft/ft_isdigit.c
sauvegarde/parsing/expansion_test/libft/libft/ft_isprint.c
sauvegarde/parsing/expansion_test/libft/libft/ft_itoa.c
sauvegarde/parsing/expansion_test/libft/libft/ft_lstadd_back.c
sauvegarde/parsing/expansion_test/libft/libft/ft_lstadd_front.c
sauvegarde/parsing/expansion_test/libft/libft/ft_lstclear.c
sauvegarde/parsing/expansion_test/libft/libft/ft_lstdel_first_el.c
sauvegarde/parsing/expansion_test/libft/libft/ft_lstdel_last_el.c
sauvegarde/parsing/expansion_test/libft/libft/ft_lstdelone.c
sauvegarde/parsing/expansion_test/libft/libft/ft_lstiter.c
sauvegarde/parsing/expansion_test/libft/libft/ft_lstlast.c
sauvegarde/parsing/expansion_test/libft/libft/ft_lstmap.c
sauvegarde/parsing/expansion_test/libft/libft/ft_lstnew.c
sauvegarde/parsing/expansion_test/libft/libft/ft_lstsize.c
sauvegarde/parsing/expansion_test/libft/libft/ft_memchr.c
sauvegarde/parsing/expansion_test/libft/libft/ft_memcmp.c
sauvegarde/parsing/expansion_test/libft/libft/ft_memcpy.c
sauvegarde/parsing/expansion_test/libft/libft/ft_memmove.c
sauvegarde/parsing/expansion_test/libft/libft/ft_memset.c
sauvegarde/parsing/expansion_test/libft/libft/ft_putchar_fd.c
sauvegarde/parsing/expansion_test/libft/libft/ft_putendl_fd.c
sauvegarde/parsing/expansion_test/libft/libft/ft_putnbr_fd.c
sauvegarde/parsing/expansion_test/libft/libft/ft_putstr_fd.c
sauvegarde/parsing/expansion_test/libft/libft/ft_split.c
sauvegarde/parsing/expansion_test/libft/libft/ft_strchr.c
sauvegarde/parsing/expansion_test/libft/libft/ft_strcpy.c
sauvegarde/parsing/expansion_test/libft/libft/ft_strcspn.c
sauvegarde/parsing/expansion_test/libft/libft/ft_strdup.c
sauvegarde/parsing/expansion_test/libft/libft/ft_striteri.c
sauvegarde/parsing/expansion_test/libft/libft/ft_strjoin.c
sauvegarde/parsing/expansion_test/libft/libft/ft_strlcat.c
sauvegarde/parsing/expansion_test/libft/libft/ft_strlcpy.c
sauvegarde/parsing/expansion_test/libft/libft/ft_strlen.c
sauvegarde/parsing/expansion_test/libft/libft/ft_strmapi.c
sauvegarde/parsing/expansion_test/libft/libft/ft_strncmp.c
sauvegarde/parsing/expansion_test/libft/libft/ft_strncpy.c
sauvegarde/parsing/expansion_test/libft/libft/ft_strnstr.c
sauvegarde/parsing/expansion_test/libft/libft/ft_strpbrk.c
sauvegarde/parsing/expansion_test/libft/libft/ft_strrchr.c
sauvegarde/parsing/expansion_test/libft/libft/ft_strspn.c
sauvegarde/parsing/expansion_test/libft/libft/ft_strtrim.c
sauvegarde/parsing/expansion_test/libft/libft/ft_substr.c
sauvegarde/parsing/expansion_test/libft/libft/ft_tolower.c
sauvegarde/parsing/expansion_test/libft/libft/ft_toupper.c
sauvegarde/parsing/expansion_test/libft/libft/power.c
sauvegarde/parsing/expansion_test/libft/libft/str_lowercase.c
sauvegarde/parsing/expansion_test/main.c
sauvegarde/parsing/expansion_test/malloc_error_print_message.c
sauvegarde/parsing/expansion_test/minishell.h
sauvegarde/parsing/expansion_test/parsing.c
sauvegarde/parsing/expansion_test/parsing_expansion.c
sauvegarde/parsing/expansion_test/parsing_expansion_dollar_conditions.c
sauvegarde/parsing/expansion_test/parsing_expansion_expand_var_helper.c
sauvegarde/parsing/expansion_test/parsing_expansion_helper.c
sauvegarde/parsing/expansion_test/parsing_expansion_join_tokens.c
sauvegarde/parsing/expansion_test/parsing_expansion_looping.c
sauvegarde/parsing/expansion_test/parsing_expansion_trim_dollar.c
sauvegarde/parsing/expansion_test/parsing_quote_removing.c
sauvegarde/parsing/expansion_test/parsing_syntax_errors.c
sauvegarde/parsing/expansion_test/parsing_syntax_errors_print_message.c
sauvegarde/parsing/expansion_test/parsing_token_extraction.c
sauvegarde/parsing/expansion_test/token_routine.c
sauvegarde/parsing/expansion_test/token_routine_delete.c
sauvegarde/parsing/expansion_test/token_routine_set_id.c
sauvegarde/parsing/expansion_trim_dollar.c
sauvegarde/parsing/parsing.c
sauvegarde/parsing/quote_removing.c
sauvegarde/parsing/syntax_errors.c
sauvegarde/parsing/syntax_errors_print_message.c
sauvegarde/parsing/tests/main_parsing_syntax_errors.c
sauvegarde/parsing/tests/main_parsing_token_extraction.c
sauvegarde/parsing/tests/main_token_routine.c
sauvegarde/parsing/token_extraction.c
sauvegarde/test_getenv.c
sauvegarde/test_tgetent.c
sauvegarde/tokens/token_routine.c
sauvegarde/tokens/token_routine_delete.c
sauvegarde/tokens/token_routine_set_id.c
signal_handler/child_sig_handler.c
signal_handler/parent_sig_handler.c
test.c
tokens/token_routine.c
tokens/token_routine_delete.c
tokens/token_routine_set_id.c
utils.c
