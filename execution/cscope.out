cscope 15 $HOME/Documents/GitHub/minishell/rita2/execution -c -q 0000000082 0000007993
	@copy_env_tab.c

12 #include 
	~"minishell.h
"

14 int 
	$column_size
(
t_env
 **
head
)

16 
t_env
 *
tmp
;

17 int 
count
;

19 
tmp
 = *
head
;

20 
count
 = 0;

21 while (
tmp
)

23 
count
++;

24 
tmp
 = tmp->
next
;

26 return (
count
);

27 
	}
}

29 char *
	$name_plus_value
(char *
name
, char *
value
)

31 char *
joined
;

32 int 
len_name
;

33 int 
len_value
;

34 int 
i
;

35 int 
j
;

37 
i
 = 0;

38 
j
 = 0;

39 
len_name
 = 
	`ft_strlen
(
name
);

40 if (
value
)

41 
len_value
 = 
	`ft_strlen
(
value
);

43 
len_value
 = 0;

44 
joined
 = 
	`malloc
(sizeof(char) * (
len_name
 + 
len_value
 + 2));

45 if (!
joined
)

47 
	`malloc_error_print_message
(
	`strerror
(
errno
));

48 return (
NULL
);

50 while (
i
 < 
len_name
)

51 
joined
[
i
++] = 
name
[
j
++];

52 
joined
[
i
] = '=';

53 
j
 = 0;

54 
i
++;

55 while (
j
 < 
len_value
)

56 
joined
[
i
++] = 
value
[
j
++];

57 
joined
[
i
] = '\0';

58 return (
joined
);

59 
	}
}

61 int 
	$copy_env_tab
(void)

63 int 
column
;

64 int 
i
;

65 
t_env
 *
env
;

67 
env
 = 
g_shell
->env;

68 
i
 = 0;

69 
column
 = 
	`column_size
(&
env
);

70 if (
column
 == 0)

72 
g_shell
->
save_env
 = 
	`malloc
(sizeof(char *) * (
column
 + 1));

73 if (!
g_shell
->
save_env
)

75 
	`malloc_error_print_message
(
	`strerror
(
errno
));

78 while (
env
)

80 
g_shell
->
save_env
[
i
] = 
	`name_plus_value
(
env
->
var_name
, env->
var_value
);

81 if (!
g_shell
->
save_env
[
i
])

83 
i
++;

84 
env
 = env->
next
;

86 
g_shell
->
save_env
[
i
] = 
NULL
;

88 
	}
}

	@exec_bin.c

12 #include 
	~"minishell.h
"

14 static int 
	$check_access
(
t_cmd
 *
cmd
)

16 int 
res
;

18 if (!
cmd
->
path
)

20 
	`printf
("access error: \n");

21 
	`ft_dprintf
(2, "minishell: %s: command not found\n", 
cmd
->cmd[0]);

22 
g_shell
->
exit_status
 = 127;

23 
cmd
->
status
 = 127;

27 
res
 = 
	`access
(
cmd
->
path
, 
F_OK
 & 
X_OK
);

28 if (
res
)

30 
	`printf
("access error: \n");

31 
	`ft_dprintf
(2, "minishell: %s\n", 
	`strerror
(
errno
));

32 
g_shell
->
exit_status
 = 127;

33 
cmd
->
status
 = 127;

37 
	}
}

39 static void 
	$check_execve
(
t_cmd
 *
cmd
)

41 int 
res
;

43 if (!
cmd
->cmd[0])

45 
	`printf
("execve error: \n");

46 
	`ft_dprintf
(2, "minishell: %s: is a directory\n", 
cmd
->
path
);

47 
g_shell
->
exit_status
 = 126;

48 
cmd
->
status
 = 126;

51 
res
 = 
	`execve
(
cmd
->
path
, cmd->cmd, 
g_shell
->
save_env
);

52 if (
res
 < 0)

54 
	`printf
("execve error: \n");

55 
	`ft_dprintf
(2, "minishell: %s\n", 
	`strerror
(
errno
));

56 if (
errno
 == 
EACCES
)

58 
g_shell
->
exit_status
 = 126;

59 
cmd
->
status
 = 126;

62 
g_shell
->
exit_status
 = 127;

63 
cmd
->
status
 = 127;

66 
g_shell
->
exit_status
 = 0;

67 
cmd
->
status
 = 0;

68 
	}
}

70 void 
	$execute_bin
(
t_cmd
 *
cmd
)

72 int 
res
 = 0;

74 if (!
cmd
 || !cmd->cmd)

76 if (!
	`get_path
(
cmd
))

78 
	`printf
("path = %s\n", 
cmd
->
path
);

79 
	`printf
("cmd = %s\n", 
cmd
->cmd[0]);

80 
res
 = 
	`check_access
(
cmd
);

81 if (
res
)

82 
	`check_execve
(
cmd
);

84 
	}
}

	@exec_builtins.c

12 #include 
	~"minishell.h
"

14 int 
	$cmd_is_builtin
(char *
s
)

16 if (
s
)

18 if (
	`ft_strncmp
(
s
, "echo", 5) == 0)

20 else if (
	`ft_strncmp
(
s
, "cd", 3) == 0)

22 else if (
	`ft_strncmp
(
s
, "pwd", 4) == 0)

24 else if (
	`ft_strncmp
(
s
, "export", 7) == 0)

26 else if (
	`ft_strncmp
(
s
, "unset", 6) == 0)

28 else if (
	`ft_strncmp
(
s
, "env", 4) == 0)

30 else if (
	`ft_strncmp
(
s
, "exit", 5) == 0)

34 
	}
}

36 void 
	$execute_builtin
(
t_cmd
 *
cmd
, t_cmd **
head
)

38 if (
	`ft_strncmp
(
cmd
->cmd[0], "exit", 6) == 0)

39 
	`ft_exit
(&
cmd
);

40 else if (
	`ft_strncmp
(
cmd
->cmd[0], "pwd", 4) == 0)

41 
	`_pwd
();

42 else if (
	`ft_strncmp
(
cmd
->cmd[0], "echo", 5) == 0)

43 
	`_echo
(
cmd
);

44 else if (
	`ft_strncmp
(
cmd
->cmd[0], "env", 4) == 0)

45 
	`_env
(
cmd
, 
g_shell
->
env
);

46 else if (
	`ft_strncmp
(
cmd
->cmd[0], "cd", 3) == 0)

47 
	`_cd
(
cmd
, 
head
);

48 else if (
	`ft_strncmp
(
cmd
->cmd[0], "export", 7) == 0)

49 
	`_export
(
cmd
, 
head
);

50 else if (
	`ft_strncmp
(
cmd
->cmd[0], "unset", 6) == 0)

51 
	`_unset
(
cmd
);

53 
	}
}

	@exec_one_cmd.c

12 #include 
	~"minishell.h
"

14 static void 
	$execute_one_bin
(
t_cmd
 *
cmd
)

16 
cmd
->
pid
 = 
	`fork
();

17 if (
cmd
->
pid
 < 0)

18 return (
	`perror
("Fork: "));

19 if (
cmd
->
pid
 == 0)

21 
	`execute_bin
(
cmd
);

22 
	`exit
(
cmd
->
status
);

26 
	`waitpid
(
cmd
->
pid
, &cmd->
status
, 0);

27 
g_shell
->
exit_status
 = 
	`WEXITSTATUS
(
cmd
->
status
);

29 
	}
}

31 void 
	$one_cmd
(
t_cmd
 *
cmd
, t_cmd **
head
)

33 if (
	`cmd_is_builtin
(
cmd
->cmd[0]))

34 
	`execute_builtin
(
cmd
, 
head
);

36 
	`execute_one_bin
(
cmd
);

37 
	}
}

	@execution_utils.c

12 #include 
	~"minishell.h
"

14 int 
	$size_tab2d
(char **
s
)

16 int 
i
;

18 
i
 = 0;

19 while (
s
[
i
])

20 
i
++;

21 return (
i
);

22 
	}
}

	@get_path.c

12 #include 
	~"minishell.h
"

14 static int 
	$is_dir
(char *
path
, 
t_cmd
 *
cmd
)

16 struct 
stat
 
buf
;

18 if (
	`stat
(
path
, &
buf
) == 0)

20 if(
	`S_ISDIR
(
buf
.
st_mode
))

22 
cmd
->cmd[0] = 
NULL
;

27 
	}
}

29 static int 
	$extract_cmd_path
(char *
path
, 
t_cmd
 *
cmd
)

31 int 
start
;

32 int 
end
;

34 
start
 = 0;

35 
end
 = 0;

36 if (
	`is_dir
(
path
, 
cmd
))

38 while (
path
[
end
])

39 
end
++;

40 
start
 = 
end
--;

41 while (
path
[
start
] != '/')

42 
start
--;

43 
	`free
(
cmd
->cmd[0]);

44 
cmd
->cmd[0] = 
NULL
;

45 
cmd
->cmd[0] = 
	`ft_substr
(
path
, 
start
 + 1, 
end
 - start);

46 if (!
cmd
->cmd[0])

48 
	`malloc_error_print_message
("ft_substr failed");

52 
	}
}

54 int 
	$get_path
(
t_cmd
 *
cmd
)

56 if (
	`ft_strchr
(
cmd
->cmd[0], '/'))

58 
cmd
->
path
 = 
	`ft_strdup
(cmd->cmd[0]);

59 if (!
cmd
->
path
)

61 
	`malloc_error_print_message
("ft_strdup failed");

64 if (!
	`extract_cmd_path
(
cmd
->
path
, cmd))

68 if (!
	`search_path
(
cmd
, 
g_shell
->
save_env
))

72 
	}
}

	@search_path_in_env_table.c

12 #include 
	~"minishell.h
"

14 static void 
	$copy_path
(int 
start
, int 
end
, char *
s
, 
t_cmd
 *
cmd
)

16 int 
i
;

18 
i
 = 0;

19 while (
start
 < 
end
)

21 
cmd
->
path
[
i
] = 
s
[
start
];

22 
i
++;

23 
start
++;

25 
cmd
->
path
[
i
] = '/';

26 
i
++;

27 
start
 = 0;

28 while (
cmd
->cmd[0][
start
])

30 
cmd
->
path
[
i
] = cmd->cmd[0][
start
];

31 
i
++;

32 
start
++;

34 
cmd
->
path
[
i
] = '\0';

35 
	}
}

37 static int 
	$check_access
(int 
start
, int 
end
, char *
s
, 
t_cmd
 *
cmd
)

39 int 
size
;

41 
size
 = 
end
 - 
start
 + 
	`ft_strlen
(
cmd
->cmd[0]) + 2;

42 
cmd
->
path
 = 
	`malloc
(sizeof(char) * 
size
);

43 if (!
cmd
->
path
)

45 
	`malloc_error_print_message
("ft_substr failed");

46 
g_shell
->
exit_status
 = 1;

47 return (
ERROR_EXIT
);

49 
	`copy_path
(
start
, 
end
, 
s
, 
cmd
);

50 if (
	`access
(
cmd
->
path
, 
F_OK
 & 
X_OK
) == 0)

52 
	`free
(
cmd
->
path
);

53 
cmd
->
path
 = 
NULL
;

55 
	}
}

57 static int 
	$check_each_path
(char *
s
, 
t_cmd
 *
cmd
)

59 int 
i
;

60 int 
start
;

61 int 
res
;

63 
i
 = 0;

64 
start
 = 0;

65 while (
s
[
i
])

67 if (
s
[
i
] == ':')

69 
res
 = 
	`check_access
(
start
, 
i
, 
s
, 
cmd
);

70 if (
res
 == 1)

72 else if (
res
 == 
ERROR_EXIT
)

74 
start
 = 
i
 + 1;

76 
i
++;

78 
res
 = 
	`check_access
(
start
, 
i
, 
s
, 
cmd
);

79 if (
res
 == 1 || res == 0)

82 
	}
}

84 int 
	$search_path
(
t_cmd
 *
cmd
, char **
env
)

86 int 
i
;

87 int 
res
;

89 
i
 = 0;

90 while (
env
[
i
] && 
	`ft_strncmp
("PATH=", env[i], 5) != 0)

91 
i
++;

92 if (!
env
[
i
])

94 
	`ft_dprintf
(2, "minishell: %s: No such file or directory\n", 
cmd
->cmd[0]);

95 
g_shell
->
exit_status
 = 127;

96 
cmd
->
status
 = 127;

99 if (
cmd
->cmd[0][0] == 0)

101 
res
 = 
	`check_each_path
((
env
[
i
] + 5), 
cmd
);

102 return (
res
);

103 
	}
}

	@
1
.
0
7
113
copy_env_tab.c
exec_bin.c
exec_builtins.c
exec_one_cmd.c
execution_utils.c
get_path.c
search_path_in_env_table.c
